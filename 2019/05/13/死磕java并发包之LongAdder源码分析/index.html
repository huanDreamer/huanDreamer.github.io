<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>死磕 java并发包之LongAdder源码分析 | HUAN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文转载自 https://juejin.im/post/5cd842aa6fb9a032332b4bb8   问题（1）java8中为什么要新增LongAdder？ （2）LongAdder的实现方式？ （3）LongAdder与AtomicLong的对比？ 简介LongAdder是java8中新增的原子类，在多线程环境中，它比AtomicLong性能要高出不少，特别是写多的场景。 它是怎么实">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="死磕 java并发包之LongAdder源码分析">
<meta property="og:url" content="http://sillyfan.top/2019/05/13/死磕java并发包之LongAdder源码分析/index.html">
<meta property="og:site_name" content="HUAN">
<meta property="og:description" content="本文转载自 https://juejin.im/post/5cd842aa6fb9a032332b4bb8   问题（1）java8中为什么要新增LongAdder？ （2）LongAdder的实现方式？ （3）LongAdder与AtomicLong的对比？ 简介LongAdder是java8中新增的原子类，在多线程环境中，它比AtomicLong性能要高出不少，特别是写多的场景。 它是怎么实">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/LongAdder1.png">
<meta property="og:image" content="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/LongAdder2.png">
<meta property="og:image" content="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode_ss.jpg">
<meta property="og:updated_time" content="2019-05-30T00:52:25.430Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="死磕 java并发包之LongAdder源码分析">
<meta name="twitter:description" content="本文转载自 https://juejin.im/post/5cd842aa6fb9a032332b4bb8   问题（1）java8中为什么要新增LongAdder？ （2）LongAdder的实现方式？ （3）LongAdder与AtomicLong的对比？ 简介LongAdder是java8中新增的原子类，在多线程环境中，它比AtomicLong性能要高出不少，特别是写多的场景。 它是怎么实">
<meta name="twitter:image" content="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/LongAdder1.png">
  
    <link rel="alternate" href="/atom.xml" title="HUAN" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HUAN</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://sillyfan.top"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-死磕java并发包之LongAdder源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/13/死磕java并发包之LongAdder源码分析/" class="article-date">
  <time datetime="2019-05-13T03:14:06.006Z" itemprop="datePublished">2019-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      死磕 java并发包之LongAdder源码分析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5cd842aa6fb9a032332b4bb8" target="_blank" rel="noopener">https://juejin.im/post/5cd842aa6fb9a032332b4bb8</a> </p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>（1）java8中为什么要新增LongAdder？</p>
<p>（2）LongAdder的实现方式？</p>
<p>（3）LongAdder与AtomicLong的对比？</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LongAdder是java8中新增的原子类，在多线程环境中，它比AtomicLong性能要高出不少，特别是写多的场景。</p>
<p>它是怎么实现的呢？让我们一起来学习吧。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>LongAdder的原理是，在最初无竞争时，只更新base的值，当有多线程竞争时通过分段的思想，让不同的线程更新不同的段，最后把这些段相加就得到了完整的LongAdder存储的值。</p>
<p><img src="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/LongAdder1.png" alt="LongAdder"></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>LongAdder继承自Striped64抽象类，Striped64中定义了Cell内部类和各重要属性。</p>
<h3 id="主要内部类"><a href="#主要内部类" class="headerlink" title="主要内部类"></a>主要内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Striped64中的内部类，使用@sun.misc.Contended注解，说明里面的值消除伪共享</span><br><span class="line">@sun.misc.Contended static final class Cell &#123;</span><br><span class="line">    // 存储元素的值，使用volatile修饰保证可见性</span><br><span class="line">    volatile long value;</span><br><span class="line">    Cell(long x) &#123; value = x; &#125;</span><br><span class="line">    // CAS更新value的值</span><br><span class="line">    final boolean cas(long cmp, long val) &#123;</span><br><span class="line">        return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Unsafe实例</span><br><span class="line">    private static final sun.misc.Unsafe UNSAFE;</span><br><span class="line">    // value字段的偏移量</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; ak = Cell.class;</span><br><span class="line">            valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (ak.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cell类使用@sun.misc.Contended注解，说明是要避免伪共享的。</p>
<p>使用Unsafe的CAS更新value的值，其中value的值使用volatile修饰，保证可见性。</p>
<p>关于Unsafe的介绍请查看【<a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F0s-u-MysppIaIHVrshp9fA" target="_blank" rel="noopener">死磕 java魔法类之Unsafe解析</a>】。</p>
<p>关于伪共享的介绍请查看【<a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Frd13SOSxhLA6TT13N9ni8Q" target="_blank" rel="noopener">杂谈 什么是伪共享（false sharing）？</a>】。</p>
<h3 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 这三个属性都在Striped64中</span><br><span class="line">// cells数组，存储各个段的值</span><br><span class="line">transient volatile Cell[] cells;</span><br><span class="line">// 最初无竞争时使用的，也算一个特殊的段</span><br><span class="line">transient volatile long base;</span><br><span class="line">// 标记当前是否有线程在创建或扩容cells，或者在创建Cell</span><br><span class="line">// 通过CAS更新该值，相当于是一个锁</span><br><span class="line">transient volatile int cellsBusy;</span><br></pre></td></tr></table></figure>

<p>最初无竞争或有其它线程在创建cells数组时使用base更新值，有过竞争时使用cells更新值。</p>
<p>最初无竞争是指一开始没有线程之间的竞争，但也有可能是多线程在操作，只是这些线程没有同时去更新base的值。</p>
<p>有过竞争是指只要出现过竞争不管后面有没有竞争都使用cells更新值，规则是不同的线程hash到不同的cell上去更新，减少竞争。</p>
<h3 id="add-x-方法"><a href="#add-x-方法" class="headerlink" title="add(x)方法"></a>add(x)方法</h3><p>add(x)方法是LongAdder的主要方法，使用它可以使LongAdder中存储的值增加x，x可为正可为负。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void add(long x) &#123;</span><br><span class="line">    // as是Striped64中的cells属性</span><br><span class="line">    // b是Striped64中的base属性</span><br><span class="line">    // v是当前线程hash到的Cell中存储的值</span><br><span class="line">    // m是cells的长度减1，hash时作为掩码使用</span><br><span class="line">    // a是当前线程hash到的Cell</span><br><span class="line">    Cell[] as; long b, v; int m; Cell a;</span><br><span class="line">    // 条件1：cells不为空，说明出现过竞争，cells已经创建</span><br><span class="line">    // 条件2：cas操作base失败，说明其它线程先一步修改了base，正在出现竞争</span><br><span class="line">    if ((as = cells) != null || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        // true表示当前竞争还不激烈</span><br><span class="line">        // false表示竞争激烈，多个线程hash到同一个Cell，可能要扩容</span><br><span class="line">        boolean uncontended = true;</span><br><span class="line">        // 条件1：cells为空，说明正在出现竞争，上面是从条件2过来的</span><br><span class="line">        // 条件2：应该不会出现</span><br><span class="line">        // 条件3：当前线程所在的Cell为空，说明当前线程还没有更新过Cell，应初始化一个Cell</span><br><span class="line">        // 条件4：更新当前线程所在的Cell失败，说明现在竞争很激烈，多个线程hash到了同一个Cell，应扩容</span><br><span class="line">        if (as == null || (m = as.length - 1) &lt; 0 ||</span><br><span class="line">            // getProbe()方法返回的是线程中的threadLocalRandomProbe字段</span><br><span class="line">            // 它是通过随机数生成的一个值，对于一个确定的线程这个值是固定的</span><br><span class="line">            // 除非刻意修改它</span><br><span class="line">            (a = as[getProbe() &amp;amp; m]) == null ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            // 调用Striped64中的方法处理</span><br><span class="line">            longAccumulate(x, null, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）最初无竞争时只更新base；</p>
<p>（2）直到更新base失败时，创建cells数组；</p>
<p>（3）当多个线程竞争同一个Cell比较激烈时，可能要扩容；</p>
<h2 id="longAccumulate-方法"><a href="#longAccumulate-方法" class="headerlink" title="longAccumulate()方法"></a>longAccumulate()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">final void longAccumulate(long x, LongBinaryOperator fn,</span><br><span class="line">                              boolean wasUncontended) &#123;</span><br><span class="line">    // 存储线程的probe值</span><br><span class="line">    int h;</span><br><span class="line">    // 如果getProbe()方法返回0，说明随机数未初始化</span><br><span class="line">    if ((h = getProbe()) == 0) &#123;</span><br><span class="line">        // 强制初始化</span><br><span class="line">        ThreadLocalRandom.current(); // force initialization</span><br><span class="line">        // 重新获取probe值</span><br><span class="line">        h = getProbe();</span><br><span class="line">        // 都未初始化，肯定还不存在竞争激烈</span><br><span class="line">        wasUncontended = true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 是否发生碰撞</span><br><span class="line">    boolean collide = false;                // True if last slot nonempty</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Cell[] as; Cell a; int n; long v;</span><br><span class="line">        // cells已经初始化过</span><br><span class="line">        if ((as = cells) != null &amp;amp;&amp;amp; (n = as.length) &gt; 0) &#123;</span><br><span class="line">            // 当前线程所在的Cell未初始化</span><br><span class="line">            if ((a = as[(n - 1) &amp;amp; h]) == null) &#123;</span><br><span class="line">                // 当前无其它线程在创建或扩容cells，也没有线程在创建Cell</span><br><span class="line">                if (cellsBusy == 0) &#123;       // Try to attach new Cell</span><br><span class="line">                    // 新建一个Cell，值为当前需要增加的值</span><br><span class="line">                    Cell r = new Cell(x);   // Optimistically create</span><br><span class="line">                    // 再次检测cellsBusy，并尝试更新它为1</span><br><span class="line">                    // 相当于当前线程加锁</span><br><span class="line">                    if (cellsBusy == 0 &amp;amp;&amp;amp; casCellsBusy()) &#123;</span><br><span class="line">                        // 是否创建成功</span><br><span class="line">                        boolean created = false;</span><br><span class="line">                        try &#123;               // Recheck under lock</span><br><span class="line">                            Cell[] rs; int m, j;</span><br><span class="line">                            // 重新获取cells，并找到当前线程hash到cells数组中的位置</span><br><span class="line">                            // 这里一定要重新获取cells，因为as并不在锁定范围内</span><br><span class="line">                            // 有可能已经扩容了，这里要重新获取</span><br><span class="line">                            if ((rs = cells) != null &amp;amp;&amp;amp;</span><br><span class="line">                                (m = rs.length) &gt; 0 &amp;amp;&amp;amp;</span><br><span class="line">                                rs[j = (m - 1) &amp;amp; h] == null) &#123;</span><br><span class="line">                                // 把上面新建的Cell放在cells的j位置处</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                // 创建成功</span><br><span class="line">                                created = true;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            // 相当于释放锁</span><br><span class="line">                            cellsBusy = 0;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 创建成功了就返回</span><br><span class="line">                        // 值已经放在新建的Cell里面了</span><br><span class="line">                        if (created)</span><br><span class="line">                            break;</span><br><span class="line">                        continue;           // Slot is now non-empty</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 标记当前未出现冲突</span><br><span class="line">                collide = false;</span><br><span class="line">            &#125;</span><br><span class="line">            // 当前线程所在的Cell不为空，且更新失败了</span><br><span class="line">            // 这里简单地设为true，相当于简单地自旋一次</span><br><span class="line">            // 通过下面的语句修改线程的probe再重新尝试</span><br><span class="line">            else if (!wasUncontended)       // CAS already known to fail</span><br><span class="line">                wasUncontended = true;      // Continue after rehash</span><br><span class="line">            // 再次尝试CAS更新当前线程所在Cell的值，如果成功了就返回</span><br><span class="line">            else if (a.cas(v = a.value, ((fn == null) ? v + x :</span><br><span class="line">                                         fn.applyAsLong(v, x))))</span><br><span class="line">                break;</span><br><span class="line">            // 如果cells数组的长度达到了CPU核心数，或者cells扩容了</span><br><span class="line">            // 设置collide为false并通过下面的语句修改线程的probe再重新尝试</span><br><span class="line">            else if (n &gt;= NCPU || cells != as)</span><br><span class="line">                collide = false;            // At max size or stale</span><br><span class="line">            // 上上个elseif都更新失败了，且上个条件不成立，说明出现冲突了</span><br><span class="line">            else if (!collide)</span><br><span class="line">                collide = true;</span><br><span class="line">            // 明确出现冲突了，尝试占有锁，并扩容</span><br><span class="line">            else if (cellsBusy == 0 &amp;amp;&amp;amp; casCellsBusy()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 检查是否有其它线程已经扩容过了</span><br><span class="line">                    if (cells == as) &#123;      // Expand table unless stale</span><br><span class="line">                        // 新数组为原数组的两倍</span><br><span class="line">                        Cell[] rs = new Cell[n &lt;&lt; 1];</span><br><span class="line">                        // 把旧数组元素拷贝到新数组中</span><br><span class="line">                        for (int i = 0; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        // 重新赋值cells为新数组</span><br><span class="line">                        cells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    // 释放锁</span><br><span class="line">                    cellsBusy = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                // 已解决冲突</span><br><span class="line">                collide = false;</span><br><span class="line">                // 使用扩容后的新数组重新尝试</span><br><span class="line">                continue;                   // Retry with expanded table</span><br><span class="line">            &#125;</span><br><span class="line">            // 更新失败或者达到了CPU核心数，重新生成probe，并重试</span><br><span class="line">            h = advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        // 未初始化过cells数组，尝试占有锁并初始化cells数组</span><br><span class="line">        else if (cellsBusy == 0 &amp;amp;&amp;amp; cells == as &amp;amp;&amp;amp; casCellsBusy()) &#123;</span><br><span class="line">            // 是否初始化成功</span><br><span class="line">            boolean init = false;</span><br><span class="line">            try &#123;                           // Initialize table</span><br><span class="line">                // 检测是否有其它线程初始化过</span><br><span class="line">                if (cells == as) &#123;</span><br><span class="line">                    // 新建一个大小为2的Cell数组</span><br><span class="line">                    Cell[] rs = new Cell[2];</span><br><span class="line">                    // 找到当前线程hash到数组中的位置并创建其对应的Cell</span><br><span class="line">                    rs[h &amp;amp; 1] = new Cell(x);</span><br><span class="line">                    // 赋值给cells数组</span><br><span class="line">                    cells = rs;</span><br><span class="line">                    // 初始化成功</span><br><span class="line">                    init = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // 释放锁</span><br><span class="line">                cellsBusy = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            // 初始化成功直接返回</span><br><span class="line">            // 因为增加的值已经同时创建到Cell中了</span><br><span class="line">            if (init)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果有其它线程在初始化cells数组中，就尝试更新base</span><br><span class="line">        // 如果成功了就返回</span><br><span class="line">        else if (casBase(v = base, ((fn == null) ? v + x :</span><br><span class="line">                                    fn.applyAsLong(v, x))))</span><br><span class="line">            break;                          // Fall back on using base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）如果cells数组未初始化，当前线程会尝试占有cellsBusy锁并创建cells数组；</p>
<p>（2）如果当前线程尝试创建cells数组时，发现有其它线程已经在创建了，就尝试更新base，如果成功就返回；</p>
<p>（3）通过线程的probe值找到当前线程应该更新cells数组中的哪个Cell；</p>
<p>（4）如果当前线程所在的Cell未初始化，就占有占有cellsBusy锁并在相应的位置创建一个Cell；</p>
<p>（5）尝试CAS更新当前线程所在的Cell，如果成功就返回，如果失败说明出现冲突；</p>
<p>（5）当前线程更新Cell失败后并不是立即扩容，而是尝试更新probe值后再重试一次；</p>
<p>（6）如果在重试的时候还是更新失败，就扩容；</p>
<p>（7）扩容时当前线程占有cellsBusy锁，并把数组容量扩大到两倍，再迁移原cells数组中元素到新数组中；</p>
<p>（8）cellsBusy在创建cells数组、创建Cell、扩容cells数组三个地方用到；</p>
<h2 id="sum-方法"><a href="#sum-方法" class="headerlink" title="sum()方法"></a>sum()方法</h2><p>sum()方法是获取LongAdder中真正存储的值的大小，通过把base和所有段相加得到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public long sum() &#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    // sum初始等于base</span><br><span class="line">    long sum = base;</span><br><span class="line">    // 如果cells不为空</span><br><span class="line">    if (as != null) &#123;</span><br><span class="line">        // 遍历所有的Cell</span><br><span class="line">        for (int i = 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">            // 如果所在的Cell不为空，就把它的value累加到sum中</span><br><span class="line">            if ((a = as[i]) != null)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回sum</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到sum()方法是把base和所有段的值相加得到，那么，这里有一个问题，如果前面已经累加到sum上的Cell的value有修改，不是就没法计算到了么？</p>
<p>答案确实如此，所以LongAdder可以说不是强一致性的，它是最终一致性的。</p>
<h2 id="LongAdder-VS-AtomicLong"><a href="#LongAdder-VS-AtomicLong" class="headerlink" title="LongAdder VS AtomicLong"></a>LongAdder VS AtomicLong</h2><p>直接上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public class LongAdderVSAtomicLongTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        testAtomicLongVSLongAdder(1, 10000000);</span><br><span class="line">        testAtomicLongVSLongAdder(10, 10000000);</span><br><span class="line">        testAtomicLongVSLongAdder(20, 10000000);</span><br><span class="line">        testAtomicLongVSLongAdder(40, 10000000);</span><br><span class="line">        testAtomicLongVSLongAdder(80, 10000000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void testAtomicLongVSLongAdder(final int threadCount, final int times)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;threadCount：&quot; + threadCount + &quot;, times：&quot; + times);</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            testLongAdder(threadCount, times);</span><br><span class="line">            System.out.println(&quot;LongAdder elapse：&quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;);</span><br><span class="line"></span><br><span class="line">            long start2 = System.currentTimeMillis();</span><br><span class="line">            testAtomicLong(threadCount, times);</span><br><span class="line">            System.out.println(&quot;AtomicLong elapse：&quot; + (System.currentTimeMillis() - start2) + &quot;ms&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void testAtomicLong(final int threadCount, final int times) throws InterruptedException &#123;</span><br><span class="line">        AtomicLong atomicLong = new AtomicLong();</span><br><span class="line">        List&lt;Thread&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i=0;i&lt;threadCount;i++)&#123;</span><br><span class="line">            list.add(new Thread(() -&gt; &#123;</span><br><span class="line">                for (int j = 0; j&lt;times; j++)&#123;</span><br><span class="line">                    atomicLong.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (Thread thread : list)&#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (Thread thread : list)&#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void testLongAdder(final int threadCount, final int times) throws InterruptedException &#123;</span><br><span class="line">        LongAdder longAdder = new LongAdder();</span><br><span class="line">        List&lt;Thread&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i=0;i&lt;threadCount;i++)&#123;</span><br><span class="line">            list.add(new Thread(() -&gt; &#123;</span><br><span class="line">                for (int j = 0; j&lt;times; j++)&#123;</span><br><span class="line">                    longAdder.add(1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (Thread thread : list)&#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (Thread thread : list)&#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">threadCount：1, times：10000000</span><br><span class="line">LongAdder elapse：158ms</span><br><span class="line">AtomicLong elapse：64ms</span><br><span class="line">threadCount：10, times：10000000</span><br><span class="line">LongAdder elapse：206ms</span><br><span class="line">AtomicLong elapse：2449ms</span><br><span class="line">threadCount：20, times：10000000</span><br><span class="line">LongAdder elapse：429ms</span><br><span class="line">AtomicLong elapse：5142ms</span><br><span class="line">threadCount：40, times：10000000</span><br><span class="line">LongAdder elapse：840ms</span><br><span class="line">AtomicLong elapse：10506ms</span><br><span class="line">threadCount：80, times：10000000</span><br><span class="line">LongAdder elapse：1369ms</span><br><span class="line">AtomicLong elapse：20482ms</span><br></pre></td></tr></table></figure>

<p>可以看到当只有一个线程的时候，AtomicLong反而性能更高，随着线程越来越多，AtomicLong的性能急剧下降，而LongAdder的性能影响很小。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>（1）LongAdder通过base和cells数组来存储值；</p>
<p>（2）不同的线程会hash到不同的cell上去更新，减少了竞争；</p>
<p>（3）LongAdder的性能非常高，最终会达到一种无竞争的状态；</p>
<h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>在longAccumulate()方法中有个条件是<code>n &gt;= NCPU</code>就不会走到扩容逻辑了，而n是2的倍数，那是不是代表cells数组最大只能达到大于等于NCPU的最小2次方？</p>
<p>答案是明确的。因为同一个CPU核心同时只会运行一个线程，而更新失败了说明有两个不同的核心更新了同一个Cell，这时会重新设置更新失败的那个线程的probe值，这样下一次它所在的Cell很大概率会发生改变，如果运行的时间足够长，最终会出现同一个核心的所有线程都会hash到同一个Cell（大概率，但不一定全在一个Cell上）上去更新，所以，这里cells数组中长度并不需要太长，达到CPU核心数足够了。</p>
<p>比如，笔者的电脑是8核的，所以这里cells的数组最大只会到8，达到8就不会扩容了。</p>
<p><img src="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/LongAdder2.png" alt="LongAdder"></p>
<hr>
<p>欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。</p>
<p><img src="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode_ss.jpg" alt="qrcode"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/13/死磕java并发包之LongAdder源码分析/" data-id="cjzj9197s001ss22a3ctdqzxd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/05/13/杂谈什么是伪共享（falsesharing）？/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          杂谈 什么是伪共享（false sharing）？
        
      </div>
    </a>
  
  
    <a href="/2019/05/12/深入了解Synchronized原理/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">深入了解Synchronized原理</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HDFS/">HDFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactor/">Reactor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/">RxJava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue-js/">Vue.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端/">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微服务/">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/HDFS/" style="font-size: 10px;">HDFS</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 13.33px;">MySQL</a> <a href="/tags/Reactor/" style="font-size: 10px;">Reactor</a> <a href="/tags/RxJava/" style="font-size: 10px;">RxJava</a> <a href="/tags/Shell/" style="font-size: 10px;">Shell</a> <a href="/tags/Spring/" style="font-size: 13.33px;">Spring</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP/IP</a> <a href="/tags/Vue-js/" style="font-size: 10px;">Vue.js</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/后端/" style="font-size: 10px;">后端</a> <a href="/tags/微服务/" style="font-size: 10px;">微服务</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/服务器/" style="font-size: 10px;">服务器</a> <a href="/tags/架构/" style="font-size: 16.67px;">架构</a> <a href="/tags/源码/" style="font-size: 10px;">源码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/20/惊！史上最全的select加锁分析(Mysql)/">惊！史上最全的select加锁分析(Mysql)</a>
          </li>
        
          <li>
            <a href="/2019/08/06/万万没想到，JVM内存结构的面试题可以问的这么难？/">万万没想到，JVM内存结构的面试题可以问的这么难？</a>
          </li>
        
          <li>
            <a href="/2019/06/28/分布式数据库中间件MyCat搞起来！/">分布式数据库中间件 MyCat 搞起来！</a>
          </li>
        
          <li>
            <a href="/2019/06/20/Linux生产环境上，最常用的一套“AWK“技巧/">Linux生产环境上，最常用的一套“AWK“技巧</a>
          </li>
        
          <li>
            <a href="/2019/06/18/死磕Java内部类（一篇就够）/">死磕Java内部类（一篇就够）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 huan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>