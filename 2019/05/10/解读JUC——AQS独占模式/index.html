<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>解读 JUC —— AQS 独占模式 | HUAN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文转载自 https://juejin.im/post/5cd1d1876fb9a031eb58ae4d   1. 前言说起 JUC，我们常常会想起其中的线程池（ExecutorService）。然而，我们今天来看看另一个核心模块 AQS。 AQS 是 AbstractQueuedSynchronizer 的简称，在 JUC 中作为各种同步器的基石。举个例子，常见的 ReentrantLock">
<meta name="keywords" content="Java,源码">
<meta property="og:type" content="article">
<meta property="og:title" content="解读 JUC —— AQS 独占模式">
<meta property="og:url" content="http://sillyfan.top/2019/05/10/解读JUC——AQS独占模式/index.html">
<meta property="og:site_name" content="HUAN">
<meta property="og:description" content="本文转载自 https://juejin.im/post/5cd1d1876fb9a031eb58ae4d   1. 前言说起 JUC，我们常常会想起其中的线程池（ExecutorService）。然而，我们今天来看看另一个核心模块 AQS。 AQS 是 AbstractQueuedSynchronizer 的简称，在 JUC 中作为各种同步器的基石。举个例子，常见的 ReentrantLock">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/5/8/16a939a72c2cb3ce?imageView2/0/w/1280/h/960/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/5/8/16a939a72c3d316d?imageView2/0/w/1280/h/960/ignore-error/1">
<meta property="og:updated_time" content="2019-05-30T00:52:25.434Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="解读 JUC —— AQS 独占模式">
<meta name="twitter:description" content="本文转载自 https://juejin.im/post/5cd1d1876fb9a031eb58ae4d   1. 前言说起 JUC，我们常常会想起其中的线程池（ExecutorService）。然而，我们今天来看看另一个核心模块 AQS。 AQS 是 AbstractQueuedSynchronizer 的简称，在 JUC 中作为各种同步器的基石。举个例子，常见的 ReentrantLock">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2019/5/8/16a939a72c2cb3ce?imageView2/0/w/1280/h/960/ignore-error/1">
  
    <link rel="alternate" href="/atom.xml" title="HUAN" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HUAN</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://sillyfan.top"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-解读JUC——AQS独占模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/10/解读JUC——AQS独占模式/" class="article-date">
  <time datetime="2019-05-10T07:21:06.000Z" itemprop="datePublished">2019-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      解读 JUC —— AQS 独占模式
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5cd1d1876fb9a031eb58ae4d" target="_blank" rel="noopener">https://juejin.im/post/5cd1d1876fb9a031eb58ae4d</a> </p>
</blockquote>
<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>说起 JUC，我们常常会想起其中的线程池（ExecutorService）。然而，我们今天来看看另一个核心模块 AQS。</p>
<p>AQS 是 AbstractQueuedSynchronizer 的简称，在 JUC 中作为各种同步器的基石。举个例子，常见的 ReentrantLock 就是由它实现的。</p>
<h1 id="2-如何实现一个锁？"><a href="#2-如何实现一个锁？" class="headerlink" title="2. 如何实现一个锁？"></a>2. 如何实现一个锁？</h1><p>我们知道，java 有一个关键字 synchronized 来给一段代码加锁，可是这是 JVM 层面的事情。那么问题来了，如何在 java 代码层面来实现模拟一个锁？</p>
<p>即实现这样一个接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package java.util.concurrent.locks;</span><br><span class="line"></span><br><span class="line">public interface Lock &#123;</span><br><span class="line">    void lock();</span><br><span class="line"></span><br><span class="line">    void unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>一个简单的想法是：让所有线程去竞争一个变量owner，确保只有一个线程成功，并设置自己为owner，其他线程陷入死循环等待。这便是所谓的<strong>自旋锁</strong>。</p>
<p>一个简单的代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line">public class SpinLock &#123;</span><br><span class="line">   private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">   public void lock() &#123;</span><br><span class="line">       Thread currentThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">       // 如果锁未被占用，则设置当前线程为锁的拥有者</span><br><span class="line">       while (!owner.compareAndSet(null, currentThread)) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void unlock() &#123;</span><br><span class="line">       Thread currentThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">       // 只有锁的拥有者才能释放锁</span><br><span class="line">       owner.compareAndSet(currentThread, null);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扯这个自旋锁，主要是为了引出 AQS 背后的算法 <code>CLH锁</code>。</p>
<p>关于<code>CLH锁</code>更多细节可以参考篇文章：</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fcoderbee.net%2Findex.php%2Fconcurrent%2F20131115%2F577" target="_blank" rel="noopener">自旋锁、排队自旋锁、MCS锁、CLH锁</a></p>
<h1 id="3-AQS-的实现"><a href="#3-AQS-的实现" class="headerlink" title="3. AQS 的实现"></a>3. AQS 的实现</h1><p>CLH锁的思想，简单的说就是：一群人去ATM取钱，头一个人拿到锁，在里面用银行卡取钱，其余的人在后面<strong>排队等待</strong>；前一个人取完钱出来，<strong>唤醒</strong>下一个人进去取钱。</p>
<p>关键部分翻译成代码就是：</p>
<ul>
<li>排队 -&gt; 队列</li>
<li>等待/唤醒 -&gt; wait()/notify() 或者别的什么 api </li>
</ul>
<h2 id="3-1-同步队列"><a href="#3-1-同步队列" class="headerlink" title="3.1 同步队列"></a>3.1 同步队列</h2><p>AQS 使用节点为 Node 的双向链表作为<strong>同步队列</strong>。拿到锁的线程可以继续执行代码，没拿到的线程就进入这个队列排队。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractQueuedSynchronizer ... &#123;</span><br><span class="line">    // 队列头</span><br><span class="line">    private transient volatile Node head;</span><br><span class="line">    // 队列尾</span><br><span class="line">    private transient volatile Node tail;</span><br><span class="line"></span><br><span class="line">    static final class Node &#123;</span><br><span class="line">        /** 共享模式，可用于实现 CountDownLatch */</span><br><span class="line">        static final Node SHARED = new Node();</span><br><span class="line">        /** 独占模式，可用于实现 ReentrantLock */</span><br><span class="line">        static final Node EXCLUSIVE = null;</span><br><span class="line">	</span><br><span class="line">        /** 取消 */</span><br><span class="line">        static final int CANCELLED =  1;</span><br><span class="line">        /** 意味着它的后继节点的线程在排队，等待被唤醒 */</span><br><span class="line">        static final int SIGNAL    = -1;</span><br><span class="line">        /** 等待在条件上（与Condition相关，暂不解释） */</span><br><span class="line">        static final int CONDITION = -2;</span><br><span class="line">        /**</span><br><span class="line">         * 与共享模式相关，暂不解释</span><br><span class="line">         */</span><br><span class="line">        static final int PROPAGATE = -3;</span><br><span class="line">	</span><br><span class="line">        // 可取值：CANCELLED, 0, SIGNAL, CONDITION, PROPAGATE</span><br><span class="line">        volatile int waitStatus;</span><br><span class="line">	</span><br><span class="line">        volatile Node prev;</span><br><span class="line">	</span><br><span class="line">        volatile Node next;</span><br><span class="line">	</span><br><span class="line">        volatile Thread thread;</span><br><span class="line">	    </span><br><span class="line">        Node nextWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个队列大体上长这样：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fa8d27ba5db49" target="_blank" rel="noopener">图片来源</a></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/8/16a939a72c2cb3ce?imageView2/0/w/1280/h/960/ignore-error/1" alt="sync queue"></p>
<p>条件队列是为了支持 Lock.newCondition() 这个功能，暂时不care，先跳过。</p>
<h2 id="3-2-独占模式的-api"><a href="#3-2-独占模式的-api" class="headerlink" title="3.2 独占模式的 api"></a>3.2 独占模式的 api</h2><p>AQS 支持独占锁（Exclusive）和共享锁（Share）两种模式：</p>
<ul>
<li>独占锁：只能被一个线程获取到 (ReentrantLock)；</li>
<li>共享锁：可以被多个线程同时获取 (CountDownLatch、ReadWriteLock 的读锁)。</li>
</ul>
<p>这边我们只看独占模式，它对外提供一套 api：</p>
<ul>
<li>acquire(int n)：获取n个资源（锁）</li>
<li>release(int n)：释放n个资源（锁）</li>
</ul>
<p>简单看一眼怎么用的 (ReentrantLock 的例子):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLock implements Lock, java.io.Serializable &#123;</span><br><span class="line">    private final Sync sync;</span><br><span class="line">    </span><br><span class="line">    abstract static class Sync extends AbstractQueuedSynchronizer &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        sync.acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        sync.release(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，AQS 封装了排队、阻塞、唤醒之类的操作，使得实现一个锁变的如此简洁。</p>
<h2 id="3-2-1-acquire-int"><a href="#3-2-1-acquire-int" class="headerlink" title="3.2.1 acquire(int)"></a>3.2.1 acquire(int)</h2><p>获取资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;amp;&amp;amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数很短，其中 tryAcquire(int) 为模板方法，留给子类实现。类似 Activity.onCreate()。</p>
<p>根据 tryAcquire(arg) 的结果，分两种情况：</p>
<pre><code>* 返回 true: 该线程拿到锁，由于短路，直接跳出 if，该线程可以往下执行自己的业务代码。
* 返回 false: 该线程没有拿到锁，会继续走 acquireQueued()，执行排队等待逻辑。</code></pre><h3 id="3-2-1-1-addWaiter-Node"><a href="#3-2-1-1-addWaiter-Node" class="headerlink" title="3.2.1.1 addWaiter(Node)"></a>3.2.1.1 addWaiter(Node)</h3><p>这一步把当前线程（Thread.currentThread()）作为一个Node节点，加入同步队列的尾部，并标记为独占模式。</p>
<p>当然，加入队列这个动作，要保证<strong>线程安全</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">    // 1处尝试更快地 enq(), 成功的话直接 return。失败的话, 在2处退化为完整版的 enq()，相对更慢些</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    if (pred != null) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123; // 1</span><br><span class="line">            pred.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node); // 2</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    // 神奇的死循环 + CAS</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        if (t == null) &#123; // Must initialize</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这边有一个<strong>死循环 + CAS</strong>的神奇操作，这是非阻塞算法的经典操作，可自行查阅相关资料。简单的说，非阻塞算法就是在多线程的情况下，不加锁同时保证某个变量（本例中为双向链表）的线程安全，而且通常比 synchronized 的效率要高。</p>
<h3 id="3-2-1-2-acquireQueued-Node，int"><a href="#3-2-1-2-acquireQueued-Node，int" class="headerlink" title="3.2.1.2 acquireQueued(Node，int)"></a>3.2.1.2 acquireQueued(Node，int)</h3><p>这个函数主要做两件事：</p>
<pre><code>* 查看prev的waitStatus，看是不是需要阻塞，需要的话阻塞该线程
* 排在队首的家伙调用了release()，会唤醒老二。老二尝试去获得锁，成功的话自己变成队首，跳出循环。</code></pre><p>结合这张图来看，每次出队完需要确保 head 始终指向占用资源的线程：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/8/16a939a72c3d316d?imageView2/0/w/1280/h/960/ignore-error/1" alt="sync queue"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        // 这又是一个死循环 + CAS，这次CAS比较隐蔽，在 shouldParkAfterFailedAcquire()里边</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) &#123; // 排在队首的后面，看看能不能获得锁，成功的话自己变成队首</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 这里失败会做一些回滚操作，不分析</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这边的 interrupted 主要是保证这样一个功能。线程在排队的时候不响应中断，直到出来以后，如果等待的过程中被中断过，作为弥补，立即相应中断（即调用selfInterrupt()）。</p>
<h3 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire()"></a>shouldParkAfterFailedAcquire()</h3><p>查看prev的waitStatus，看是不是需要阻塞。可以预见的是，经过几次死循环，全部都会变成SIGNAL状态。之后全部陷入阻塞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    int ws = pred.waitStatus; // 查看前驱节点的状态</span><br><span class="line">    if (ws == Node.SIGNAL) // SIGNAL: 可以安全的阻塞</span><br><span class="line">        return true;</span><br><span class="line">    if (ws &gt; 0) &#123; // CANCEL: 取消排队的节点，直接从队列中清除。</span><br><span class="line">        do &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; else &#123; // 0 or PROPAGATE: 需要变成 SIGNAL，但不能立即阻塞，需要重走外层的死循环二次确认。</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得一提的是，阻塞和唤醒没有使用常说的 wait()/notify()，而是使用了 LockSupport.park()/unpark()。只有使用 synchronized 获取锁的对象才能使用 wait，ReentrantLock.newCondition 提供的 await/signal 也是 LockSupport.park()/unpark() 实现的。<br>参考 <a href="https://pqpo.me/2019/01/30/learn-java-lock-block/" target="_blank" rel="noopener">https://pqpo.me/2019/01/30/learn-java-lock-block/</a></p>
<h2 id="3-2-2-release-int"><a href="#3-2-2-release-int" class="headerlink" title="3.2.2 release(int)"></a>3.2.2 release(int)</h2><p>释放资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;amp;&amp;amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 唤醒next节点对应的线程，通常就是老二（直接后继）。</span><br><span class="line">     * 如果是null，或者是cancel状态（出现异常如线程遇到空指针挂掉了），</span><br><span class="line">     * 那么跳过cancel节点，找到后继节点。</span><br><span class="line">     */</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">        for (Node t = tail; t != null &amp;amp;&amp;amp; t != node; t = t.prev)</span><br><span class="line">            if (t.waitStatus &lt;= 0)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    // 唤醒 node.next</span><br><span class="line">    if (s != null)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放的逻辑比较简单。注意一点，对于 next 节点 unpark()，相当于在把 next 节点从 acquireQueued() 中的死循环中解放出来。</p>
<p>回到 ATM 的例子，相当于，他取完钱，轮到后一个人取钱了。这样逻辑全部都串起来了。</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>这样，顺着独占锁这条线，AQS 的独占模式就分析完了。其他还有用于实现闭锁的共享模式，用于实现 Condition 的条件队列就不展开了。</p>
<h1 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h1><p><a href="https://link.juejin.im?target=https%3A%2F%2Fmy.oschina.net%2FUBW%2Fblog%2F2995774" target="_blank" rel="noopener">Java并发编程实战（chapter_4）（AQS源码分析）</a></p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fa8d27ba5db49" target="_blank" rel="noopener">JUC源码分析—AQS</a></p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fcoderbee.net%2Findex.php%2Fconcurrent%2F20131115%2F577" target="_blank" rel="noopener">自旋锁、排队自旋锁、MCS锁、CLH锁</a></p>
<p>《JAVA并发编程实践》</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/10/解读JUC——AQS独占模式/" data-id="cjx1h8cz40022662alh8mbw7i" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/05/11/Java中的Wait和Notify机制/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Java 中的 Wait 和 Notify 机制
        
      </div>
    </a>
  
  
    <a href="/2019/05/10/面试官：说说你对ThreadLocal的了解/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">面试官：说说你对ThreadLocal的了解</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HDFS/">HDFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactor/">Reactor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/">RxJava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue-js/">Vue.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端/">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微服务/">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/HDFS/" style="font-size: 10px;">HDFS</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Reactor/" style="font-size: 10px;">Reactor</a> <a href="/tags/RxJava/" style="font-size: 10px;">RxJava</a> <a href="/tags/Spring/" style="font-size: 13.33px;">Spring</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP/IP</a> <a href="/tags/Vue-js/" style="font-size: 10px;">Vue.js</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/后端/" style="font-size: 10px;">后端</a> <a href="/tags/微服务/" style="font-size: 10px;">微服务</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/服务器/" style="font-size: 10px;">服务器</a> <a href="/tags/架构/" style="font-size: 16.67px;">架构</a> <a href="/tags/源码/" style="font-size: 10px;">源码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/18/死磕Java内部类（一篇就够）/">死磕Java内部类（一篇就够）</a>
          </li>
        
          <li>
            <a href="/2019/06/06/面试那点小事，你从未见过的springboot面试集锦（附详细答案）/">面试那点小事，你从未见过的spring boot面试集锦（附详细答案）</a>
          </li>
        
          <li>
            <a href="/2019/06/01/SpringBoot实现动态控制定时任务-支持多参数/">SpringBoot实现动态控制定时任务-支持多参数</a>
          </li>
        
          <li>
            <a href="/2019/05/31/感受lambda之美，推荐收藏，需要时查阅/">感受lambda之美，推荐收藏，需要时查阅</a>
          </li>
        
          <li>
            <a href="/2019/05/30/README/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 huan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>