<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>感受lambda之美，推荐收藏，需要时查阅 | HUAN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文转载自 https://juejin.im/post/5ce66801e51d455d850d3a4a一、引言二、java重要的函数式接口1、什么是函数式接口1.1 java8自带的常用函数式接口。1.2 惰性求值与及早求值2、常用的流2.1 collect(Collectors.toList())2.2 filter2.3 map2.4 flatMap2.5 max和min2.6 coun">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="感受lambda之美，推荐收藏，需要时查阅">
<meta property="og:url" content="http://sillyfan.top/2019/05/31/感受lambda之美，推荐收藏，需要时查阅/index.html">
<meta property="og:site_name" content="HUAN">
<meta property="og:description" content="本文转载自 https://juejin.im/post/5ce66801e51d455d850d3a4a一、引言二、java重要的函数式接口1、什么是函数式接口1.1 java8自带的常用函数式接口。1.2 惰性求值与及早求值2、常用的流2.1 collect(Collectors.toList())2.2 filter2.3 map2.4 flatMap2.5 max和min2.6 coun">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/5/23/16ae40638d420acd?imageView2/0/w/1280/h/960/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/5/23/16ae40638d2c0a51?imageView2/0/w/1280/h/960/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/5/23/16ae40638d1c6610?imageView2/0/w/1280/h/960/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/5/23/16ae40638c4cca86?imageView2/0/w/1280/h/960/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/5/23/16ae40638c52397b?imageView2/0/w/1280/h/960/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/5/23/16ae4063943b9487?imageView2/0/w/1280/h/960/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/5/23/16ae4063f5d78c78?imageView2/0/w/1280/h/960/ignore-error/1">
<meta property="og:updated_time" content="2019-05-31T08:43:37.745Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="感受lambda之美，推荐收藏，需要时查阅">
<meta name="twitter:description" content="本文转载自 https://juejin.im/post/5ce66801e51d455d850d3a4a一、引言二、java重要的函数式接口1、什么是函数式接口1.1 java8自带的常用函数式接口。1.2 惰性求值与及早求值2、常用的流2.1 collect(Collectors.toList())2.2 filter2.3 map2.4 flatMap2.5 max和min2.6 coun">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2019/5/23/16ae40638d420acd?imageView2/0/w/1280/h/960/ignore-error/1">
  
    <link rel="alternate" href="/atom.xml" title="HUAN" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HUAN</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://sillyfan.top"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-感受lambda之美，推荐收藏，需要时查阅" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/31/感受lambda之美，推荐收藏，需要时查阅/" class="article-date">
  <time datetime="2019-05-31T08:43:37.037Z" itemprop="datePublished">2019-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      感受lambda之美，推荐收藏，需要时查阅
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5ce66801e51d455d850d3a4a" target="_blank" rel="noopener">https://juejin.im/post/5ce66801e51d455d850d3a4a</a><br><a href="#h">一、引言</a><a href="#hjava">二、java重要的函数式接口</a><a href="#h1">1、什么是函数式接口</a><a href="#h11java8">1.1 java8自带的常用函数式接口。</a><a href="#h12">1.2 惰性求值与及早求值</a><a href="#h2">2、常用的流</a><a href="#h21collectcollectorstolist">2.1 collect(Collectors.toList())</a><a href="#h22filter">2.2 filter</a><a href="#h23map">2.3 map</a><a href="#h24flatmap">2.4 flatMap</a><a href="#h25maxmin">2.5 max和min</a><a href="#h26count">2.6 count</a><a href="#h27reduce">2.7 reduce</a><a href="#h-1">三、高级集合类及收集器</a><a href="#h31">3.1 转换成值</a><a href="#h32">3.2 转换成块</a><a href="#h33">3.3 数据分组</a><a href="#h34">3.4 字符串拼接</a><a href="#h-2">四、总结</a></p>
</blockquote>
<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>java8最大的特性就是引入Lambda表达式，即函数式编程，可以将行为进行传递。<strong>总结就是：使用不可变值与函数，函数对不可变值进行处理，映射成另一个值。</strong></p>
<h3 id="二、java重要的函数式接口"><a href="#二、java重要的函数式接口" class="headerlink" title="二、java重要的函数式接口"></a>二、java重要的函数式接口</h3><h3 id="1、什么是函数式接口"><a href="#1、什么是函数式接口" class="headerlink" title="1、什么是函数式接口"></a>1、什么是函数式接口</h3><p><strong>函数接口是只有一个抽象方法的接口，用作 Lambda 表达式的类型。使用@FunctionalInterface注解修饰的类，编译器会检测该类是否只有一个抽象方法或接口，否则，会报错。可以有多个默认方法，静态方法。</strong></p>
<h3 id="1-1-java8自带的常用函数式接口。"><a href="#1-1-java8自带的常用函数式接口。" class="headerlink" title="1.1 java8自带的常用函数式接口。"></a>1.1 java8自带的常用函数式接口。</h3><table>
<thead>
<tr>
<th align="center">函数接口</th>
<th align="center">抽象方法</th>
<th align="center">功能</th>
<th align="center">参数</th>
<th align="center">返回类型</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Predicate</td>
<td align="center">test(T t)</td>
<td align="center">判断真假</td>
<td align="center">T</td>
<td align="center">boolean</td>
<td align="center">9龙的身高大于185cm吗？</td>
</tr>
<tr>
<td align="center">Consumer</td>
<td align="center">accept(T t)</td>
<td align="center">消费消息</td>
<td align="center">T</td>
<td align="center">void</td>
<td align="center">输出一个值</td>
</tr>
<tr>
<td align="center">Function</td>
<td align="center">R apply(T t)</td>
<td align="center">将T映射为R（转换功能）</td>
<td align="center">T</td>
<td align="center">R</td>
<td align="center">获得student对象的名字</td>
</tr>
<tr>
<td align="center">Supplier</td>
<td align="center">T get()</td>
<td align="center">生产消息</td>
<td align="center">None</td>
<td align="center">T</td>
<td align="center">工厂方法</td>
</tr>
<tr>
<td align="center">UnaryOperator</td>
<td align="center">T apply(T t)</td>
<td align="center">一元操作</td>
<td align="center">T</td>
<td align="center">T</td>
<td align="center">逻辑非（!）</td>
</tr>
<tr>
<td align="center">BinaryOperator</td>
<td align="center">apply(T t, U u)</td>
<td align="center">二元操作</td>
<td align="center">(T，T)</td>
<td align="center">(T)</td>
<td align="center">求两个数的乘积（*）</td>
</tr>
<tr>
<td align="center"><code>{     {         Predicate&lt;Integer&gt; predicate = x -&gt; x &gt; ;         Student student =  Student(, , );         System.out.println(              + predicate.test(student.getStature()));         Consumer&lt;String&gt; consumer = System.out::println;         consumer.accept();         Function&lt;Student, String&gt; function = Student::getName;         String name = function.apply(student);         System.out.println(name);         Supplier&lt;Integer&gt; supplier =              () -&gt; Integer.valueOf(BigDecimal.TEN.toString());         System.out.println(supplier.get());         UnaryOperator&lt;Boolean&gt; unaryOperator = uglily -&gt; !uglily;         Boolean apply2 = unaryOperator.apply();         System.out.println(apply2);         BinaryOperator&lt;Integer&gt; operator = (x, y) -&gt; x * y;         Integer integer = operator.apply(, );         System.out.println(integer);         test(() -&gt; );     }          {         String work = worker.work();         System.out.println(work);     }      {         ;     } }</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>以上演示了lambda接口的使用及自定义一个函数式接口并使用。下面，我们看看java8将函数式接口封装到流中如何高效的帮助我们处理集合。</p>
<p><strong>注意：Student::getName</strong>例子中这种编写lambda表达式的方式称为<strong>方法引用。</strong>格式为<strong>ClassNmae::methodName</strong>。是不是很神奇，java8就是这么迷人。</p>
<p><strong>示例：本篇所有示例都基于以下三个类。OutstandingClass：班级；Student：学生；SpecialityEnum：特长。</strong><br><img src="https://user-gold-cdn.xitu.io/2019/5/23/16ae40638d420acd?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<h3 id="1-2-惰性求值与及早求值"><a href="#1-2-惰性求值与及早求值" class="headerlink" title="1.2 惰性求值与及早求值"></a>1.2 惰性求值与及早求值</h3><p><strong>惰性求值：只描述Stream，操作的结果也是Stream，这样的操作称为惰性求值。</strong>惰性求值可以像建造者模式一样链式使用，最后再使用及早求值得到最终结果。</p>
<p><strong>及早求值：得到最终的结果而不是Stream，这样的操作称为及早求值。</strong></p>
<h3 id="2、常用的流"><a href="#2、常用的流" class="headerlink" title="2、常用的流"></a>2、常用的流</h3><h3 id="2-1-collect-Collectors-toList"><a href="#2-1-collect-Collectors-toList" class="headerlink" title="2.1 collect(Collectors.toList())"></a>2.1 collect(Collectors.toList())</h3><p><strong>将流转换为list。还有toSet()，toMap()等。及早求值</strong>。
<code>{     {         List&lt;Student&gt; studentList = Stream.of( Student(, , ),                  Student(, , ),                  Student(, , )).collect(Collectors.toList());         System.out.println(studentList);     } }</code></p>
<h3 id="2-2-filter"><a href="#2-2-filter" class="headerlink" title="2.2 filter"></a>2.2 filter</h3><p>顾名思义，起<strong>过滤筛选</strong>的作用。<strong>内部就是Predicate接口。惰性求值。</strong><br><img src="https://user-gold-cdn.xitu.io/2019/5/23/16ae40638d2c0a51?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>比如我们筛选出出身高小于180的同学。</p>
<p><code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));         List&lt;Student&gt; list = students.stream()             .filter(stu -&gt; stu.getStature() &lt; )             .collect(Collectors.toList());         System.out.println(list);     } }</code></p>
<h3 id="2-3-map"><a href="#2-3-map" class="headerlink" title="2.3 map"></a>2.3 map</h3><p><strong>转换功能，内部就是Function接口。惰性求值</strong><br><img src="https://user-gold-cdn.xitu.io/2019/5/23/16ae40638d1c6610?imageView2/0/w/1280/h/960/ignore-error/1" alt> <code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));         List&lt;String&gt; names = students.stream().map(student -&gt; student.getName())                 .collect(Collectors.toList());         System.out.println(names);     } }</code></p>
<p>例子中将student对象转换为String对象，获取student的名字。</p>
<h3 id="2-4-flatMap"><a href="#2-4-flatMap" class="headerlink" title="2.4 flatMap"></a>2.4 flatMap</h3><p><strong>将多个Stream合并为一个Stream。惰性求值</strong><br><img src="https://user-gold-cdn.xitu.io/2019/5/23/16ae40638c4cca86?imageView2/0/w/1280/h/960/ignore-error/1" alt> <code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));         List&lt;Student&gt; studentList = Stream.of(students,                 asList( Student(, , ),                          Student(, , )))                 .flatMap(students1 -&gt; students1.stream()).collect(Collectors.toList());         System.out.println(studentList);     } }</code></p>
<p>调用Stream.of的静态方法将两个list转换为Stream，再通过flatMap将两个流合并为一个。</p>
<h3 id="2-5-max和min"><a href="#2-5-max和min" class="headerlink" title="2.5 max和min"></a>2.5 max和min</h3><p>我们经常会在集合中<strong>求最大或最小值</strong>，使用流就很方便。<strong>及早求值。</strong><br><code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));         Optional&lt;Student&gt; max = students.stream()             .max(Comparator.comparing(stu -&gt; stu.getAge()));         Optional&lt;Student&gt; min = students.stream()             .min(Comparator.comparing(stu -&gt; stu.getAge()));                   (max.isPresent()) {             System.out.println(max.get());         }          (min.isPresent()) {             System.out.println(min.get());         }     } }</code></p>
<p><strong>max、min接收一个Comparator</strong>（例子中使用java8自带的静态函数，只需要传进需要比较值即可。）并且返回一个Optional对象，该对象是java8新增的类，专门为了防止null引发的空指针异常。可以使用max.isPresent()判断是否有值；可以使用max.orElse(new Student())，当值为null时就使用给定值；也可以使用max.orElseGet(() -&gt; new Student());这需要传入一个Supplier的lambda表达式。</p>
<h3 id="2-6-count"><a href="#2-6-count" class="headerlink" title="2.6 count"></a>2.6 count</h3><p><strong>统计功能，一般都是结合filter使用，因为先筛选出我们需要的再统计即可。及早求值</strong><br><code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));          count = students.stream().filter(s1 -&gt; s1.getAge() &lt; ).count();         System.out.println( + count);     } }</code></p>
<h3 id="2-7-reduce"><a href="#2-7-reduce" class="headerlink" title="2.7 reduce"></a>2.7 reduce</h3><p><strong>reduce 操作可以实现从一组值中生成一个值</strong>。在上述例子中用到的 count 、 min 和 max 方<br>法，因为常用而被纳入标准库中。事实上，这些方法都是 reduce 操作。<strong>及早求值。</strong><br><img src="https://user-gold-cdn.xitu.io/2019/5/23/16ae40638c52397b?imageView2/0/w/1280/h/960/ignore-error/1" alt> <code>{     {         Integer reduce = Stream.of(, , , ).reduce(, (acc, x) -&gt; acc+ x);         System.out.println(reduce);     } }</code></p>
<p>我们看得reduce接收了一个初始值为0的累加器，依次取出值与累加器相加，最后累加器的值就是最终的结果。</p>
<h3 id="三、高级集合类及收集器"><a href="#三、高级集合类及收集器" class="headerlink" title="三、高级集合类及收集器"></a>三、高级集合类及收集器</h3><h3 id="3-1-转换成值"><a href="#3-1-转换成值" class="headerlink" title="3.1 转换成值"></a>3.1 转换成值</h3><p><strong>收集器，一种通用的、从流生成复杂值的结构。</strong>只要将它传给 collect 方法，所有<br>的流就都可以使用它了。标准类库已经提供了一些有用的收集器，<strong>以下示例代码中的收集器都是从 java.util.stream.Collectors 类中静态导入的。</strong><br><code>{     {         List&lt;Student&gt; students1 =  ArrayList&lt;&gt;();         students1.add( Student(, , ));         students1.add( Student(, , ));         students1.add( Student(, , ));         OutstandingClass ostClass1 =  OutstandingClass(, students1);                  List&lt;Student&gt; students2 =  ArrayList&lt;&gt;(students1);         students2.remove();         OutstandingClass ostClass2 =  OutstandingClass(, students2);                  Stream&lt;OutstandingClass&gt; classStream = Stream.of(ostClass1, ostClass2);         OutstandingClass outstandingClass = biggestGroup(classStream);         System.out.println( + outstandingClass.getName());         System.out.println( + averageNumberOfStudent(students1));     }          {          outstandingClasses.collect(                 maxBy(comparing(ostClass -&gt; ostClass.getStudents().size())))                 .orElseGet(OutstandingClass::);     }          {          students.stream().collect(averagingInt(Student::getAge));     } }</code></p>
<p>maxBy或者minBy就是求最大值与最小值。</p>
<h3 id="3-2-转换成块"><a href="#3-2-转换成块" class="headerlink" title="3.2 转换成块"></a>3.2 转换成块</h3><p><strong>常用的流操作是将其分解成两个集合，Collectors.partitioningBy帮我们实现了，接收一个Predicate函数式接口。</strong><br><img src="https://user-gold-cdn.xitu.io/2019/5/23/16ae4063943b9487?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>将示例学生分为会唱歌与不会唱歌的两个集合。</p>
<p><code>{     {                  Map&lt;Boolean, List&lt;Student&gt;&gt; listMap = students.stream().collect(             Collectors.partitioningBy(student -&gt; student.getSpecialities().                                       contains(SpecialityEnum.SING)));     } }</code></p>
<h3 id="3-3-数据分组"><a href="#3-3-数据分组" class="headerlink" title="3.3 数据分组"></a>3.3 数据分组</h3><p>数据分组是一种更自然的分割数据操作，与将数据分成 ture 和 false 两部分不同，<strong>可以使</strong><br><strong>用任意值对数据分组。Collectors.groupingBy接收一个Function做转换。</strong><br><img src="https://user-gold-cdn.xitu.io/2019/5/23/16ae4063f5d78c78?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p><strong>如图，我们使用groupingBy将根据进行分组为圆形一组，三角形一组，正方形一组。</strong></p>
<p>例子：根据学生第一个特长进行分组<br><code>{     {                   Map&lt;SpecialityEnum, List&lt;Student&gt;&gt; listMap =               students.stream().collect(              Collectors.groupingBy(student -&gt; student.getSpecialities().get()));     } }</code></p>
<p><strong>Collectors.groupingBy与SQL 中的 group by 操作是一样的。</strong></p>
<h3 id="3-4-字符串拼接"><a href="#3-4-字符串拼接" class="headerlink" title="3.4 字符串拼接"></a>3.4 字符串拼接</h3><p>如果将所有学生的名字拼接起来，怎么做呢？通常只能创建一个StringBuilder，循环拼接。使用Stream，使用Collectors.joining()简单容易。<br><code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));          String names = students.stream()              .map(Student::getName).collect(Collectors.joining(,,));         System.out.println(names);     } }</code></p>
<p><strong>joining接收三个参数，第一个是分界符，第二个是前缀符，第三个是结束符。也可以不传入参数Collectors.joining()，这样就是直接拼接。</strong></p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>本篇主要从实际使用讲述了常用的方法及流，使用java8可以很清晰表达你要做什么，代码也很简洁。本篇例子主要是为了讲解较为简单，大家可以去使用java8重构自己现有的代码，自行领会lambda的奥妙。本文说的Stream要组合使用才会发挥更大的功能，链式调用很迷人，根据自己的业务去做吧。</p>
<p><strong>整理不易，希望点赞支持支持。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/31/感受lambda之美，推荐收藏，需要时查阅/" data-id="cjwkcoovh001fn02a3nop0csu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/06/01/SpringBoot实现动态控制定时任务-支持多参数/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          SpringBoot实现动态控制定时任务-支持多参数
        
      </div>
    </a>
  
  
    <a href="/2019/05/30/README/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HDFS/">HDFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactor/">Reactor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/">RxJava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue-js/">Vue.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端/">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微服务/">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/HDFS/" style="font-size: 10px;">HDFS</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Reactor/" style="font-size: 10px;">Reactor</a> <a href="/tags/RxJava/" style="font-size: 10px;">RxJava</a> <a href="/tags/Spring/" style="font-size: 13.33px;">Spring</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP/IP</a> <a href="/tags/Vue-js/" style="font-size: 10px;">Vue.js</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/后端/" style="font-size: 10px;">后端</a> <a href="/tags/微服务/" style="font-size: 10px;">微服务</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/服务器/" style="font-size: 10px;">服务器</a> <a href="/tags/架构/" style="font-size: 16.67px;">架构</a> <a href="/tags/源码/" style="font-size: 10px;">源码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/06/面试那点小事，你从未见过的springboot面试集锦（附详细答案）/">面试那点小事，你从未见过的spring boot面试集锦（附详细答案）</a>
          </li>
        
          <li>
            <a href="/2019/06/01/SpringBoot实现动态控制定时任务-支持多参数/">SpringBoot实现动态控制定时任务-支持多参数</a>
          </li>
        
          <li>
            <a href="/2019/05/31/感受lambda之美，推荐收藏，需要时查阅/">感受lambda之美，推荐收藏，需要时查阅</a>
          </li>
        
          <li>
            <a href="/2019/05/30/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/05/30/Effective Java/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 huan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>