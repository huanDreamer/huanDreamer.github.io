<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>死磕Java内部类（一篇就够） | HUAN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文转载自 https://juejin.im/post/5d0821315188254c434686c8Java内部类，相信大家都用过，但是多数同学可能对它了解的并不深入，只是靠记忆来完成日常工作，却不能融会贯通，遇到奇葩问题更是难以有思路去解决。这篇文章带大家一起死磕Java内部类的方方面面。 友情提示：这篇文章的讨论基于JDK版本 1.8.0_191  开篇问题我一直觉得技术是工具，是一定">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="死磕Java内部类（一篇就够）">
<meta property="og:url" content="http://sillyfan.top/2019/06/18/死磕Java内部类（一篇就够）/index.html">
<meta property="og:site_name" content="HUAN">
<meta property="og:description" content="本文转载自 https://juejin.im/post/5d0821315188254c434686c8Java内部类，相信大家都用过，但是多数同学可能对它了解的并不深入，只是靠记忆来完成日常工作，却不能融会贯通，遇到奇葩问题更是难以有思路去解决。这篇文章带大家一起死磕Java内部类的方方面面。 友情提示：这篇文章的讨论基于JDK版本 1.8.0_191  开篇问题我一直觉得技术是工具，是一定">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/6/18/16b67c1a51958f99?imageView2/0/w/1280/h/960/ignore-error/1">
<meta property="og:updated_time" content="2019-06-18T07:18:47.860Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="死磕Java内部类（一篇就够）">
<meta name="twitter:description" content="本文转载自 https://juejin.im/post/5d0821315188254c434686c8Java内部类，相信大家都用过，但是多数同学可能对它了解的并不深入，只是靠记忆来完成日常工作，却不能融会贯通，遇到奇葩问题更是难以有思路去解决。这篇文章带大家一起死磕Java内部类的方方面面。 友情提示：这篇文章的讨论基于JDK版本 1.8.0_191  开篇问题我一直觉得技术是工具，是一定">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2019/6/18/16b67c1a51958f99?imageView2/0/w/1280/h/960/ignore-error/1">
  
    <link rel="alternate" href="/atom.xml" title="HUAN" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HUAN</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://sillyfan.top"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-死磕Java内部类（一篇就够）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/18/死磕Java内部类（一篇就够）/" class="article-date">
  <time datetime="2019-06-18T07:18:46.046Z" itemprop="datePublished">2019-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      死磕Java内部类（一篇就够）
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5d0821315188254c434686c8" target="_blank" rel="noopener">https://juejin.im/post/5d0821315188254c434686c8</a><br>Java内部类，相信大家都用过，但是多数同学可能对它了解的并不深入，只是靠记忆来完成日常工作，却不能融会贯通，遇到奇葩问题更是难以有思路去解决。这篇文章带大家一起死磕Java内部类的方方面面。 友情提示：这篇文章的讨论基于JDK版本 1.8.0_191</p>
</blockquote>
<h3 id="开篇问题"><a href="#开篇问题" class="headerlink" title="开篇问题"></a>开篇问题</h3><p>我一直觉得技术是工具，是一定要落地的，要切实解决某些问题的，所以我们通过先抛出问题，然后解决这些问题，在这个过程中来加深理解，最容易有收获。 so，先抛出几个问题。（如果这些问题你早已思考过，答案也了然于胸，那恭喜你，这篇文章可以关掉了）。</p>
<pre><code>* **为什么需要内部类？**
* **为什么内部类（包括匿名内部类、局部内部类），会持有外部类的引用？**
* **为什么匿名内部类使用到外部类方法中的局部变量时需要是final类型的？**
* **如何创建内部类实例，如何继承内部类？**
* **Lambda表达式是如何实现的？**</code></pre><h3 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类?"></a>为什么需要内部类?</h3><p>要回答这个问题，先要弄明白什么是内部类？我们知道Java有三种类型的内部类</p>
<h3 id="普通的内部类"><a href="#普通的内部类" class="headerlink" title="普通的内部类"></a>普通的内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line"></span><br><span class="line">    // 普通内部类</span><br><span class="line">    public class DemoRunnable implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line"></span><br><span class="line">    // 匿名内部类</span><br><span class="line">    private Runnable runnable = new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法内局部内部类"><a href="#方法内局部内部类" class="headerlink" title="方法内局部内部类"></a>方法内局部内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line"></span><br><span class="line">    // 局部内部类</span><br><span class="line">    public void work() &#123;</span><br><span class="line">        class InnerRunnable implements Runnable &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        InnerRunnable runnable = new InnerRunnable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三种形式的内部类，大家肯定都用过，但是技术在设计之初肯定也是要用来解决某个问题或者某个痛点，那可以想想内部类相对比外部定义类有什么优势呢？ 我们通过一个小例子来做说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Worker &#123;</span><br><span class="line">    private List&lt;Job&gt; mJobList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void addJob(Runnable task) &#123;</span><br><span class="line">        mJobList.add(new Job(task));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class Job implements Runnable &#123;</span><br><span class="line">        Runnable task;</span><br><span class="line">        public  Job(Runnable task) &#123;</span><br><span class="line">            this.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">            System.out.println(&quot;left job size : &quot; + mJobList.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了一个Worker类，暴露了一个addJob方法，一个参数task，类型是Runnable，然后定义 了一个内部类Job类对task进行了一层封装，这里Job是私有的，所以外界是感知不到Job的存在的，所以有了内部类第一个优势。</p>
<pre><code>* **内部类能够更好的封装，内聚，屏蔽细节**</code></pre><p>我们在Job的run方法中，打印了外部Worker的mJobList列表中剩余Job数量，代码这样写没问题，但是细想，内部类是如何拿到外部类的成员变量的呢？这里先卖个关子，但是已经可以先得出内部类的第二个优势了。</p>
<pre><code>* **内部类天然有访问外部类成员变量的能力**</code></pre><p>内部类主要就是上面的二个优势。当然还有一些其他的小优点，比如可以用来实现多重继承，可以将逻辑内聚在一个类方便维护等，这些见仁见智，先不去说它们。</p>
<p>我们接着看第二个问题！！！</p>
<h3 id="为什么内部类（包括匿名内部类、局部内部类），会持有外部类的引用？"><a href="#为什么内部类（包括匿名内部类、局部内部类），会持有外部类的引用？" class="headerlink" title="为什么内部类（包括匿名内部类、局部内部类），会持有外部类的引用？"></a>为什么内部类（包括匿名内部类、局部内部类），会持有外部类的引用？</h3><p>问这个问题，显得我是个杠精，您先别着急，其实我想问的是，内部类Java是怎么实现的。 我们还是举例说明，先以普通的内部类为例</p>
<h3 id="普通内部类的实现"><a href="#普通内部类的实现" class="headerlink" title="普通内部类的实现"></a>普通内部类的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    // 普通内部类</span><br><span class="line">    public class DemoRunnable implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切到Demo.java所在文件夹，命令行执行 javac Demo.java，在Demo类同目录下可以看到生成了二个class文件</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/6/18/16b67c1a51958f99?imageView2/0/w/1280/h/960/ignore-error/1" alt="普通内部类生成class.png"></p>
<p>Demo.class很好理解，另一个 类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Demo$DemoRunnable.class</span><br></pre></td></tr></table></figure>

<p>就是我们的内部类编译出来的，它的命名也是有规律的，外部类名Demo+$+内部类名DemoRunnable。 查看反编译后的代码（IntelliJ IDEA本身就支持，直接查看class文件即可）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package inner;</span><br><span class="line"></span><br><span class="line">public class Demo$DemoRunnable implements Runnable &#123;</span><br><span class="line">    public Demo$DemoRunnable(Demo var1) &#123;</span><br><span class="line">        this.this$0 = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的类只有一个构造器，参数就是Demo类型，而且保存到内部类本身的this$0字段中。到这里我们其实已经可以想到，内部类持有的外部类引用就是通过这个构造器传递进来的，它是一个强引用。</p>
<h3 id="验证我们的想法"><a href="#验证我们的想法" class="headerlink" title="验证我们的想法"></a>验证我们的想法</h3><p>怎么验证呢？我们需要在Demo.class类中加一个方法，来实例化这个DemoRunnable内部类对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Demo.java</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        DemoRunnable demoRunnable = new DemoRunnable();</span><br><span class="line">        demoRunnable.run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再次执行 javac Demo.java，再执行javap -verbose Demo.class，查看Demo类的字节码，前方高能，需要一些字节码知识，这里我们重点关注run方法（插一句题外话，字节码简单的要能看懂，-。-）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void run();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=2, args_size=1</span><br><span class="line">         0: new           #2                  // class inner/Demo$DemoRunnable</span><br><span class="line">         3: dup</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: invokespecial #3                  // Method inner/Demo$DemoRunnable.&quot;&lt;init&gt;&quot;:(Linner/Demo;)V</span><br><span class="line">         8: astore_1</span><br><span class="line">         9: aload_1</span><br><span class="line">        10: invokevirtual #4                  // Method inner/Demo$DemoRunnable.run:()V</span><br><span class="line">        13: return</span><br></pre></td></tr></table></figure>

<pre><code>* **先通过new指令，新建了一个Demo$DemoRunnable对象**
* **aload_0指令将外部类Demo对象自身加载到栈帧中**
* **调用Demo$DemoRunnable类的init方法，注意这里将Demo对象作为了参数传递进来了**</code></pre><p>到这一步其实已经很清楚了，就是将外部类对象自身作为参数传递给了内部类构造器，与我们上面的猜想一致。</p>
<h3 id="匿名内部类的实现"><a href="#匿名内部类的实现" class="headerlink" title="匿名内部类的实现"></a>匿名内部类的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    // 匿名内部类</span><br><span class="line">    private Runnable runnable = new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样执行javac Demo.java，这次多生成了一个Demo$1.class，反编译查看代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package inner;</span><br><span class="line"></span><br><span class="line">class Demo$1 implements Runnable &#123;</span><br><span class="line">    Demo$1(Demo var1) &#123;</span><br><span class="line">        this.this$0 = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到匿名内部类和普通内部类实现基本一致，只是编译器自动给它拼了个名字，所以匿名内部类不能自定义构造器，因为名字编译完成后才能确定。 方法局部内部类，我这里就不赘述了，原理都是一样的，大家可以自行试验。 这样我们算是解答了第二个问题，来看第三个问题。</p>
<h3 id="为什么匿名内部类使用到外部类方法中的局部变量时需要是final类型的？"><a href="#为什么匿名内部类使用到外部类方法中的局部变量时需要是final类型的？" class="headerlink" title="为什么匿名内部类使用到外部类方法中的局部变量时需要是final类型的？"></a>为什么匿名内部类使用到外部类方法中的局部变量时需要是final类型的？</h3><p>这里先申明一下，这个问题本身是有问题的，问题在哪呢？因为java8中并不一定需要声明为final。我们来看个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Demo.java</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        int age = 10;</span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                int myAge = age + 1;</span><br><span class="line">                System.out.println(myAge);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>匿名内部类对象runnable，使用了外部类方法中的age局部变量。编译运行完全没问题，而age并没有final修饰啊！ 那我们再在run方法中，尝试修改age试试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">        int age = 10;</span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                int myAge = age + 1;</span><br><span class="line">                System.out.println(myAge);</span><br><span class="line">                age = 20;   // error</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译器报错了，提示信息是”age is access from inner class, need to be final or effectively final“。很显然编译器很智能，由于我们第一个例子并没有修改age的值，所以编译器认为这是effectively final，是安全的，可以编译通过，而第二个例子尝试修改age的值，编译器立马就报错了。</strong></p>
<h3 id="外部类变量是怎么传递给内部类的？"><a href="#外部类变量是怎么传递给内部类的？" class="headerlink" title="外部类变量是怎么传递给内部类的？"></a>外部类变量是怎么传递给内部类的？</h3><p>这里对于变量的类型分三种情况分别来说明</p>
<h3 id="非final局部变量"><a href="#非final局部变量" class="headerlink" title="非final局部变量"></a>非final局部变量</h3><p>我们去掉尝试修改age的代码，然后执行javac Demo.java，查看Demo$1.class的实现代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package inner;</span><br><span class="line"></span><br><span class="line">class Demo$1 implements Runnable &#123;</span><br><span class="line">    Demo$1(Demo var1, int var2) &#123;</span><br><span class="line">        this.this$0 = var1;</span><br><span class="line">        this.val$age = var2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        int var1 = this.val$age + 1;</span><br><span class="line">        System.out.println(var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到对于非final局部变量，是通过构造器的方式传递进来的。</p>
<h3 id="final局部变量"><a href="#final局部变量" class="headerlink" title="final局部变量"></a>final局部变量</h3><p>age修改为final</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">        final int age = 10;</span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                int myAge = age + 1;</span><br><span class="line">                System.out.println(myAge);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>同样执行javac Demo.java，查看Demo$1.class的实现代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Demo$1 implements Runnable &#123;</span><br><span class="line">    Demo$1(Demo var1) &#123;</span><br><span class="line">        this.this$0 = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        byte var1 = 11;</span><br><span class="line">        System.out.println(var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到编译器很聪明的做了优化，age是final的，所以在编译期间是确定的，直接将+1优化为11。 为了测试编译器的智商，我们把age的赋值修改一下，改为运行时才能确定的，看编译器如何应对</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">        final int age = (int) System.currentTimeMillis();</span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                int myAge = age + 1;</span><br><span class="line">                System.out.println(myAge);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再看Demo$1 字节码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Demo$1 implements Runnable &#123;</span><br><span class="line">    Demo$1(Demo var1, int var2) &#123;</span><br><span class="line">        this.this$0 = var1;</span><br><span class="line">        this.val$age = var2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        int var1 = this.val$age + 1;</span><br><span class="line">        System.out.println(var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译器意识到编译期age的值不能确定，所以还是采用构造器传参的形式实现。现代编译器还是很机智的。</strong></p>
<h3 id="外部类成员变量"><a href="#外部类成员变量" class="headerlink" title="外部类成员变量"></a>外部类成员变量</h3><p>将age改为Demo的成员变量，注意没有加任何修饰符，是包级访问级别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    int age = 10;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                int myAge = age + 1;</span><br><span class="line">                System.out.println(myAge);</span><br><span class="line">                age = 20;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>javac Demo.java，查看匿名内部内的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Demo$1 implements Runnable &#123;</span><br><span class="line">    Demo$1(Demo var1) &#123;</span><br><span class="line">        this.this$0 = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        int var1 = this.this$0.age + 1;</span><br><span class="line">        System.out.println(var1);</span><br><span class="line">        this.this$0.age = 20;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一次编译器直接通过外部类的引用操作age，没毛病，由于age是包访问级别，所以这样是最高效的。 如果将age改为private，编译器会在Demo类中生成二个方法，分别用于读取age和设置age，篇幅关系，这种情况留给大家自行测试。</p>
<h3 id="解答为何局部变量传递给匿名内部类需要是final"><a href="#解答为何局部变量传递给匿名内部类需要是final" class="headerlink" title="解答为何局部变量传递给匿名内部类需要是final?"></a>解答为何局部变量传递给匿名内部类需要是final?</h3><p><strong>通过上面的例子可以看到，不是一定需要局部变量是final的，但是你不能在匿名内部类中修改外部局部变量，因为Java对于匿名内部类传递变量的实现是基于构造器传参的，也就是说如果允许你在匿名内部类中修改值，你修改的是匿名内部类中的外部局部变量副本，最终并不会对外部类产生效果，因为已经是二个变量了。</strong> <strong>这样就会让程序员产生困扰，原以为修改会生效，事实上却并不会，所以Java就禁止在匿名内部类中修改外部局部变量。</strong></p>
<h3 id="如何创建内部类实例，如何继承内部类？"><a href="#如何创建内部类实例，如何继承内部类？" class="headerlink" title="如何创建内部类实例，如何继承内部类？"></a>如何创建内部类实例，如何继承内部类？</h3><p>由于内部类对象需要持有外部类对象的引用，所以必须得先有外部类对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Demo.DemoRunnable demoRunnable = new Demo().new DemoRunnable();</span><br></pre></td></tr></table></figure>

<p>那如何继承一个内部类呢，先给出示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 extends Demo.DemoRunnable &#123;</span><br><span class="line">        public Demo2(Demo demo) &#123;</span><br><span class="line">            demo.super();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>必须在构造器中传入一个Demo对象，并且还需要调用demo.super(); 看个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class DemoKata &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo2 demo2 = new DemoKata().new Demo2(new Demo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class Demo2 extends Demo.DemoRunnable &#123;</span><br><span class="line">        public Demo2(Demo demo) &#123;</span><br><span class="line">            demo.super();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Demo2也是一个内部类，所以需要先new一个DemoKata对象。 这一个问题描述的场景可能用的并不多，一般也不这么去用，这里提一下，大家知道有这么回事就行。</p>
<h3 id="Lambda表达式是如何实现的？"><a href="#Lambda表达式是如何实现的？" class="headerlink" title="Lambda表达式是如何实现的？"></a>Lambda表达式是如何实现的？</h3><p>Java8引入了Lambda表达式，一定程度上可以简化我们的代码，使代码结构看起来更优雅。做技术的还是要有刨根问底的那股劲，问问自己有没有想过Java中Lambda到底是如何实现的呢？</p>
<p>来看一个最简单的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    public void run(Runnable runnable) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Animal类中定义了一个run方法，参数是一个Runnable对象，Java8以前，我们可以传入一个匿名内部类对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">run(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Java 8 之后编译器已经很智能的提示我们可以用Lambda表达式来替换。既然可以替换，那匿名内部类和Lambda表达式是不是底层实现是一样的呢，或者说Lambda表达式只是匿名内部类的语法糖呢？ 要解答这个问题，我们还是要去字节码中找线索。通过前面的知识，我们知道javac Animal.java命令将类编译成class，匿名内部类的方式会产生一个额外的类。那用Lambda表达式会不会也会编译新类呢？我们试一下便知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void run(Runnable runnable) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test() &#123;</span><br><span class="line">        run(() -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>javac Animal.java，发现并没有生成额外的类！！！ 我们继续使用javap -verbose Animal.class来查看Animal.class的字节码实现，重点关注test方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokedynamic #2,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable;</span><br><span class="line">         6: invokevirtual #3                  // Method run:(Ljava/lang/Runnable;)V</span><br><span class="line">         9: return</span><br><span class="line"></span><br><span class="line">SourceFile: &quot;Demo.java&quot;</span><br><span class="line">InnerClasses:</span><br><span class="line">     public static final #34= #33 of #37; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</span><br><span class="line">BootstrapMethods:</span><br><span class="line">  0: #18 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">    Method arguments:</span><br><span class="line">      #19 ()V</span><br><span class="line">      #20 invokestatic com/company/inner/Demo.lambda$test$0:()V</span><br><span class="line">      #19 ()V</span><br></pre></td></tr></table></figure>

<p>发现test方法字节码中多了一个invokedynamic /#2 0指令，这是java7引入的新指令，其中/#2 指向</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#2 = InvokeDynamic      #0:#21         // #0:run:()Ljava/lang/Runnable;</span><br></pre></td></tr></table></figure>

<p>而0代表BootstrapMethods方法表中的第一个，java/lang/invoke/LambdaMetafactory.metafactory方法被调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BootstrapMethods:</span><br><span class="line">  0: #18 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">    Method arguments:</span><br><span class="line">      #19 ()V</span><br><span class="line">      #20 invokestatic com/company/inner/Demo.lambda$test$0:()V</span><br><span class="line">      #19 ()V</span><br></pre></td></tr></table></figure>

<p>这里面我们看到了com/company/inner/Demo.lambda$test$0这么个东西，看起来跟我们的匿名内部类的名称有些类似，而且中间还有lambda，有可能就是我们要找的生成的类。 我们不妨验证下我们的想法，可以通过下面的代码打印出Lambda对象的真实类名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void run(Runnable runnable) &#123;</span><br><span class="line">        System.out.println(runnable.getClass().getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test() &#123;</span><br><span class="line">        run(() -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>打印出runnable的类名，结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.company.inner.Demo$$Lambda$1/764977973</span><br></pre></td></tr></table></figure>

<p>跟我们上面的猜测并不完全一致，我们继续找别的线索，既然我们有看到LambdaMetafactory.metafactory这个类被调用，不妨继续跟进看下它的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static CallSite metafactory(MethodHandles.Lookup caller,</span><br><span class="line">                                       String invokedName,</span><br><span class="line">                                       MethodType invokedType,</span><br><span class="line">                                       MethodType samMethodType,</span><br><span class="line">                                       MethodHandle implMethod,</span><br><span class="line">                                       MethodType instantiatedMethodType)</span><br><span class="line">            throws LambdaConversionException &#123;</span><br><span class="line">        AbstractValidatingLambdaMetafactory mf;</span><br><span class="line">        mf = new InnerClassLambdaMetafactory(caller, invokedType,</span><br><span class="line">                                             invokedName, samMethodType,</span><br><span class="line">                                             implMethod, instantiatedMethodType,</span><br><span class="line">                                             false, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);</span><br><span class="line">        mf.validateMetafactoryArgs();</span><br><span class="line">        return mf.buildCallSite();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>内部new了一个InnerClassLambdaMetafactory对象。看名字很可疑，继续跟进</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public InnerClassLambdaMetafactory(...)</span><br><span class="line">            throws LambdaConversionException &#123;</span><br><span class="line">        //....</span><br><span class="line">        lambdaClassName = targetClass.getName().replace(&apos;.&apos;, &apos;/&apos;) + &quot;$$Lambda$&quot; + counter.incrementAndGet();</span><br><span class="line">        cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);</span><br><span class="line">       //....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>省略了很多代码，我们重点看lambdaClassName这个字符串（通过名字就知道是干啥的），可以看到它的拼接结果跟我们上面打印的Lambda类名基本一致。而下面的ClassWriter也暴露了，其实Lambda运用的是Asm字节码技术，在运行时生成类文件。我感觉到这里就差不多了，再往下可能就有点太过细节了。-。-</p>
<h3 id="Lambda实现总结"><a href="#Lambda实现总结" class="headerlink" title="Lambda实现总结"></a>Lambda实现总结</h3><p>所以Lambda表达式并不是匿名内部类的语法糖，它是基于invokedynamic指令，在运行时使用ASM生成类文件来实现的。</p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>这可能是我迄今写的最长的一篇技术文章了，写的过程中也在不断的加深自己对知识点的理解，颠覆了很多以往的错误认知。写技术文章这条路我会一直坚持下去。 非常喜欢得到里面的一句slogan，胡适先生说的话。 <strong>怕什么真理无穷，进一寸有一寸的欢喜</strong> 共勉!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/06/18/死磕Java内部类（一篇就够）/" data-id="cjyza2xyl002zaf2a167513a4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/06/20/Linux生产环境上，最常用的一套“AWK“技巧/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Linux生产环境上，最常用的一套“AWK“技巧
        
      </div>
    </a>
  
  
    <a href="/2019/06/06/面试那点小事，你从未见过的springboot面试集锦（附详细答案）/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">面试那点小事，你从未见过的spring boot面试集锦（附详细答案）</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HDFS/">HDFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactor/">Reactor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/">RxJava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue-js/">Vue.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端/">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微服务/">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/HDFS/" style="font-size: 10px;">HDFS</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 13.33px;">MySQL</a> <a href="/tags/Reactor/" style="font-size: 10px;">Reactor</a> <a href="/tags/RxJava/" style="font-size: 10px;">RxJava</a> <a href="/tags/Shell/" style="font-size: 10px;">Shell</a> <a href="/tags/Spring/" style="font-size: 13.33px;">Spring</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP/IP</a> <a href="/tags/Vue-js/" style="font-size: 10px;">Vue.js</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/后端/" style="font-size: 10px;">后端</a> <a href="/tags/微服务/" style="font-size: 10px;">微服务</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/服务器/" style="font-size: 10px;">服务器</a> <a href="/tags/架构/" style="font-size: 16.67px;">架构</a> <a href="/tags/源码/" style="font-size: 10px;">源码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/06/万万没想到，JVM内存结构的面试题可以问的这么难？/">万万没想到，JVM内存结构的面试题可以问的这么难？</a>
          </li>
        
          <li>
            <a href="/2019/06/28/分布式数据库中间件MyCat搞起来！/">分布式数据库中间件 MyCat 搞起来！</a>
          </li>
        
          <li>
            <a href="/2019/06/20/Linux生产环境上，最常用的一套“AWK“技巧/">Linux生产环境上，最常用的一套“AWK“技巧</a>
          </li>
        
          <li>
            <a href="/2019/06/18/死磕Java内部类（一篇就够）/">死磕Java内部类（一篇就够）</a>
          </li>
        
          <li>
            <a href="/2019/06/06/面试那点小事，你从未见过的springboot面试集锦（附详细答案）/">面试那点小事，你从未见过的spring boot面试集锦（附详细答案）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 huan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>