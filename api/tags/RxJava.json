{"name":"RxJava","slug":"RxJava","count":1,"posts":[{"title":"Java8新的异步编程方式 CompletableFuture(三)","slug":"Java8新的异步编程方式CompletableFuture(3)","date":"2019-05-14T03:46:27.027Z","updated":"2019-05-30T00:52:25.404Z","comments":true,"pin":null,"path":"api/articles/Java8新的异步编程方式CompletableFuture(3).json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/59eae7636fb9a045117044c6\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/59eae7636fb9a045117044c6</a> </p>\n</blockquote>\n<p>前面两篇文章已经整理了CompletableFuture大部分的特性，本文会整理完CompletableFuture余下的特性，以及将它跟RxJava进行比较。</p>\n<h2 id=\"3-6-Either\"><a href=\"#3-6-Either\" class=\"headerlink\" title=\"3.6 Either\"></a>3.6 Either</h2><p>Either 表示的是两个CompletableFuture，当其中任意一个CompletableFuture计算完成的时候就会执行。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">acceptEither(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)</td>\n<td align=\"center\">当任意一个CompletableFuture完成的时候，action这个消费者就会被执行。</td>\n</tr>\n<tr>\n<td align=\"center\">acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)</td>\n<td align=\"center\">当任意一个CompletableFuture完成的时候，action这个消费者就会被执行。使用ForkJoinPool</td>\n</tr>\n<tr>\n<td align=\"center\">acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action, Executor executor)</td>\n<td align=\"center\">当任意一个CompletableFuture完成的时候，action这个消费者就会被执行。使用指定的线程池</td>\n</tr>\n<tr>\n<td align=\"center\">`Random random =  Random();</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<pre><code>CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(()-&gt;{\n\n     {\n        Thread.sleep(random.nextInt());\n    }  (InterruptedException e) {\n        e.printStackTrace();\n    }\n\n     ;\n});\n\nCompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(()-&gt;{\n\n     {\n        Thread.sleep(random.nextInt());\n    }  (InterruptedException e) {\n        e.printStackTrace();\n    }\n\n     ;\n});\n\nCompletableFuture&lt;Void&gt; future =  future1.acceptEither(future2,str-&gt;System.out.println(+str));\n\n {\n    future.get();\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果：The future is from future1 或者 The future is from future2。<br>因为future1和future2，执行的顺序是随机的。</p>\n<p>applyToEither 跟 acceptEither 类似。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">applyToEither(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn)</td>\n<td align=\"center\">当任意一个CompletableFuture完成的时候，fn会被执行，它的返回值会当作新的CompletableFuture<u>的计算结果。</u></td>\n</tr>\n<tr>\n<td align=\"center\">applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn)</td>\n<td align=\"center\">当任意一个CompletableFuture完成的时候，fn会被执行，它的返回值会当作新的CompletableFuture<u>的计算结果。使用ForkJoinPool</u></td>\n</tr>\n<tr>\n<td align=\"center\">applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn, Executor executor)</td>\n<td align=\"center\">当任意一个CompletableFuture完成的时候，fn会被执行，它的返回值会当作新的CompletableFuture<u>的计算结果。使用指定的线程池</u></td>\n</tr>\n<tr>\n<td align=\"center\">`Random random =  Random();</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<pre><code>CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(()-&gt;{\n\n     {\n        Thread.sleep(random.nextInt());\n    }  (InterruptedException e) {\n        e.printStackTrace();\n    }\n\n     ;\n});\n\nCompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(()-&gt;{\n\n     {\n        Thread.sleep(random.nextInt());\n    }  (InterruptedException e) {\n        e.printStackTrace();\n    }\n\n     ;\n});\n\nCompletableFuture&lt;String&gt; future =  future1.applyToEither(future2,str-&gt;+str);\n\n {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果也跟上面的程序类似。</p>\n<h2 id=\"3-7-其他方法\"><a href=\"#3-7-其他方法\" class=\"headerlink\" title=\"3.7 其他方法\"></a>3.7 其他方法</h2><p>allOf、anyOf是CompletableFuture的静态方法。</p>\n<h3 id=\"3-7-1-allOf\"><a href=\"#3-7-1-allOf\" class=\"headerlink\" title=\"3.7.1 allOf\"></a>3.7.1 allOf</h3><table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">allOf(CompletableFuture&lt;?&gt;… cfs)</td>\n<td align=\"center\">在所有Future对象完成后结束，并返回一个future。</td>\n</tr>\n</tbody></table>\n<p>allOf()方法所返回的CompletableFuture，并不能组合前面多个CompletableFuture的计算结果。于是我们借助Java 8的Stream来组合多个future的结果。<br>`CompletableFuture<string> future1 = CompletableFuture.supplyAsync(() -&gt; );</string></p>\n<pre><code>CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; );\n\nCompletableFuture&lt;String&gt; future3 = CompletableFuture.supplyAsync(() -&gt; );\n\nCompletableFuture.allOf(future1, future2, future3)\n        .thenApply(v -&gt;\n        Stream.of(future1, future2, future3)\n                .map(CompletableFuture::join)\n                .collect(Collectors.joining()))\n        .thenAccept(System.out::print);`</code></pre><p>执行结果：</p>\n<p><code>tony cafei aaron</code></p>\n<h3 id=\"3-7-2-anyOf\"><a href=\"#3-7-2-anyOf\" class=\"headerlink\" title=\"3.7.2 anyOf\"></a>3.7.2 anyOf</h3><table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">anyOf(CompletableFuture&lt;?&gt;… cfs)</td>\n<td align=\"center\">在任何一个Future对象结束后结束，并返回一个future。</td>\n</tr>\n<tr>\n<td align=\"center\">`Random rand =  Random();</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">CompletableFuture<string> future1 = CompletableFuture.supplyAsync(() -&gt; {</string></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">{</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">Thread.sleep(rand.nextInt());</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">}  (InterruptedException e) {</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">e.printStackTrace();</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">}</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">;</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">});</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">CompletableFuture<string> future2 = CompletableFuture.supplyAsync(() -&gt; {</string></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">{</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">Thread.sleep(rand.nextInt());</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">}  (InterruptedException e) {</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">e.printStackTrace();</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">}</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">;</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">});</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">CompletableFuture<string> future3 = CompletableFuture.supplyAsync(() -&gt; {</string></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">{</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">Thread.sleep(rand.nextInt());</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">}  (InterruptedException e) {</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">e.printStackTrace();</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">}</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">;</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">});</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<pre><code>CompletableFuture&lt;Object&gt; future =  CompletableFuture.anyOf(future1,future2,future3);\n\n {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>使用anyOf()时，只要某一个future完成，就结束了。所以执行结果可能是”from future1”、”from future2”、”from future3”中的任意一个。</p>\n<p>anyOf 和 acceptEither、applyToEither的区别在于，后两者只能使用在两个future中，而anyOf可以使用在多个future中。</p>\n<h2 id=\"3-8-CompletableFuture异常处理\"><a href=\"#3-8-CompletableFuture异常处理\" class=\"headerlink\" title=\"3.8 CompletableFuture异常处理\"></a>3.8 CompletableFuture异常处理</h2><p>CompletableFuture在运行时如果遇到异常，可以使用get()并抛出异常进行处理，但这并不是一个最好的方法。CompletableFuture本身也提供了几种方式来处理异常。</p>\n<h3 id=\"3-8-1-exceptionally\"><a href=\"#3-8-1-exceptionally\" class=\"headerlink\" title=\"3.8.1 exceptionally\"></a>3.8.1 exceptionally</h3><table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">exceptionally(Function fn)</td>\n<td align=\"center\">只有当CompletableFuture抛出异常的时候，才会触发这个exceptionally的计算，调用function计算值。</td>\n</tr>\n<tr>\n<td align=\"center\">`CompletableFuture.supplyAsync(() -&gt; )</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">.thenApply(s -&gt; {</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">s = ;</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">length = s.length();</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">length;</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">}).thenAccept(i -&gt; System.out.println(i))</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">.exceptionally(t -&gt; {</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">System.out.println( + t);</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">;</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">});`</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>执行结果：</p>\n<p><code>Unexpected error:java.util.concurrent.CompletionException: java.lang.NullPointerException</code></p>\n<p>对上面的代码稍微做了一下修改，修复了空指针的异常。</p>\n<p>`CompletableFuture.supplyAsync(() -&gt; )<br>                .thenApply(s -&gt; {</p>\n<pre><code>     length = s.length();\n     length;\n}).thenAccept(i -&gt; System.out.println(i))\n.exceptionally(t -&gt; {\n    System.out.println( + t);\n     ;\n});`</code></pre><p>执行结果：</p>\n<p>``</p>\n<h3 id=\"3-8-2-whenComplete\"><a href=\"#3-8-2-whenComplete\" class=\"headerlink\" title=\"3.8.2 whenComplete\"></a>3.8.2 whenComplete</h3><p>whenComplete 在上一篇文章其实已经介绍过了，在这里跟exceptionally的作用差不多，可以捕获任意阶段的异常。如果没有异常的话，就执行action。<br>`CompletableFuture.supplyAsync(() -&gt; )<br>                .thenApply(s -&gt; {<br>                    s = ;<br>                     length = s.length();<br>                     length;<br>                }).thenAccept(i -&gt; System.out.println(i))<br>                .whenComplete((result, throwable) -&gt; {</p>\n<pre><code>     (throwable != ) {\n       System.out.println(+throwable);\n    }  {\n        System.out.println(result);\n    }\n\n});`</code></pre><p>执行结果：</p>\n<p><code>Unexpected error:java.util.concurrent.CompletionException: java.lang.NullPointerException</code></p>\n<p>跟whenComplete相似的方法是handle，handle的用法在上一篇文章中也已经介绍过。</p>\n<h1 id=\"四-CompletableFuture-VS-Java8-Stream-VS-RxJava1-amp-RxJava2\"><a href=\"#四-CompletableFuture-VS-Java8-Stream-VS-RxJava1-amp-RxJava2\" class=\"headerlink\" title=\"四. CompletableFuture VS Java8 Stream VS RxJava1 &amp; RxJava2\"></a>四. CompletableFuture VS Java8 Stream VS RxJava1 &amp; RxJava2</h1><p>CompletableFuture 有很多特性跟RxJava很像，所以将CompletableFuture、Java 8 Stream和RxJava做一个相互的比较。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">composable</th>\n<th align=\"center\">lazy</th>\n<th align=\"center\">resuable</th>\n<th align=\"center\">async</th>\n<th align=\"center\">cached</th>\n<th align=\"center\">push</th>\n<th align=\"center\">back pressure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">CompletableFuture</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">不支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">不支持</td>\n</tr>\n<tr>\n<td align=\"center\">Stream</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">不支持</td>\n<td align=\"center\">不支持</td>\n<td align=\"center\">不支持</td>\n<td align=\"center\">不支持</td>\n<td align=\"center\">不支持</td>\n</tr>\n<tr>\n<td align=\"center\">Observable(RxJava1)</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n</tr>\n<tr>\n<td align=\"center\">Observable(RxJava2)</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">不支持</td>\n</tr>\n<tr>\n<td align=\"center\">Flowable(RxJava2)</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n</tr>\n</tbody></table>\n<h1 id=\"五-总结\"><a href=\"#五-总结\" class=\"headerlink\" title=\"五. 总结\"></a>五. 总结</h1><p>Java 8提供了一种函数风格的异步和事件驱动编程模型CompletableFuture，它不会造成堵塞。CompletableFuture背后依靠的是fork/join框架来启动新的线程实现异步与并发。当然，我们也能通过指定线程池来做这些事情。</p>\n<p>CompletableFuture特别是对微服务架构而言，会有很大的作为。举一个具体的场景，电商的商品页面可能会涉及到商品详情服务、商品评论服务、相关商品推荐服务等等。获取商品的信息时（/productdetails?productid=xxx），需要调用多个服务来处理这一个请求并返回结果。这里可能会涉及到并发编程，我们完全可以使用Java 8的CompletableFuture或者RxJava来实现。</p>\n<p>先前的文章：<br><a href=\"https://juejin.im/post/59eae61b51882549fc512b34\" target=\"_blank\" rel=\"noopener\">Java8新的异步编程方式 CompletableFuture(一)</a><br><a href=\"https://juejin.im/post/59eae6e4f265da430e4e4cb5\" target=\"_blank\" rel=\"noopener\">Java8新的异步编程方式 CompletableFuture(二)</a></p>\n","text":"本文转载自 https://juejin.im/post/59eae7636fb9a045117044c6 前面两篇文章已经整理了CompletableFuture大部分的特性，本文会整理完CompletableFuture余下的特性，以及将它跟RxJava进行比较。3.6 Ei","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"},{"name":"RxJava","slug":"RxJava","count":1,"path":"api/tags/RxJava.json"}]}]}