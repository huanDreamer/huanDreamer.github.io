{"name":"Java","slug":"Java","count":26,"posts":[{"title":"Java8新的异步编程方式 CompletableFuture(一)","slug":"Java8新的异步编程方式CompletableFuture(1)","date":"2019-05-14T03:45:42.042Z","updated":"2019-05-30T00:52:25.403Z","comments":true,"pin":null,"path":"api/articles/Java8新的异步编程方式CompletableFuture(1).json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/59eae61b51882549fc512b34\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/59eae61b51882549fc512b34</a> </p>\n</blockquote>\n<h1 id=\"一-Future\"><a href=\"#一-Future\" class=\"headerlink\" title=\"一. Future\"></a>一. Future</h1><p>JDK 5引入了Future模式。Future接口是Java多线程Future模式的实现，在java.util.concurrent包中，可以来进行异步计算。</p>\n<p>Future模式是多线程设计常用的一种设计模式。Future模式可以理解成：我有一个任务，提交给了Future，Future替我完成这个任务。期间我自己可以去做任何想做的事情。一段时间之后，我就便可以从Future那儿取出结果。</p>\n<p>Future的接口很简单，只有五个方法。<br>`{</p>\n<pre><code>;\n\n;\n\n;\n\n;\n\n;</code></pre><p>}`</p>\n<p>Future接口的方法介绍如下：</p>\n<pre><code>* boolean cancel (boolean mayInterruptIfRunning) 取消任务的执行。参数指定是否立即中断任务执行，或者等等任务结束\n* boolean isCancelled () 任务是否已经取消，任务正常完成前将其取消，则返回 true\n* boolean isDone () 任务是否已经完成。需要注意的是如果任务正常终止、异常或取消，都将返回true\n* V get () throws InterruptedException, ExecutionException 等待任务执行结束，然后获得V类型的结果。InterruptedException 线程被中断异常， ExecutionException任务执行异常，如果任务被取消，还会抛出CancellationException\n* V get (long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException 同上面的get功能一样，多了设置超时时间。参数timeout指定超时时间，uint指定时间的单位，在枚举类TimeUnit中有相关的定义。如果计 算超时，将抛出TimeoutException</code></pre><p>一般情况下，我们会结合Callable和Future一起使用，通过ExecutorService的submit方法执行Callable，并返回Future。<br>`ExecutorService executor = Executors.newCachedThreadPool();</p>\n<pre><code>Future&lt;String&gt; future = executor.submit(() -&gt; { \n    System.out.println();\n    Thread.sleep();\n     ;\n});\n\n {\n    Thread.sleep();\n}  (InterruptedException e) {\n}\n\nSystem.out.println();  \n\n {\n    System.out.println(future.get());  \n}  (InterruptedException e) {\n}  (ExecutionException e) {\n\n}  {\n    executor.shutdown();\n}`</code></pre><p>比起future.get()，其实更推荐使用get (long timeout, TimeUnit unit) 方法，设置了超时时间可以防止程序无限制的等待future的结果。</p>\n<h1 id=\"二-CompletableFuture介绍\"><a href=\"#二-CompletableFuture介绍\" class=\"headerlink\" title=\"二. CompletableFuture介绍\"></a>二. CompletableFuture介绍</h1><h2 id=\"2-1-Future模式的缺点\"><a href=\"#2-1-Future模式的缺点\" class=\"headerlink\" title=\"2.1 Future模式的缺点\"></a>2.1 Future模式的缺点</h2><pre><code>* Future虽然可以实现获取异步执行结果的需求，但是它没有提供通知的机制，我们无法得知Future什么时候完成。\n* 要么使用阻塞，在future.get()的地方等待future返回的结果，这时又变成同步操作。要么使用isDone()轮询地判断Future是否完成，这样会耗费CPU的资源。</code></pre><h2 id=\"2-2-CompletableFuture介绍\"><a href=\"#2-2-CompletableFuture介绍\" class=\"headerlink\" title=\"2.2 CompletableFuture介绍\"></a>2.2 CompletableFuture介绍</h2><p>Netty、Guava分别扩展了Java 的 Future 接口，方便异步编程。</p>\n<p>Java 8新增的CompletableFuture类正是吸收了所有Google Guava中ListenableFuture和SettableFuture的特征，还提供了其它强大的功能，让Java拥有了完整的非阻塞编程模型：Future、Promise 和 Callback(在Java8之前，只有无Callback 的Future)。</p>\n<p>CompletableFuture能够将回调放到与任务不同的线程中执行，也能将回调作为继续执行的同步函数，在与任务相同的线程中执行。它避免了传统回调最大的问题，那就是能够将控制流分离到不同的事件处理器中。</p>\n<p>CompletableFuture弥补了Future模式的缺点。在异步的任务完成后，需要用其结果继续操作时，无需等待。可以直接通过thenAccept、thenApply、thenCompose等方式将前面异步处理的结果交给另外一个异步事件处理线程来处理。</p>\n<h1 id=\"三-CompletableFuture特性\"><a href=\"#三-CompletableFuture特性\" class=\"headerlink\" title=\"三. CompletableFuture特性\"></a>三. CompletableFuture特性</h1><h2 id=\"3-1-CompletableFuture的静态工厂方法\"><a href=\"#3-1-CompletableFuture的静态工厂方法\" class=\"headerlink\" title=\"3.1 CompletableFuture的静态工厂方法\"></a>3.1 CompletableFuture的静态工厂方法</h2><table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">runAsync(Runnable runnable)</td>\n<td align=\"center\">使用ForkJoinPool.commonPool()作为它的线程池执行异步代码。</td>\n</tr>\n<tr>\n<td align=\"center\">runAsync(Runnable runnable, Executor executor)</td>\n<td align=\"center\">使用指定的thread pool执行异步代码。</td>\n</tr>\n<tr>\n<td align=\"center\">supplyAsync(Supplier<u> supplier)</u></td>\n<td align=\"center\">使用ForkJoinPool.commonPool()作为它的线程池执行异步代码，异步操作有返回值</td>\n</tr>\n<tr>\n<td align=\"center\">supplyAsync(Supplier<u> supplier, Executor executor)</u></td>\n<td align=\"center\">使用指定的thread pool执行异步代码，异步操作有返回值</td>\n</tr>\n</tbody></table>\n<p>runAsync 和 supplyAsync 方法的区别是runAsync返回的CompletableFuture是没有返回值的。<br>`CompletableFuture<void> future = CompletableFuture.runAsync(() -&gt; {<br>            System.out.println();<br>        });</void></p>\n<pre><code> {\n    future.get();\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}\n\nSystem.out.println();`</code></pre><p>而supplyAsync返回的CompletableFuture是由返回值的，下面的代码打印了future的返回值。</p>\n<p>`CompletableFuture<string> future = CompletableFuture.supplyAsync(() -&gt; );</string></p>\n<pre><code> {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}\n\nSystem.out.println();`</code></pre><h2 id=\"3-2-Completable\"><a href=\"#3-2-Completable\" class=\"headerlink\" title=\"3.2 Completable\"></a>3.2 Completable</h2><table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">complete(T t)</td>\n<td align=\"center\">完成异步执行，并返回future的结果</td>\n</tr>\n<tr>\n<td align=\"center\">completeExceptionally(Throwable ex)</td>\n<td align=\"center\">异步执行不正常的结束</td>\n</tr>\n</tbody></table>\n<p>future.get()在等待执行结果时，程序会一直block，如果此时调用complete(T t)会立即执行。<br>`CompletableFuture<string> future  = CompletableFuture.supplyAsync(() -&gt; );</string></p>\n<pre><code>future.complete();\n\n {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果：</p>\n<p><code>World</code></p>\n<p>可以看到future调用complete(T t)会立即执行。但是complete(T t)只能调用一次，后续的重复调用会失效。</p>\n<p>如果future已经执行完毕能够返回结果，此时再调用complete(T t)则会无效。<br>`CompletableFuture<string> future = CompletableFuture.supplyAsync(() -&gt; );</string></p>\n<pre><code> {\n    Thread.sleep();\n}  (InterruptedException e) {\n    e.printStackTrace();\n}\n\nfuture.complete();\n\n {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果：</p>\n<p><code>Hello</code></p>\n<p>如果使用completeExceptionally(Throwable ex)则抛出一个异常，而不是一个成功的结果。</p>\n<p>`CompletableFuture<string> future = CompletableFuture.supplyAsync(() -&gt; );</string></p>\n<pre><code>future.completeExceptionally( Exception());\n\n {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果：</p>\n<p><code>java.util.concurrent.ExecutionException: java.lang.Exception\n...</code></p>\n","text":"本文转载自 https://juejin.im/post/59eae61b51882549fc512b34 一. FutureJDK 5引入了Future模式。Future接口是Java多线程Future模式的实现，在java.util.concurrent包中，可以来进行异步计","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]},{"title":"Java8新的异步编程方式 CompletableFuture(三)","slug":"Java8新的异步编程方式CompletableFuture(3)","date":"2019-05-14T03:46:27.027Z","updated":"2019-05-30T00:52:25.404Z","comments":true,"pin":null,"path":"api/articles/Java8新的异步编程方式CompletableFuture(3).json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/59eae7636fb9a045117044c6\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/59eae7636fb9a045117044c6</a> </p>\n</blockquote>\n<p>前面两篇文章已经整理了CompletableFuture大部分的特性，本文会整理完CompletableFuture余下的特性，以及将它跟RxJava进行比较。</p>\n<h2 id=\"3-6-Either\"><a href=\"#3-6-Either\" class=\"headerlink\" title=\"3.6 Either\"></a>3.6 Either</h2><p>Either 表示的是两个CompletableFuture，当其中任意一个CompletableFuture计算完成的时候就会执行。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">acceptEither(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)</td>\n<td align=\"center\">当任意一个CompletableFuture完成的时候，action这个消费者就会被执行。</td>\n</tr>\n<tr>\n<td align=\"center\">acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)</td>\n<td align=\"center\">当任意一个CompletableFuture完成的时候，action这个消费者就会被执行。使用ForkJoinPool</td>\n</tr>\n<tr>\n<td align=\"center\">acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action, Executor executor)</td>\n<td align=\"center\">当任意一个CompletableFuture完成的时候，action这个消费者就会被执行。使用指定的线程池</td>\n</tr>\n<tr>\n<td align=\"center\">`Random random =  Random();</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<pre><code>CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(()-&gt;{\n\n     {\n        Thread.sleep(random.nextInt());\n    }  (InterruptedException e) {\n        e.printStackTrace();\n    }\n\n     ;\n});\n\nCompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(()-&gt;{\n\n     {\n        Thread.sleep(random.nextInt());\n    }  (InterruptedException e) {\n        e.printStackTrace();\n    }\n\n     ;\n});\n\nCompletableFuture&lt;Void&gt; future =  future1.acceptEither(future2,str-&gt;System.out.println(+str));\n\n {\n    future.get();\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果：The future is from future1 或者 The future is from future2。<br>因为future1和future2，执行的顺序是随机的。</p>\n<p>applyToEither 跟 acceptEither 类似。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">applyToEither(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn)</td>\n<td align=\"center\">当任意一个CompletableFuture完成的时候，fn会被执行，它的返回值会当作新的CompletableFuture<u>的计算结果。</u></td>\n</tr>\n<tr>\n<td align=\"center\">applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn)</td>\n<td align=\"center\">当任意一个CompletableFuture完成的时候，fn会被执行，它的返回值会当作新的CompletableFuture<u>的计算结果。使用ForkJoinPool</u></td>\n</tr>\n<tr>\n<td align=\"center\">applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn, Executor executor)</td>\n<td align=\"center\">当任意一个CompletableFuture完成的时候，fn会被执行，它的返回值会当作新的CompletableFuture<u>的计算结果。使用指定的线程池</u></td>\n</tr>\n<tr>\n<td align=\"center\">`Random random =  Random();</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<pre><code>CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(()-&gt;{\n\n     {\n        Thread.sleep(random.nextInt());\n    }  (InterruptedException e) {\n        e.printStackTrace();\n    }\n\n     ;\n});\n\nCompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(()-&gt;{\n\n     {\n        Thread.sleep(random.nextInt());\n    }  (InterruptedException e) {\n        e.printStackTrace();\n    }\n\n     ;\n});\n\nCompletableFuture&lt;String&gt; future =  future1.applyToEither(future2,str-&gt;+str);\n\n {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果也跟上面的程序类似。</p>\n<h2 id=\"3-7-其他方法\"><a href=\"#3-7-其他方法\" class=\"headerlink\" title=\"3.7 其他方法\"></a>3.7 其他方法</h2><p>allOf、anyOf是CompletableFuture的静态方法。</p>\n<h3 id=\"3-7-1-allOf\"><a href=\"#3-7-1-allOf\" class=\"headerlink\" title=\"3.7.1 allOf\"></a>3.7.1 allOf</h3><table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">allOf(CompletableFuture&lt;?&gt;… cfs)</td>\n<td align=\"center\">在所有Future对象完成后结束，并返回一个future。</td>\n</tr>\n</tbody></table>\n<p>allOf()方法所返回的CompletableFuture，并不能组合前面多个CompletableFuture的计算结果。于是我们借助Java 8的Stream来组合多个future的结果。<br>`CompletableFuture<string> future1 = CompletableFuture.supplyAsync(() -&gt; );</string></p>\n<pre><code>CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; );\n\nCompletableFuture&lt;String&gt; future3 = CompletableFuture.supplyAsync(() -&gt; );\n\nCompletableFuture.allOf(future1, future2, future3)\n        .thenApply(v -&gt;\n        Stream.of(future1, future2, future3)\n                .map(CompletableFuture::join)\n                .collect(Collectors.joining()))\n        .thenAccept(System.out::print);`</code></pre><p>执行结果：</p>\n<p><code>tony cafei aaron</code></p>\n<h3 id=\"3-7-2-anyOf\"><a href=\"#3-7-2-anyOf\" class=\"headerlink\" title=\"3.7.2 anyOf\"></a>3.7.2 anyOf</h3><table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">anyOf(CompletableFuture&lt;?&gt;… cfs)</td>\n<td align=\"center\">在任何一个Future对象结束后结束，并返回一个future。</td>\n</tr>\n<tr>\n<td align=\"center\">`Random rand =  Random();</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">CompletableFuture<string> future1 = CompletableFuture.supplyAsync(() -&gt; {</string></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">{</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">Thread.sleep(rand.nextInt());</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">}  (InterruptedException e) {</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">e.printStackTrace();</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">}</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">;</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">});</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">CompletableFuture<string> future2 = CompletableFuture.supplyAsync(() -&gt; {</string></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">{</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">Thread.sleep(rand.nextInt());</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">}  (InterruptedException e) {</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">e.printStackTrace();</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">}</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">;</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">});</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">CompletableFuture<string> future3 = CompletableFuture.supplyAsync(() -&gt; {</string></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">{</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">Thread.sleep(rand.nextInt());</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">}  (InterruptedException e) {</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">e.printStackTrace();</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">}</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">;</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">});</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<pre><code>CompletableFuture&lt;Object&gt; future =  CompletableFuture.anyOf(future1,future2,future3);\n\n {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>使用anyOf()时，只要某一个future完成，就结束了。所以执行结果可能是”from future1”、”from future2”、”from future3”中的任意一个。</p>\n<p>anyOf 和 acceptEither、applyToEither的区别在于，后两者只能使用在两个future中，而anyOf可以使用在多个future中。</p>\n<h2 id=\"3-8-CompletableFuture异常处理\"><a href=\"#3-8-CompletableFuture异常处理\" class=\"headerlink\" title=\"3.8 CompletableFuture异常处理\"></a>3.8 CompletableFuture异常处理</h2><p>CompletableFuture在运行时如果遇到异常，可以使用get()并抛出异常进行处理，但这并不是一个最好的方法。CompletableFuture本身也提供了几种方式来处理异常。</p>\n<h3 id=\"3-8-1-exceptionally\"><a href=\"#3-8-1-exceptionally\" class=\"headerlink\" title=\"3.8.1 exceptionally\"></a>3.8.1 exceptionally</h3><table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">exceptionally(Function fn)</td>\n<td align=\"center\">只有当CompletableFuture抛出异常的时候，才会触发这个exceptionally的计算，调用function计算值。</td>\n</tr>\n<tr>\n<td align=\"center\">`CompletableFuture.supplyAsync(() -&gt; )</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">.thenApply(s -&gt; {</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">s = ;</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">length = s.length();</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">length;</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">}).thenAccept(i -&gt; System.out.println(i))</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">.exceptionally(t -&gt; {</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">System.out.println( + t);</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">;</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">});`</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>执行结果：</p>\n<p><code>Unexpected error:java.util.concurrent.CompletionException: java.lang.NullPointerException</code></p>\n<p>对上面的代码稍微做了一下修改，修复了空指针的异常。</p>\n<p>`CompletableFuture.supplyAsync(() -&gt; )<br>                .thenApply(s -&gt; {</p>\n<pre><code>     length = s.length();\n     length;\n}).thenAccept(i -&gt; System.out.println(i))\n.exceptionally(t -&gt; {\n    System.out.println( + t);\n     ;\n});`</code></pre><p>执行结果：</p>\n<p>``</p>\n<h3 id=\"3-8-2-whenComplete\"><a href=\"#3-8-2-whenComplete\" class=\"headerlink\" title=\"3.8.2 whenComplete\"></a>3.8.2 whenComplete</h3><p>whenComplete 在上一篇文章其实已经介绍过了，在这里跟exceptionally的作用差不多，可以捕获任意阶段的异常。如果没有异常的话，就执行action。<br>`CompletableFuture.supplyAsync(() -&gt; )<br>                .thenApply(s -&gt; {<br>                    s = ;<br>                     length = s.length();<br>                     length;<br>                }).thenAccept(i -&gt; System.out.println(i))<br>                .whenComplete((result, throwable) -&gt; {</p>\n<pre><code>     (throwable != ) {\n       System.out.println(+throwable);\n    }  {\n        System.out.println(result);\n    }\n\n});`</code></pre><p>执行结果：</p>\n<p><code>Unexpected error:java.util.concurrent.CompletionException: java.lang.NullPointerException</code></p>\n<p>跟whenComplete相似的方法是handle，handle的用法在上一篇文章中也已经介绍过。</p>\n<h1 id=\"四-CompletableFuture-VS-Java8-Stream-VS-RxJava1-amp-RxJava2\"><a href=\"#四-CompletableFuture-VS-Java8-Stream-VS-RxJava1-amp-RxJava2\" class=\"headerlink\" title=\"四. CompletableFuture VS Java8 Stream VS RxJava1 &amp; RxJava2\"></a>四. CompletableFuture VS Java8 Stream VS RxJava1 &amp; RxJava2</h1><p>CompletableFuture 有很多特性跟RxJava很像，所以将CompletableFuture、Java 8 Stream和RxJava做一个相互的比较。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">composable</th>\n<th align=\"center\">lazy</th>\n<th align=\"center\">resuable</th>\n<th align=\"center\">async</th>\n<th align=\"center\">cached</th>\n<th align=\"center\">push</th>\n<th align=\"center\">back pressure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">CompletableFuture</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">不支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">不支持</td>\n</tr>\n<tr>\n<td align=\"center\">Stream</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">不支持</td>\n<td align=\"center\">不支持</td>\n<td align=\"center\">不支持</td>\n<td align=\"center\">不支持</td>\n<td align=\"center\">不支持</td>\n</tr>\n<tr>\n<td align=\"center\">Observable(RxJava1)</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n</tr>\n<tr>\n<td align=\"center\">Observable(RxJava2)</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">不支持</td>\n</tr>\n<tr>\n<td align=\"center\">Flowable(RxJava2)</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n</tr>\n</tbody></table>\n<h1 id=\"五-总结\"><a href=\"#五-总结\" class=\"headerlink\" title=\"五. 总结\"></a>五. 总结</h1><p>Java 8提供了一种函数风格的异步和事件驱动编程模型CompletableFuture，它不会造成堵塞。CompletableFuture背后依靠的是fork/join框架来启动新的线程实现异步与并发。当然，我们也能通过指定线程池来做这些事情。</p>\n<p>CompletableFuture特别是对微服务架构而言，会有很大的作为。举一个具体的场景，电商的商品页面可能会涉及到商品详情服务、商品评论服务、相关商品推荐服务等等。获取商品的信息时（/productdetails?productid=xxx），需要调用多个服务来处理这一个请求并返回结果。这里可能会涉及到并发编程，我们完全可以使用Java 8的CompletableFuture或者RxJava来实现。</p>\n<p>先前的文章：<br><a href=\"https://juejin.im/post/59eae61b51882549fc512b34\" target=\"_blank\" rel=\"noopener\">Java8新的异步编程方式 CompletableFuture(一)</a><br><a href=\"https://juejin.im/post/59eae6e4f265da430e4e4cb5\" target=\"_blank\" rel=\"noopener\">Java8新的异步编程方式 CompletableFuture(二)</a></p>\n","text":"本文转载自 https://juejin.im/post/59eae7636fb9a045117044c6 前面两篇文章已经整理了CompletableFuture大部分的特性，本文会整理完CompletableFuture余下的特性，以及将它跟RxJava进行比较。3.6 Ei","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"},{"name":"RxJava","slug":"RxJava","count":1,"path":"api/tags/RxJava.json"}]},{"title":"Java8新的异步编程方式 CompletableFuture(二)","slug":"Java8新的异步编程方式CompletableFuture(2)","date":"2019-05-14T03:46:06.006Z","updated":"2019-05-30T00:52:25.403Z","comments":true,"pin":null,"path":"api/articles/Java8新的异步编程方式CompletableFuture(2).json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/59eae6e4f265da430e4e4cb5\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/59eae6e4f265da430e4e4cb5</a> </p>\n</blockquote>\n<p><a href=\"https://juejin.im/post/59eae61b51882549fc512b34\" target=\"_blank\" rel=\"noopener\">上一篇文章</a>，讲述了Future模式的机制、缺点，CompletableFuture产生的由来、静态工厂方法、complete()方法等等。</p>\n<p>本文将继续整理CompletableFuture的特性。</p>\n<h2 id=\"3-3-转换\"><a href=\"#3-3-转换\" class=\"headerlink\" title=\"3.3 转换\"></a>3.3 转换</h2><p>我们可以通过CompletableFuture来异步获取一组数据，并对数据进行一些转换，类似RxJava、Scala的map、flatMap操作。</p>\n<h3 id=\"3-3-1-map\"><a href=\"#3-3-1-map\" class=\"headerlink\" title=\"3.3.1 map\"></a>3.3.1 map</h3><table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">thenApply(Function&lt;? super T,? extends U&gt; fn)</td>\n<td align=\"center\">接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture</td>\n</tr>\n<tr>\n<td align=\"center\">thenApplyAsync(Function&lt;? super T,? extends U&gt; fn)</td>\n<td align=\"center\">接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture，使用ForkJoinPool</td>\n</tr>\n<tr>\n<td align=\"center\">thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor)</td>\n<td align=\"center\">接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture，使用指定的线程池</td>\n</tr>\n</tbody></table>\n<p>thenApply的功能相当于将CompletableFuture<t>转换成CompletableFuture<u>。\n`CompletableFuture<string> future = CompletableFuture.supplyAsync(() -&gt; );</string></u></t></p>\n<pre><code>future = future.thenApply( Function&lt;String, String&gt;() {\n\n\n    {\n\n         s + ;\n    }\n}).thenApply( Function&lt;String, String&gt;() {\n\n    {\n\n         s.toUpperCase();\n    }\n});\n\n {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>再用lambda表达式简化一下</p>\n<p>`CompletableFuture<string> future = CompletableFuture.supplyAsync(() -&gt; )<br>                .thenApply(s -&gt; s + ).thenApply(String::toUpperCase);</string></p>\n<pre><code> {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果：</p>\n<p><code>HELLO WORLD</code></p>\n<p>下面的例子，展示了数据流的类型经历了如下的转换：String -&gt; Integer -&gt; Double。</p>\n<p>`CompletableFuture<double> future = CompletableFuture.supplyAsync(() -&gt; )<br>                .thenApply(Integer::parseInt)<br>                .thenApply(i-&gt;i*);</double></p>\n<pre><code> {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果：</p>\n<p>``</p>\n<h3 id=\"3-3-2-flatMap\"><a href=\"#3-3-2-flatMap\" class=\"headerlink\" title=\"3.3.2 flatMap\"></a>3.3.2 flatMap</h3><table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">thenCompose(Function&lt;? super T, ? extends CompletionStage<u>&gt; fn)</u></td>\n<td align=\"center\">在异步操作完成的时候对异步操作的结果进行一些操作，并且仍然返回CompletableFuture类型。</td>\n</tr>\n<tr>\n<td align=\"center\">thenComposeAsync(Function&lt;? super T, ? extends CompletionStage<u>&gt; fn)</u></td>\n<td align=\"center\">在异步操作完成的时候对异步操作的结果进行一些操作，并且仍然返回CompletableFuture类型。使用ForkJoinPool。</td>\n</tr>\n<tr>\n<td align=\"center\">thenComposeAsync(Function&lt;? super T, ? extends CompletionStage<u>&gt; fn,Executor executor)</u></td>\n<td align=\"center\">在异步操作完成的时候对异步操作的结果进行一些操作，并且仍然返回CompletableFuture类型。使用指定的线程池。</td>\n</tr>\n</tbody></table>\n<p>thenCompose可以用于组合多个CompletableFuture，将前一个结果作为下一个计算的参数，它们之间存在着先后顺序。<br>`CompletableFuture<string> future = CompletableFuture.supplyAsync(() -&gt; )<br>                .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + ));</string></p>\n<pre><code> {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果：</p>\n<p><code>Hello World</code></p>\n<p>下面的例子展示了多次调用thenCompose()</p>\n<p>`CompletableFuture<double> future = CompletableFuture.supplyAsync(() -&gt; )<br>                .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + ))<br>                .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; Double.parseDouble(s)));</double></p>\n<pre><code> {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果：</p>\n<p>``</p>\n<h2 id=\"3-4-组合\"><a href=\"#3-4-组合\" class=\"headerlink\" title=\"3.4 组合\"></a>3.4 组合</h2><table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">thenCombine(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn)</td>\n<td align=\"center\">当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。</td>\n</tr>\n<tr>\n<td align=\"center\">thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn)</td>\n<td align=\"center\">当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。使用ForkJoinPool。</td>\n</tr>\n<tr>\n<td align=\"center\">thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn, Executor executor)</td>\n<td align=\"center\">当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。使用指定的线程池。</td>\n</tr>\n</tbody></table>\n<p>现在有CompletableFuture<t>、CompletableFuture<u>和一个函数(T,U)-&gt;V，thenCompose就是将CompletableFuture<t>和CompletableFuture<u>变为CompletableFuture<v>。\n`CompletableFuture<string> future1 = CompletableFuture.supplyAsync(() -&gt; );<br>        CompletableFuture<integer> future2 = CompletableFuture.supplyAsync(() -&gt; );</integer></string></v></u></t></u></t></p>\n<pre><code>CompletableFuture&lt;Double&gt; future = future1.thenCombine(future2, (s, i) -&gt; Double.parseDouble(s + i));\n\n {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果：</p>\n<p>``\n使用thenCombine()之后future1、future2之间是并行执行的，最后再将结果汇总。这一点跟thenCompose()不同。</p>\n<p>thenAcceptBoth跟thenCombine类似，但是返回CompletableFuture类型。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">thenAcceptBoth(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action)</td>\n<td align=\"center\">当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。</td>\n</tr>\n<tr>\n<td align=\"center\">thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action)</td>\n<td align=\"center\">当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。使用ForkJoinPool。</td>\n</tr>\n<tr>\n<td align=\"center\">thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action, Executor executor)</td>\n<td align=\"center\">当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。使用指定的线程池。</td>\n</tr>\n<tr>\n<td align=\"center\">`CompletableFuture<string> future1 = CompletableFuture.supplyAsync(() -&gt; );</string></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">CompletableFuture<integer> future2 = CompletableFuture.supplyAsync(() -&gt; );</integer></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<pre><code>CompletableFuture&lt;Void&gt; future = future1.thenAcceptBoth(future2, (s, i) -&gt; System.out.println(Double.parseDouble(s + i)));\n\n {\n    future.get();\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果：</p>\n<p>``</p>\n<h2 id=\"3-5-计算结果完成时的处理\"><a href=\"#3-5-计算结果完成时的处理\" class=\"headerlink\" title=\"3.5 计算结果完成时的处理\"></a>3.5 计算结果完成时的处理</h2><p>当CompletableFuture完成计算结果后，我们可能需要对结果进行一些处理。</p>\n<p>/#/#/#3.5.1 执行特定的Action</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">whenComplete(BiConsumer&lt;? super T,? super Throwable&gt; action)</td>\n<td align=\"center\">当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。</td>\n</tr>\n<tr>\n<td align=\"center\">whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action)</td>\n<td align=\"center\">当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。使用ForkJoinPool。</td>\n</tr>\n<tr>\n<td align=\"center\">whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action, Executor executor)</td>\n<td align=\"center\">当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。使用指定的线程池。</td>\n</tr>\n<tr>\n<td align=\"center\">`CompletableFuture.supplyAsync(() -&gt; )</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">.thenApply(s-&gt;s+)</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">.thenApply(s-&gt;s+ )</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">.thenApply(String::toLowerCase)</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">.whenComplete((result, throwable) -&gt; System.out.println(result));`</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>执行结果：</p>\n<p><code>hello world\n is completablefuture demo</code></p>\n<p>/#/#/#3.5.2 执行完Action可以做转换</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)</td>\n<td align=\"center\">当CompletableFuture完成计算结果或者抛出异常的时候，执行提供的fn</td>\n</tr>\n<tr>\n<td align=\"center\">handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)</td>\n<td align=\"center\">当CompletableFuture完成计算结果或者抛出异常的时候，执行提供的fn，使用ForkJoinPool。</td>\n</tr>\n<tr>\n<td align=\"center\">handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn, Executor executor)</td>\n<td align=\"center\">当CompletableFuture完成计算结果或者抛出异常的时候，执行提供的fn，使用指定的线程池。</td>\n</tr>\n<tr>\n<td align=\"center\">`CompletableFuture<double> future = CompletableFuture.supplyAsync(() -&gt; )</double></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">.thenApply(s-&gt;s+)</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">.handle((s, t) -&gt; s !=  ? Double.parseDouble(s) : );</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<pre><code> {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果：</p>\n<p>``</p>\n<p>在这里，handle()的参数是BiFunction，apply()方法返回R，相当于转换的操作。</p>\n<p>`{</p>\n<pre><code>;\n\n\n &lt;V&gt; {\n    Objects.requireNonNull(after);\n     (T t, U u) -&gt; after.apply(apply(t, u));\n}</code></pre><p>}`</p>\n<p>而whenComplete()的参数是BiConsumer，accept()方法返回void。</p>\n<p>`{</p>\n<pre><code>;\n\n\n{\n    Objects.requireNonNull(after);\n\n     (l, r) -&gt; {\n        accept(l, r);\n        after.accept(l, r);\n    };\n}</code></pre><p>}`\n所以，handle()相当于whenComplete()+转换。</p>\n<p>/#/#/#3.5.3 纯消费(执行Action)</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">thenAccept(Consumer&lt;? super T&gt; action)</td>\n<td align=\"center\">当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值</td>\n</tr>\n<tr>\n<td align=\"center\">thenAcceptAsync(Consumer&lt;? super T&gt; action)</td>\n<td align=\"center\">当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值，使用ForkJoinPool。</td>\n</tr>\n<tr>\n<td align=\"center\">thenAcceptAsync(Consumer&lt;? super T&gt; action, Executor executor)</td>\n<td align=\"center\">当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值</td>\n</tr>\n</tbody></table>\n<p>thenAccept()是只会对计算结果进行消费而不会返回任何结果的方法。<br><code>CompletableFuture.supplyAsync(() -&gt; )\n                .thenApply(s-&gt;s+)\n                .thenApply(s-&gt;s+ )\n                .thenApply(String::toLowerCase)\n                .thenAccept(System.out::print);</code></p>\n<p>执行结果：</p>\n<p><code>hello world\n is completablefuture demo</code></p>\n","text":"本文转载自 https://juejin.im/post/59eae6e4f265da430e4e4cb5 上一篇文章，讲述了Future模式的机制、缺点，CompletableFuture产生的由来、静态工厂方法、complete()方法等等。本文将继续整理Completabl","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]},{"title":"Java8的CompletableFuture进阶之道","slug":"Java8的CompletableFuture进阶之道","date":"2019-05-14T03:26:08.008Z","updated":"2019-05-30T00:52:25.405Z","comments":true,"pin":null,"path":"api/articles/Java8的CompletableFuture进阶之道.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5ca47aa0e51d457131257269\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ca47aa0e51d457131257269</a> </p>\n</blockquote>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>作为Java 8 Concurrency API改进而引入，本文是CompletableFuture类的功能和用例的介绍。同时在Java 9 也有对CompletableFuture有一些改进，之后再进入讲解。</p>\n<h1 id=\"Future计算\"><a href=\"#Future计算\" class=\"headerlink\" title=\"Future计算\"></a>Future计算</h1><p>Future异步计算很难操作，通常我们希望将任何计算逻辑视为一系列步骤。但是在异步计算的情况下，表示为回调的方法往往分散在代码中或者深深地嵌套在彼此内部。但是当我们需要处理其中一个步骤中可能发生的错误时，情况可能会变得更复杂。</p>\n<p>Futrue接口是Java 5中作为异步计算而新增的，但它没有任何方法去进行计算组合或者处理可能出现的错误。</p>\n<p>在Java 8中，引入了CompletableFuture类。与Future接口一起，它还实现了CompletionStage接口。此接口定义了可与其他Future组合成异步计算契约。</p>\n<p>CompletableFuture同时是一个组合和一个框架，具有大约50种不同的构成，结合，执行异步计算步骤和处理错误。</p>\n<p>如此庞大的API可能会令人难以招架，下文将调一些重要的做重点介绍。</p>\n<h1 id=\"使用CompletableFuture作为Future实现\"><a href=\"#使用CompletableFuture作为Future实现\" class=\"headerlink\" title=\"使用CompletableFuture作为Future实现\"></a>使用CompletableFuture作为Future实现</h1><p>首先，CompletableFuture类实现Future接口，因此你可以将其用作Future实现，但需要额外的完成实现逻辑。</p>\n<p>例如，你可以使用无构参构造函数创建此类的实例，然后使用<code>complete</code>方法完成。消费者可以使用get方法来阻塞当前线程，直到<code>get()</code>结果。</p>\n<p>在下面的示例中，我们有一个创建CompletableFuture实例的方法，然后在另一个线程中计算并立即返回Future。</p>\n<p>计算完成后，该方法通过将结果提供给完整方法来完成Future：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Future&lt;String&gt; calculateAsync() throws InterruptedException &#123;</span><br><span class=\"line\">    CompletableFuture&lt;String&gt; completableFuture </span><br><span class=\"line\">      = new CompletableFuture&lt;&gt;();</span><br><span class=\"line\"> </span><br><span class=\"line\">    Executors.newCachedThreadPool().submit(() -&gt; &#123;</span><br><span class=\"line\">        Thread.sleep(500);</span><br><span class=\"line\">        completableFuture.complete(&quot;Hello&quot;);</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">    return completableFuture;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>为了分离计算，我们使用了<em>Executor</em> API ，这种创建和完成<em>CompletableFuture的方法</em>可以与任何并发包（包括原始线程）一起使用。</p>\n<p>请注意，<strong>该<code>calculateAsync</code>方法返回一个<code>Future</code>实例。</strong></p>\n<p>我们只是调用方法，接收<em>Future</em>实例并在我们准备阻塞结果时调用它的<em>get</em>方法。</p>\n<p>另请注意，<em>get</em>方法抛出一些已检查的异常，即<em>ExecutionException</em>（封装计算期间发生的异常）和<em>InterruptedException</em>（表示执行方法的线程被中断的异常）：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future&lt;String&gt; completableFuture = calculateAsync();</span><br><span class=\"line\"> </span><br><span class=\"line\">// ... </span><br><span class=\"line\"> </span><br><span class=\"line\">String result = completableFuture.get();</span><br><span class=\"line\">assertEquals(&quot;Hello&quot;, result);</span><br></pre></td></tr></table></figure></div>\n\n<p>如果你已经知道计算的结果，也可以用变成同步的方式来返回结果。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future&lt;String&gt; completableFuture = </span><br><span class=\"line\">  CompletableFuture.completedFuture(&quot;Hello&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">// ...</span><br><span class=\"line\"> </span><br><span class=\"line\">String result = completableFuture.get();</span><br><span class=\"line\">assertEquals(&quot;Hello&quot;, result);</span><br></pre></td></tr></table></figure></div>\n\n<p>作为在某些场景中，你可能希望取消Future任务的执行。</p>\n<p>假设我们没有找到结果并决定完全取消异步执行任务。这可以通过Future的取消方法完成。此方法<code>mayInterruptIfRunning</code>，但在CompletableFuture的情况下，它没有任何效果，因为中断不用于控制CompletableFuture的处理。</p>\n<p>这是异步方法的修改版本：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Future&lt;String&gt; calculateAsyncWithCancellation() throws InterruptedException &#123;</span><br><span class=\"line\">    CompletableFuture&lt;String&gt; completableFuture = new CompletableFuture&lt;&gt;();</span><br><span class=\"line\"> </span><br><span class=\"line\">    Executors.newCachedThreadPool().submit(() -&gt; &#123;</span><br><span class=\"line\">        Thread.sleep(500);</span><br><span class=\"line\">        completableFuture.cancel(false);</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">    return completableFuture;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>当我们使用Future.get()方法阻塞结果时，<code>cancel()</code>表示取消执行，它将抛出CancellationException：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future&lt;String&gt; future = calculateAsyncWithCancellation();</span><br><span class=\"line\">future.get(); // CancellationException</span><br></pre></td></tr></table></figure></div>\n\n<h1 id=\"API介绍\"><a href=\"#API介绍\" class=\"headerlink\" title=\"API介绍\"></a>API介绍</h1><h2 id=\"static方法说明\"><a href=\"#static方法说明\" class=\"headerlink\" title=\"static方法说明\"></a>static方法说明</h2><p>上面的代码很简单，下面介绍几个 <strong>static</strong> 方法，它们使用任务来实例化一个 CompletableFuture 实例。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.runAsync(Runnable runnable);</span><br><span class=\"line\">CompletableFuture.runAsync(Runnable runnable, Executor executor);</span><br><span class=\"line\"></span><br><span class=\"line\">CompletableFuture.supplyAsync(Supplier&lt;U&gt; supplier);</span><br><span class=\"line\">CompletableFuture.supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</span><br></pre></td></tr></table></figure></div>\n\n<pre><code>* runAsync 方法接收的是 Runnable 的实例，但是它没有返回值\n* supplyAsync 方法是JDK8函数式接口，无参数，会返回一个结果\n* 这两个方法是 executor 的升级，表示让任务在指定的线程池中执行，不指定的话，通常任务是在 ForkJoinPool.commonPool() 线程池中执行的。</code></pre><h2 id=\"supplyAsync-使用\"><a href=\"#supplyAsync-使用\" class=\"headerlink\" title=\"supplyAsync()使用\"></a>supplyAsync()使用</h2><p>静态方法<code>runAsync</code>和<code>supplyAsync</code>允许我们相应地从Runnable和Supplier功能类型中创建CompletableFuture实例。</p>\n<p>该Runnable的接口是在线程使用旧的接口，它不允许返回值。</p>\n<p>Supplier接口是一个不具有参数，并返回参数化类型的一个值的单个方法的通用功能接口。</p>\n<p>这允许将Supplier的实例作为lambda表达式提供，该表达式执行计算并返回结果：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;String&gt; future</span><br><span class=\"line\">  = CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">// ...</span><br><span class=\"line\"> </span><br><span class=\"line\">assertEquals(&quot;Hello&quot;, future.get());</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"thenRun-使用\"><a href=\"#thenRun-使用\" class=\"headerlink\" title=\"thenRun()使用\"></a>thenRun()使用</h2><p>在两个任务任务A，任务B中，如果既不需要任务A的值也不想在任务B中引用，那么你可以将Runnable lambda 传递给<code>thenRun()</code>方法。在下面的示例中，在调用future.get()方法之后，我们只需在控制台中打印一行：</p>\n<p>模板</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.runAsync(() -&gt; &#123;&#125;).thenRun(() -&gt; &#123;&#125;); </span><br><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &quot;resultA&quot;).thenRun(() -&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure></div>\n\n<pre><code>* 第一行用的是 `thenRun(Runnable runnable)`，任务 A 执行完执行 B，并且 B 不需要 A 的结果。\n* 第二行用的是 `thenRun(Runnable runnable)`，任务 A 执行完执行 B，会返回`resultA`，但是 B 不需要 A 的结果。</code></pre><p>实战</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;String&gt; completableFuture </span><br><span class=\"line\">  = CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">CompletableFuture&lt;Void&gt; future = completableFuture</span><br><span class=\"line\">  .thenRun(() -&gt; System.out.println(&quot;Computation finished.&quot;));</span><br><span class=\"line\"> </span><br><span class=\"line\">future.get();</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"thenAccept-使用\"><a href=\"#thenAccept-使用\" class=\"headerlink\" title=\"thenAccept()使用\"></a>thenAccept()使用</h2><p>在两个任务任务A，任务B中，如果你不需要在Future中有返回值，则可以用 <code>thenAccept</code>方法接收将计算结果传递给它。最后的future.get（）调用返回Void类型的实例。</p>\n<p>模板</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.runAsync(() -&gt; &#123;&#125;).thenAccept(resultA -&gt; &#123;&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &quot;resultA&quot;).thenAccept(resultA -&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure></div>\n\n<pre><code>* 第一行中，`runAsync`不会有返回值，第二个方法`thenAccept`，接收到的resultA值为null，同时任务B也不会有返回结果\n* 第二行中，`supplyAsync`有返回值，同时任务B不会有返回结果。</code></pre><p>实战</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;String&gt; completableFuture</span><br><span class=\"line\">  = CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">CompletableFuture&lt;Void&gt; future = completableFuture</span><br><span class=\"line\">  .thenAccept(s -&gt; System.out.println(&quot;Computation returned: &quot; + s));</span><br><span class=\"line\"> </span><br><span class=\"line\">future.get();</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"thenApply-使用\"><a href=\"#thenApply-使用\" class=\"headerlink\" title=\"thenApply()使用\"></a>thenApply()使用</h2><p>在两个任务任务A，任务B中，任务B想要任务A计算的结果，可以用<code>thenApply</code>方法来接受一个函数实例，用它来处理结果，并返回一个Future函数的返回值：</p>\n<p>模板</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.runAsync(() -&gt; &#123;&#125;).thenApply(resultA -&gt; &quot;resultB&quot;);</span><br><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &quot;resultA&quot;).thenApply(resultA -&gt; resultA + &quot; resultB&quot;);</span><br></pre></td></tr></table></figure></div>\n\n<pre><code>* 第二行用的是 thenApply(Function fn)，任务 A 执行完执行 B，B 需要 A 的结果，同时任务 B 有返回值。</code></pre><p>实战</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;String&gt; completableFuture</span><br><span class=\"line\">  = CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">CompletableFuture&lt;String&gt; future = completableFuture</span><br><span class=\"line\">  .thenApply(s -&gt; s + &quot; World&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">assertEquals(&quot;Hello World&quot;, future.get());</span><br></pre></td></tr></table></figure></div>\n\n<p>当然，多个任务的情况下，如果任务 B 后面还有任务 C，往下继续调用 .thenXxx() 即可。</p>\n<h2 id=\"thenCompose-使用\"><a href=\"#thenCompose-使用\" class=\"headerlink\" title=\"thenCompose()使用\"></a>thenCompose()使用</h2><p>接下来会有一个很有趣的设计模式；</p>\n<p>CompletableFuture API 的最佳场景是能够在一系列计算步骤中组合CompletableFuture实例。</p>\n<p>这种组合结果本身就是CompletableFuture，允许进一步再续组合。这种方法在函数式语言中无处不在，通常被称为<code>monadic设计模式</code>。</p>\n<p>简单说，Monad就是一种设计模式，表示将一个运算过程，通过函数拆解成互相连接的多个步骤。你只要提供下一步运算所需的函数，整个运算就会自动进行下去。</p>\n<p>在下面的示例中，我们使用thenCompose方法按顺序组合两个Futures。</p>\n<p>请注意，此方法采用返回CompletableFuture实例的函数。该函数的参数是先前计算步骤的结果。这允许我们在下一个CompletableFuture的lambda中使用这个值：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;String&gt; completableFuture </span><br><span class=\"line\">  = CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;)</span><br><span class=\"line\">    .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + &quot; World&quot;));</span><br><span class=\"line\"> </span><br><span class=\"line\">assertEquals(&quot;Hello World&quot;, completableFuture.get());</span><br></pre></td></tr></table></figure></div>\n\n<p>该thenCompose方法连同thenApply一样实现了结果的合并计算。但是他们的内部形式是不一样的，它们与Java 8中可用的Stream和Optional类的map和flatMap方法是有着类似的设计思路在里面的。</p>\n<p>两个方法都接收一个CompletableFuture并将其应用于计算结果，但thenCompose（flatMap）方法接收一个函数，该函数返回相同类型的另一个CompletableFuture对象。此功能结构允许将这些类的实例继续进行组合计算。</p>\n<h2 id=\"thenCombine\"><a href=\"#thenCombine\" class=\"headerlink\" title=\"thenCombine()\"></a>thenCombine()</h2><p>取两个任务的结果</p>\n<p>如果要执行两个独立的任务，并对其结果执行某些操作，可以用Future的thenCombine方法：</p>\n<p>模板</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;String&gt; cfA = CompletableFuture.supplyAsync(() -&gt; &quot;resultA&quot;);</span><br><span class=\"line\">CompletableFuture&lt;String&gt; cfB = CompletableFuture.supplyAsync(() -&gt; &quot;resultB&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">cfA.thenAcceptBoth(cfB, (resultA, resultB) -&gt; &#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">cfA.thenCombine(cfB, (resultA, resultB) -&gt; &quot;result A + B&quot;);</span><br></pre></td></tr></table></figure></div>\n\n<p>实战</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;String&gt; completableFuture </span><br><span class=\"line\">  = CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;)</span><br><span class=\"line\">    .thenCombine(CompletableFuture.supplyAsync(</span><br><span class=\"line\">      () -&gt; &quot; World&quot;), (s1, s2) -&gt; s1 + s2));</span><br><span class=\"line\"> </span><br><span class=\"line\">assertEquals(&quot;Hello World&quot;, completableFuture.get());</span><br></pre></td></tr></table></figure></div>\n\n<p>更简单的情况是，当你想要使用两个Future结果时，但不需要将任何结果值进行返回时，可以用<code>thenAcceptBoth</code>，它表示后续的处理不需要返回值，而 thenCombine 表示需要返回值：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture future = CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;)</span><br><span class=\"line\">  .thenAcceptBoth(CompletableFuture.supplyAsync(() -&gt; &quot; World&quot;),</span><br><span class=\"line\">    (s1, s2) -&gt; System.out.println(s1 + s2));</span><br></pre></td></tr></table></figure></div>\n\n<h1 id=\"thenApply-和thenCompose-之间的区别\"><a href=\"#thenApply-和thenCompose-之间的区别\" class=\"headerlink\" title=\"thenApply()和thenCompose()之间的区别\"></a>thenApply()和thenCompose()之间的区别</h1><p>在前面的部分中，我们展示了关于thenApply()和thenCompose()的示例。这两个API都是使用的CompletableFuture调用，但这两个API的使用是不同的。</p>\n<h2 id=\"thenApply\"><a href=\"#thenApply\" class=\"headerlink\" title=\"thenApply()\"></a>thenApply()</h2><p>此方法用于处理先前调用的<strong>结果</strong>。但是，要记住的一个关键点是返回类型是转换泛型中的类型，是同一个CompletableFuture。</p>\n<p>因此，当我们想要转换CompletableFuture 调用的结果时，效果是这样的 ：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;Integer&gt; finalResult = compute().thenApply(s-&gt; s + 1);</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"thenCompose\"><a href=\"#thenCompose\" class=\"headerlink\" title=\"thenCompose()\"></a>thenCompose()</h2><p>该thenCompose()方法类似于thenApply()在都返回一个新的计算结果。但是，thenCompose()使用前一个Future作为参数。它会直接使结果变新的Future，而不是我们在thenApply()中到的嵌套Future，而是用来连接两个CompletableFuture，是生成一个新的CompletableFuture：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;Integer&gt; computeAnother(Integer i)&#123;</span><br><span class=\"line\">    return CompletableFuture.supplyAsync(() -&gt; 10 + i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">CompletableFuture&lt;Integer&gt; finalResult = compute().thenCompose(this::computeAnother);</span><br></pre></td></tr></table></figure></div>\n\n<p>因此，如果想要继续嵌套链接<em>CompletableFuture</em> 方法，那么最好使用<em>thenCompose()</em>。</p>\n<h1 id=\"并行运行多个任务\"><a href=\"#并行运行多个任务\" class=\"headerlink\" title=\"并行运行多个任务\"></a>并行运行多个任务</h1><p>当我们需要并行执行多个任务时，我们通常希望等待所有它们执行，然后处理它们的组合结果。</p>\n<p>该<code>CompletableFuture.allOf</code>静态方法允许等待所有的完成任务：</p>\n<p>API</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs)&#123;...&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>实战</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;String&gt; future1  </span><br><span class=\"line\">  = CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;);</span><br><span class=\"line\">CompletableFuture&lt;String&gt; future2  </span><br><span class=\"line\">  = CompletableFuture.supplyAsync(() -&gt; &quot;Beautiful&quot;);</span><br><span class=\"line\">CompletableFuture&lt;String&gt; future3  </span><br><span class=\"line\">  = CompletableFuture.supplyAsync(() -&gt; &quot;World&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">CompletableFuture&lt;Void&gt; combinedFuture </span><br><span class=\"line\">  = CompletableFuture.allOf(future1, future2, future3);</span><br><span class=\"line\"> </span><br><span class=\"line\">// ...</span><br><span class=\"line\"> </span><br><span class=\"line\">combinedFuture.get();</span><br><span class=\"line\"> </span><br><span class=\"line\">assertTrue(future1.isDone());</span><br><span class=\"line\">assertTrue(future2.isDone());</span><br><span class=\"line\">assertTrue(future3.isDone());</span><br></pre></td></tr></table></figure></div>\n\n<p>请注意，CompletableFuture.allOf()的返回类型是CompletableFuture 。这种方法的局限性在于它不会返回所有任务的综合结果。相反，你必须手动从Futures获取结果。幸运的是，CompletableFuture.join()方法和Java 8 Streams API可以解决：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String combined = Stream.of(future1, future2, future3)</span><br><span class=\"line\">  .map(CompletableFuture::join)</span><br><span class=\"line\">  .collect(Collectors.joining(&quot; &quot;));</span><br><span class=\"line\"> </span><br><span class=\"line\">assertEquals(&quot;Hello Beautiful World&quot;, combined);</span><br></pre></td></tr></table></figure></div>\n\n<p>CompletableFuture 提供了 join() 方法，它的功能和 get() 方法是一样的，都是阻塞获取值，它们的区别在于 join() 抛出的是 unchecked Exception。这使得它可以在Stream.map（）方法中用作方法引用。</p>\n<h1 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h1><p>说到这里，我们顺便来说下 CompletableFuture 的异常处理。这里我们要介绍两个方法：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public CompletableFuture&lt;T&gt; exceptionally(Function&lt;Throwable, ? extends T&gt; fn);</span><br><span class=\"line\">public &lt;U&gt; CompletionStage&lt;U&gt; handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn);</span><br></pre></td></tr></table></figure></div>\n\n<p>看下代码</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &quot;resultA&quot;)</span><br><span class=\"line\">    .thenApply(resultA -&gt; resultA + &quot; resultB&quot;)</span><br><span class=\"line\">    .thenApply(resultB -&gt; resultB + &quot; resultC&quot;)</span><br><span class=\"line\">    .thenApply(resultC -&gt; resultC + &quot; resultD&quot;);</span><br></pre></td></tr></table></figure></div>\n\n<p>上面的代码中，任务 A、B、C、D 依次执行，如果任务 A 抛出异常（当然上面的代码不会抛出异常），那么后面的任务都得不到执行。如果任务 C 抛出异常，那么任务 D 得不到执行。</p>\n<p>那么我们怎么处理异常呢？看下面的代码，我们在任务 A 中抛出异常，并对其进行处理：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    throw new RuntimeException();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">        .exceptionally(ex -&gt; &quot;errorResultA&quot;)</span><br><span class=\"line\">        .thenApply(resultA -&gt; resultA + &quot; resultB&quot;)</span><br><span class=\"line\">        .thenApply(resultB -&gt; resultB + &quot; resultC&quot;)</span><br><span class=\"line\">        .thenApply(resultC -&gt; resultC + &quot; resultD&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(future.join());</span><br></pre></td></tr></table></figure></div>\n\n<p>上面的代码中，任务 A 抛出异常，然后通过<code>.exceptionally()</code> 方法处理了异常，并返回新的结果，这个新的结果将传递给任务 B。所以最终的输出结果是：</p>\n<p>errorResultA resultB resultC resultD<br> <div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String name = null;</span><br><span class=\"line\"> </span><br><span class=\"line\">// ...</span><br><span class=\"line\"> </span><br><span class=\"line\">CompletableFuture&lt;String&gt; completableFuture  </span><br><span class=\"line\">  =  CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">      if (name == null) &#123;</span><br><span class=\"line\">          throw new RuntimeException(&quot;Computation error!&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return &quot;Hello, &quot; + name;</span><br><span class=\"line\">  &#125;)&#125;).handle((s, t) -&gt; s != null ? s : &quot;Hello, Stranger!&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">assertEquals(&quot;Hello, Stranger!&quot;, completableFuture.get());</span><br></pre></td></tr></table></figure></div></p>\n<p>当然，它们也可以都为 null，因为如果它作用的那个 CompletableFuture 实例没有返回值的时候，s 就是 null。</p>\n<h1 id=\"Async后缀方法\"><a href=\"#Async后缀方法\" class=\"headerlink\" title=\"Async后缀方法\"></a>Async后缀方法</h1><p><em>CompletableFuture</em>类中的API的大多数方法都有两个带有<em>Async</em>后缀的附加修饰。这些方法表示用于异步线程。</p>\n<p>没有<em>Async</em>后缀的方法使用调用线程运行下一个执行线程阶段。不带<em>Async</em>方法使用<em>ForkJoinPool.commonPool()</em>线程池的<em>fork / join</em>实现运算任务。带有<em>Async</em>方法使用传递式的<em>Executor</em>任务去运行。</p>\n<p>下面附带一个案例，可以看到有<em>thenApplyAsync</em>方法。在程序内部，线程被包装到<em>ForkJoinTask</em>实例中。这样可以进一步并行化你的计算并更有效地使用系统资源。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture&lt;String&gt; completableFuture  </span><br><span class=\"line\">  = CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">CompletableFuture&lt;String&gt; future = completableFuture</span><br><span class=\"line\">  .thenApplyAsync(s -&gt; s + &quot; World&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">assertEquals(&quot;Hello World&quot;, future.get());</span><br></pre></td></tr></table></figure></div>\n\n<h1 id=\"JDK-9-CompletableFuture-API\"><a href=\"#JDK-9-CompletableFuture-API\" class=\"headerlink\" title=\"JDK 9 CompletableFuture API\"></a>JDK 9 CompletableFuture API</h1><p>在Java 9中， CompletableFuture API通过以下更改得到了进一步增强：</p>\n<pre><code>* 新工厂方法增加了\n* 支持延迟和超时\n* 改进了对子类化的支持。</code></pre><p>引入了新的实例API：</p>\n<pre><code>* Executor defaultExecutor()\n* CompletableFuturenewIncompleteFuture()\n* CompletableFuture copy()\n* CompletionStage minimalCompletionStage()\n* CompletableFuture completeAsync(Supplier&lt;? extends T&gt; supplier, Executor executor)\n* CompletableFuture completeAsync(Supplier&lt;? extends T&gt; supplier)\n* CompletableFuture orTimeout(long timeout, TimeUnit unit)\n* CompletableFuture completeOnTimeout(T value, long timeout, TimeUnit unit)</code></pre><p>还有一些静态实用方法：</p>\n<pre><code>* Executor delayedExecutor(long delay, TimeUnit unit, Executor executor)\n* Executor delayedExecutor(long delay, TimeUnit unit)\n* CompletionStagecompletedStage(U value)    * CompletionStagefailedStage(Throwable ex)    * CompletableFuturefailedFuture(Throwable ex)</code></pre><p>最后，为了解决超时问题，Java 9又引入了两个新功能：</p>\n<pre><code>* orTimeout()\n* completeOnTimeout()</code></pre><h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>在本文中，我们描述了CompletableFuture类的方法和典型用例。</p>\n","text":"本文转载自 https://juejin.im/post/5ca47aa0e51d457131257269 简介作为Java 8 Concurrency API改进而引入，本文是CompletableFuture类的功能和用例的介绍。同时在Java 9 也有对Completabl","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]},{"title":"Java 中的 Wait 和 Notify 机制","slug":"Java中的Wait和Notify机制","date":"2019-05-11T15:10:27.027Z","updated":"2019-05-30T00:52:25.406Z","comments":true,"pin":null,"path":"api/articles/Java中的Wait和Notify机制.json","excerpt":"","keywords":null,"cover":"https://user-gold-cdn.xitu.io/2019/5/11/16aa5da0e43cb932?imageView2/0/w/1280/h/960/ignore-error/1","content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5cd67d31e51d453b5854b8a8\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5cd67d31e51d453b5854b8a8</a> </p>\n</blockquote>\n<h3 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h3><p><code>Wait</code> 和 <code>Notify</code> 是 <code>Java</code> 面试中常见的问题，但是在平时工作中可能不常见到。大家或多或少知道些背景知识，例如二者均为 <code>Object</code> 类的方法，而不是 <code>Thread</code> 特有的（因为<code>锁</code>是每个对象都具有的特性，因此操作锁的方法也紧跟对象，没毛病），且都只能在<code>同步代码块</code>中调用（即前提是先获得对象的<code>监视器锁</code>，一般来说在 <code>synchronized</code> 代码块中使用），否则抛出异常 <code>IllegalMonitorStateException</code>。</p>\n<p><code>Wait</code> 会挂起自己让出 <code>CPU</code> 时间片，并将自身加入锁定对象的 <code>Wait Set</code> 中，释放对象的监视器锁<code>（monitor）</code>让其他线程可以获得，直到其他线程调用此对象的 <code>notify( )</code> 方法或 <code>notifyAll( )</code> 方法，自身才能被唤醒（这里有个特殊情况就是 <code>Wait</code> 可以增加等待时间）；<code>Notify</code> 方法则会释放监视器锁的同时，唤醒对象 <code>Wait Set</code> 中等待的线程，顺序是随机的不确定。</p>\n<h3 id=\"Wait-Set\"><a href=\"#Wait-Set\" class=\"headerlink\" title=\"Wait Set\"></a>Wait Set</h3><p><code>虚拟机规范</code>中定义了一个 <code>Wait Set</code> 的概念，但至于其具体是什么样的数据结构规范没有强制规定，<strong>意味着不同的厂商可以自行实现</strong>，但不管怎样，线程调用了某个对象的 <code>Wait</code> 方法，就会被加入该对象的 <code>Wait Set</code> 中</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/11/16aa5da0e43cb932?imageView2/0/w/1280/h/960/ignore-error/1\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"Demo-代码\"><a href=\"#Demo-代码\" class=\"headerlink\" title=\"Demo 代码\"></a>Demo 代码</h3><p>下面通过一段 <code>demo</code> 来解释 <code>Wait</code> 和 <code>Notify</code> 的功能</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\">public class WaitNotify &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        final Object A = new Object();</span><br><span class=\"line\">        final Object B = new Object();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread t1 = new Thread(&quot;t1-thread&quot;) &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                synchronized (A) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + &quot;拿到 A 的监视器锁&quot;);</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + &quot;尝试获取 B 的监视器锁&quot;);</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        System.out.println(Thread.currentThread().getName() + &quot;休眠 2s，不释放 A 的监视器锁&quot;);</span><br><span class=\"line\">                        TimeUnit.SECONDS.sleep(2);</span><br><span class=\"line\">                        System.out.println(Thread.currentThread().getName() + &quot;挂起自己，释放 A 的监视器锁&quot;);</span><br><span class=\"line\">                        A.wait();</span><br><span class=\"line\">                        System.out.println(Thread.currentThread().getName() + &quot;被唤醒，等待获取 B 的监视器锁&quot;);</span><br><span class=\"line\">                    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    synchronized (B) &#123;</span><br><span class=\"line\">                        System.out.println(Thread.currentThread().getName() + &quot;拿到 B 的监视器锁&quot;);</span><br><span class=\"line\">                        B.notify();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread t2 = new Thread(&quot;t2-thread&quot;) &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                synchronized (B) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + &quot;拿到 B 的监视器锁&quot;);</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + &quot;尝试获取 A 的监视器锁&quot;);</span><br><span class=\"line\">                    synchronized (A) &#123;</span><br><span class=\"line\">                        System.out.println(Thread.currentThread().getName() + &quot;拿到 A 的监视器锁&quot;);</span><br><span class=\"line\">                        try &#123;</span><br><span class=\"line\">                            System.out.println(Thread.currentThread().getName() + &quot;休眠 2s，不释放 A 的监视器锁&quot;);</span><br><span class=\"line\">                            TimeUnit.SECONDS.sleep(2);</span><br><span class=\"line\">                        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        System.out.println(Thread.currentThread().getName() + &quot;挂起自己，释放 A 的监视器锁，唤醒 t0&quot;);</span><br><span class=\"line\">                        A.notify();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        System.out.println(Thread.currentThread().getName() + &quot;休眠 2s，不释放 B 的监视器锁&quot;);</span><br><span class=\"line\">                        TimeUnit.SECONDS.sleep(2);</span><br><span class=\"line\">                        System.out.println(Thread.currentThread().getName() + &quot;挂起自己，释放 B 的监视器锁&quot;);</span><br><span class=\"line\">                        B.wait();</span><br><span class=\"line\">                        System.out.println(Thread.currentThread().getName() + &quot;被唤醒&quot;);</span><br><span class=\"line\">                    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"输出结果\"><a href=\"#输出结果\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t1-thread拿到 A 的监视器锁</span><br><span class=\"line\">t2-thread拿到 B 的监视器锁</span><br><span class=\"line\">t1-thread尝试获取 B 的监视器锁</span><br><span class=\"line\">t2-thread尝试获取 A 的监视器锁</span><br><span class=\"line\">t1-thread休眠 2s，不释放 A 的监视器锁</span><br><span class=\"line\">t1-thread挂起自己，释放 A 的监视器锁</span><br><span class=\"line\">t2-thread拿到 A 的监视器锁</span><br><span class=\"line\">t2-thread休眠 2s，不释放 A 的监视器锁</span><br><span class=\"line\">t2-thread挂起自己，释放 A 的监视器锁，唤醒 t0</span><br><span class=\"line\">t2-thread休眠 2s，不释放 B 的监视器锁</span><br><span class=\"line\">t1-thread被唤醒，等待获取 B 的监视器锁</span><br><span class=\"line\">t2-thread挂起自己，释放 B 的监视器锁</span><br><span class=\"line\">t1-thread拿到 B 的监视器锁</span><br><span class=\"line\">t2-thread被唤醒</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h3><p><img src=\"https://user-gold-cdn.xitu.io/2019/5/11/16aa5da0e439ccdb?imageView2/0/w/1280/h/960/ignore-error/1\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>这是一个不定时更新的、披着程序员外衣的文青小号，欢迎关注。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/2/16a78675262bc604?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n","text":"本文转载自 https://juejin.im/post/5cd67d31e51d453b5854b8a8 写在前面Wait 和 Notify 是 Java 面试中常见的问题，但是在平时工作中可能不常见到。大家或多或少知道些背景知识，例如二者均为 Object 类的方法，而不是 ","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]},{"title":"Java的12个语法糖","slug":"Java的12个语法糖","date":"2019-05-16T07:40:26.026Z","updated":"2019-05-30T00:52:25.409Z","comments":true,"pin":null,"path":"api/articles/Java的12个语法糖.json","excerpt":"","keywords":null,"cover":"https://user-gold-cdn.xitu.io/2019/5/13/16aaec8209852aa9?imageView2/0/w/1280/h/960/ignore-error/1","content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5cd8c5e6f265da03555c9d79\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5cd8c5e6f265da03555c9d79</a> </p>\n</blockquote>\n<p>GitHub 2.5k Star 的<a href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fhollischuang%2FtoBeTopJavaer\" target=\"_blank\" rel=\"noopener\">Java工程师成神之路</a> ，不来了解一下吗?</p>\n<p>GitHub 2.5k Star 的<a href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fhollischuang%2FtoBeTopJavaer\" target=\"_blank\" rel=\"noopener\">Java工程师成神之路</a> ，真的不来了解一下吗?</p>\n<p>GitHub 2.5k Star 的<a href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fhollischuang%2FtoBeTopJavaer\" target=\"_blank\" rel=\"noopener\">Java工程师成神之路</a> ，真的确定不来了解一下吗?</p>\n<p>本文从 Java 编译原理角度，深入字节码及 class 文件，抽丝剥茧，了解 Java 中的语法糖原理及用法，帮助大家在学会如何使用 Java。</p>\n<h3 id=\"语法糖\"><a href=\"#语法糖\" class=\"headerlink\" title=\"语法糖\"></a>语法糖</h3><p>语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。<br>有意思的是，在编程领域，除了语法糖，还有语法盐和语法糖精的说法，篇幅有限这里不做扩展了。</p>\n<p>我们所熟知的编程语言中几乎都有语法糖。作者认为，语法糖的多少是评判一个语言够不够牛逼的标准之一。很多人说Java是一个“低糖语言”，其实从Java 7开始Java语言层面上一直在添加各种糖，主要是在“Project Coin”项目下研发。尽管现在Java有人还是认为现在的Java是低糖，未来还会持续向着“高糖”的方向发展。</p>\n<h3 id=\"解语法糖\"><a href=\"#解语法糖\" class=\"headerlink\" title=\"解语法糖\"></a>解语法糖</h3><p>前面提到过，语法糖的存在主要是方便开发人员使用。但其实，Java虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。</p>\n<p>说到编译，大家肯定都知道，Java语言中，<code>javac</code>命令可以将后缀名为<code>.java</code>的源文件编译为后缀名为<code>.class</code>的可以运行于Java虚拟机的字节码。如果你去看<code>com.sun.tools.javac.main.JavaCompiler</code>的源码，你会发现在<code>compile()</code>中有一个步骤就是调用<code>desugar()</code>，这个方法就是负责解语法糖的实现的。</p>\n<p>Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。本文主要来分析下这些语法糖背后的原理。一步一步剥去糖衣，看看其本质。</p>\n<h3 id=\"糖块一、-switch-支持-String-与枚举\"><a href=\"#糖块一、-switch-支持-String-与枚举\" class=\"headerlink\" title=\"糖块一、 switch 支持 String 与枚举\"></a>糖块一、 switch 支持 String 与枚举</h3><p>前面提到过，从Java 7 开始，Java语言中的语法糖在逐渐丰富，其中一个比较重要的就是Java 7中<code>switch</code>开始支持<code>String</code>。</p>\n<p>在开始coding之前先科普下，Java中的<code>swith</code>自身原本就支持基本类型。比如<code>int</code>、<code>char</code>等。对于<code>int</code>类型，直接进行数值的比较。对于<code>char</code>类型则是比较其ascii码。所以，对于编译器来说，<code>switch</code>中其实只能使用整型，任何类型的比较都要转换成整型。比如<code>byte</code>。<code>short</code>，<code>char</code>(ackii码是整型)以及<code>int</code>。</p>\n<p>那么接下来看下<code>switch</code>对<code>String</code>得支持，有以下代码：<br><code>public class switchDemoString {\n    public static void main(String[] args) {\n        String str = &quot;world&quot;;\n        switch (str) {\n        case &quot;hello&quot;:\n            System.out.println(&quot;hello&quot;);\n            break;\n        case &quot;world&quot;:\n            System.out.println(&quot;world&quot;);\n            break;\n        default:\n            break;\n        }\n    }\n}</code></p>\n<p><a href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F58\" target=\"_blank\" rel=\"noopener\">反编译</a>后内容如下：</p>\n<p><code>public class switchDemoString\n{\n    public switchDemoString()\n    {\n    }\n    public static void main(String args[])\n    {\n        String str = &quot;world&quot;;\n        String s;\n        switch((s = str).hashCode())\n        {\n        default:\n            break;\n        case 99162322:\n            if(s.equals(&quot;hello&quot;))\n                System.out.println(&quot;hello&quot;);\n            break;\n        case 113318802:\n            if(s.equals(&quot;world&quot;))\n                System.out.println(&quot;world&quot;);\n            break;\n        }\n    }\n}</code></p>\n<p>看到这个代码，你知道原来/<em>/</em>字符串的switch是通过<code>equals()</code>和<code>hashCode()</code>方法来实现的。/<em>/</em>还好<code>hashCode()</code>方法返回的是<code>int</code>，而不是<code>long</code>。</p>\n<p>仔细看下可以发现，进行<code>switch</code>的实际是哈希值，然后通过使用<code>equals</code>方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行switch或者使用纯整数常量，但这也不是很差。</p>\n<h3 id=\"糖块二、-泛型\"><a href=\"#糖块二、-泛型\" class=\"headerlink\" title=\"糖块二、 泛型\"></a>糖块二、 泛型</h3><p>我们都知道，很多语言都是支持泛型的，但是很多人不知道的是，不同的编译器对于泛型的处理方式是不同的，通常情况下，一个编译器处理泛型有两种方式：<code>Code specialization</code>和<code>Code sharing</code>。C++和C/#是使用<code>Code specialization</code>的处理机制，而Java使用的是<code>Code sharing</code>的机制。<br>Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（<code>type erasue</code>）实现的。</p>\n<p>也就是说，<strong>对于Java虚拟机来说，他根本不认识<code>Map&lt;String, String&gt; map</code>这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。</strong></p>\n<p>类型擦除的主要过程如下： 1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。 2.移除所有的类型参数。</p>\n<p>以下代码：<br><code>Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();  \nmap.put(&quot;name&quot;, &quot;hollis&quot;);  \nmap.put(&quot;wechat&quot;, &quot;Hollis&quot;);  \nmap.put(&quot;blog&quot;, &quot;www.hollischuang.com&quot;);</code></p>\n<p>解语法糖之后会变成：</p>\n<p><code>Map map = new HashMap();  \nmap.put(&quot;name&quot;, &quot;hollis&quot;);  \nmap.put(&quot;wechat&quot;, &quot;Hollis&quot;);  \nmap.put(&quot;blog&quot;, &quot;www.hollischuang.com&quot;);</code></p>\n<p>以下代码：</p>\n<p><code>public static &lt;A extends Comparable&lt;A&gt;&gt; A max(Collection&lt;A&gt; xs) {\n    Iterator&lt;A&gt; xi = xs.iterator();\n    A w = xi.next();\n    while (xi.hasNext()) {\n        A x = xi.next();\n        if (w.compareTo(x) &lt; 0)\n            w = x;\n    }\n    return w;\n}</code></p>\n<p>类型擦除后会变成：</p>\n<p><code>public static Comparable max(Collection xs){\n    Iterator xi = xs.iterator();\n    Comparable w = (Comparable)xi.next();\n    while(xi.hasNext())\n    {\n        Comparable x = (Comparable)xi.next();\n        if(w.compareTo(x) &lt; 0)\n            w = x;\n    }\n    return w;\n}</code></p>\n<p><strong>虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的<code>Class</code>类对象。比如并不存在<code>List&lt;String&gt;.class</code>或是<code>List&lt;Integer&gt;.class</code>，而只有<code>List.class</code>。</strong></p>\n<h3 id=\"糖块三、-自动装箱与拆箱\"><a href=\"#糖块三、-自动装箱与拆箱\" class=\"headerlink\" title=\"糖块三、 自动装箱与拆箱\"></a>糖块三、 自动装箱与拆箱</h3><p>自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。原始类型byte, short, char, int, long, float, double 和 boolean 对应的封装类为Byte, Short, Character, Integer, Long, Float, Double, Boolean。</p>\n<p>先来看个自动装箱的代码：<br><code>public static void main(String[] args) {\n    int i = 10;\n    Integer n = i;\n}</code></p>\n<p>反编译后代码如下:</p>\n<p><code>public static void main(String args[])\n{\n    int i = 10;\n    Integer n = Integer.valueOf(i);\n}</code></p>\n<p>再来看个自动拆箱的代码：</p>\n<p>`public static void main(String[] args) {</p>\n<pre><code>Integer i = 10;\nint n = i;</code></pre><p>}`</p>\n<p>反编译后代码如下：</p>\n<p><code>public static void main(String args[])\n{\n    Integer i = Integer.valueOf(10);\n    int n = i.intValue();\n}</code></p>\n<p>从反编译得到内容可以看出，在装箱的时候自动调用的是<code>Integer</code>的<code>valueOf(int)</code>方法。而在拆箱的时候自动调用的是<code>Integer</code>的<code>intValue</code>方法。</p>\n<p>所以，<strong>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。</strong></p>\n<h3 id=\"糖块四-、-方法变长参数\"><a href=\"#糖块四-、-方法变长参数\" class=\"headerlink\" title=\"糖块四 、 方法变长参数\"></a>糖块四 、 方法变长参数</h3><p>可变参数(<code>variable arguments</code>)是在Java 1.5中引入的一个特性。它允许一个方法把任意数量的值作为参数。</p>\n<p>看下以下可变参数代码，其中print方法接收可变参数：<br>`public static void main(String[] args)<br>    {<br>        print(“Holis”, “公众号:Hollis”, “博客：<a href=\"http://www.hollischuang.com&quot;\" target=\"_blank\" rel=\"noopener\">www.hollischuang.com&quot;</a>, “QQ：907607222”);<br>    }</p>\n<p>public static void print(String… strs)<br>{\n    for (int i = 0; i &lt; strs.length; i++)<br>    {<br>        System.out.println(strs[i]);<br>    }<br>}`</p>\n<p>反编译后代码：</p>\n<p>`public static void main(String args[])<br>{\n    print(new String[] {<br>        “Holis”, “\\u516C\\u4F17\\u53F7:Hollis”, “\\u535A\\u5BA2\\uFF1A<a href=\"http://www.hollischuang.com&quot;\" target=\"_blank\" rel=\"noopener\">www.hollischuang.com&quot;</a>, “QQ\\uFF1A907607222”<br>    });<br>}</p>\n<p>public static transient void print(String strs[])<br>{\n    for(int i = 0; i &lt; strs.length; i++)<br>        System.out.println(strs[i]);</p>\n<p>}`</p>\n<p>从反编译后代码可以看出，可变参数在被使用的时候，他首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数，然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。</p>\n<p>PS：反编译后的print方法声明中有一个transient标识，是不是很奇怪？transient不是不可以修饰方法吗？transient不是和序列化有关么？transient在这里的作用是什么？因为这个与本文关系不大，这里不做深入分析了。相了解的同学可以关注我微信公众号或者博客。</p>\n<h3 id=\"糖块五-、-枚举\"><a href=\"#糖块五-、-枚举\" class=\"headerlink\" title=\"糖块五 、 枚举\"></a>糖块五 、 枚举</h3><p>Java SE5提供了一种新的类型-Java的枚举类型，关键字<code>enum</code>可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。</p>\n<p>要想看源码，首先得有一个类吧，那么枚举类型到底是什么类呢？是<code>enum</code>吗？答案很明显不是，<code>enum</code>就和<code>class</code>一样，只是一个关键字，他并不是一个类，那么枚举是由什么类维护的呢，我们简单的写一个枚举：<br><code>public enum t {\n    SPRING,SUMMER;\n}</code></p>\n<p>然后我们使用反编译，看看这段代码到底是怎么实现的，反编译后代码内容如下：</p>\n<p>`public final class T extends Enum<br>{\n    private T(String s, int i)<br>    {<br>        super(s, i);<br>    }<br>    public static T[] values()<br>    {<br>        T at[];<br>        int i;<br>        T at1[];<br>        System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i);<br>        return at1;<br>    }</p>\n<pre><code>public static T valueOf(String s)\n{\n    return (T)Enum.valueOf(demo/T, s);\n}\n\npublic static final T SPRING;\npublic static final T SUMMER;\nprivate static final T ENUM$VALUES[];\nstatic\n{\n    SPRING = new T(&quot;SPRING&quot;, 0);\n    SUMMER = new T(&quot;SUMMER&quot;, 1);\n    ENUM$VALUES = (new T[] {\n        SPRING, SUMMER\n    });\n}</code></pre><p>}`</p>\n<p>通过反编译后代码我们可以看到，<code>public final class T extends Enum</code>，说明，该类是继承了<code>Enum</code>类的，同时<code>final</code>关键字告诉我们，这个类也是不能被继承的。<strong>当我们使用<code>enmu</code>来定义一个枚举类型的时候，编译器会自动帮我们创建一个<code>final</code>类型的类继承<code>Enum</code>类，所以枚举类型不能被继承。</strong></p>\n<h3 id=\"糖块六-、-内部类\"><a href=\"#糖块六-、-内部类\" class=\"headerlink\" title=\"糖块六 、 内部类\"></a>糖块六 、 内部类</h3><p>内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。</p>\n<p><strong>内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念，<code>outer.java</code>里面定义了一个内部类<code>inner</code>，一旦编译成功，就会生成两个完全不同的<code>.class</code>文件了，分别是<code>outer.class</code>和<code>outer$inner.class</code>。所以内部类的名字完全可以和它的外部类名字相同。</strong><br>`public class OutterClass {<br>    private String userName;</p>\n<pre><code>public String getUserName() {\n    return userName;\n}\n\npublic void setUserName(String userName) {\n    this.userName = userName;\n}\n\npublic static void main(String[] args) {\n\n}\n\nclass InnerClass{\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}</code></pre><p>}`</p>\n<p>以上代码编译后会生成两个class文件：<code>OutterClass$InnerClass.class</code> 、<code>OutterClass.class</code> 。当我们尝试对<code>OutterClass.class</code>文件进行反编译的时候，命令行会打印以下内容：<code>Parsing OutterClass.class...Parsing inner class OutterClass$InnerClass.class... Generating OutterClass.jad</code> 。他会把两个文件全部进行反编译，然后一起生成一个<code>OutterClass.jad</code>文件。文件内容如下：</p>\n<p>`public class OutterClass<br>{\n    class InnerClass<br>    {<br>        public String getName()<br>        {<br>            return name;<br>        }<br>        public void setName(String name)<br>        {<br>            this.name = name;<br>        }<br>        private String name;<br>        final OutterClass this$0;</p>\n<pre><code>    InnerClass()\n    {\n        this.this$0 = OutterClass.this;\n        super();\n    }\n}\n\npublic OutterClass()\n{\n}\npublic String getUserName()\n{\n    return userName;\n}\npublic void setUserName(String userName){\n    this.userName = userName;\n}\npublic static void main(String args1[])\n{\n}\nprivate String userName;</code></pre><p>}`</p>\n<h3 id=\"糖块七-、条件编译\"><a href=\"#糖块七-、条件编译\" class=\"headerlink\" title=\"糖块七 、条件编译\"></a>糖块七 、条件编译</h3><p>—般情况下，程序中的每一行代码都要参加编译。但有时候出于对程序代码优化的考虑，希望只对其中一部分内容进行编译，此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。</p>\n<p>如在C或CPP中，可以通过预处理语句来实现条件编译。其实在Java中也可实现条件编译。我们先来看一段代码：<br>`public class ConditionalCompilation {<br>    public static void main(String[] args) {<br>        final boolean DEBUG = true;<br>        if(DEBUG) {<br>            System.out.println(“Hello, DEBUG!”);<br>        }</p>\n<pre><code>    final boolean ONLINE = false;\n\n    if(ONLINE){\n        System.out.println(&quot;Hello, ONLINE!&quot;);\n    }\n}</code></pre><p>}`</p>\n<p>反编译后代码如下：</p>\n<p>`public class ConditionalCompilation<br>{</p>\n<pre><code>public ConditionalCompilation()\n{\n}\n\npublic static void main(String args[])\n{\n    boolean DEBUG = true;\n    System.out.println(&quot;Hello, DEBUG!&quot;);\n    boolean ONLINE = false;\n}</code></pre><p>}`</p>\n<p>首先，我们发现，在反编译后的代码中没有<code>System.out.println(&quot;Hello, ONLINE!&quot;);</code>，这其实就是条件编译。当<code>if(ONLINE)</code>为false的时候，编译器就没有对其内的代码进行编译。</p>\n<p>所以，<strong>Java语法的条件编译，是通过判断条件为常量的if语句实现的。其原理也是Java语言的语法糖。根据if判断条件的真假，编译器直接把分支为false的代码块消除。通过该方式实现的条件编译，必须在方法体内实现，而无法在正整个Java类的结构或者类的属性上进行条件编译，这与C/C++的条件编译相比，确实更有局限性。在Java语言设计之初并没有引入条件编译的功能，虽有局限，但是总比没有更强。</strong></p>\n<h3 id=\"糖块八-、-断言\"><a href=\"#糖块八-、-断言\" class=\"headerlink\" title=\"糖块八 、 断言\"></a>糖块八 、 断言</h3><p>在Java中，<code>assert</code>关键字是从JAVA SE 1.4 引入的，为了避免和老版本的Java代码中使用了<code>assert</code>关键字导致错误，Java在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！），如果要开启断言检查，则需要用开关<code>-enableassertions</code>或<code>-ea</code>来开启。</p>\n<p>看一段包含断言的代码：<br><code>public class AssertTest {\n    public static void main(String args[]) {\n        int a = 1;\n        int b = 1;\n        assert a == b;\n        System.out.println(&quot;公众号：Hollis&quot;);\n        assert a != b : &quot;Hollis&quot;;\n        System.out.println(&quot;博客：www.hollischuang.com&quot;);\n    }\n}</code></p>\n<p>反编译后代码如下：</p>\n<p>`public class AssertTest {<br>   public AssertTest()<br>    {<br>    }<br>    public static void main(String args[])<br>{\n    int a = 1;<br>    int b = 1;<br>    if(!$assertionsDisabled &amp;&amp; a != b)<br>        throw new AssertionError();<br>    System.out.println(“\\u516C\\u4F17\\u53F7\\uFF1AHollis”);<br>    if(!$assertionsDisabled &amp;&amp; a == b)<br>    {<br>        throw new AssertionError(“Hollis”);<br>    } else<br>    {<br>        System.out.println(“\\u535A\\u5BA2\\uFF1A<a href=\"http://www.hollischuang.com&quot;\" target=\"_blank\" rel=\"noopener\">www.hollischuang.com&quot;</a>);<br>        return;<br>    }<br>}</p>\n<p>static final boolean $assertionsDisabled = !com/hollis/suguar/AssertTest.desiredAssertionStatus();</p>\n<p>}`</p>\n<p>很明显，反编译之后的代码要比我们自己的代码复杂的多。所以，使用了assert这个语法糖我们节省了很多代码。<strong>其实断言的底层实现就是if语言，如果断言结果为true，则什么都不做，程序继续执行，如果断言结果为false，则程序抛出AssertError来打断程序的执行。</strong><code>-enableassertions</code>会设置$assertionsDisabled字段的值。</p>\n<h3 id=\"糖块九-、-数值字面量\"><a href=\"#糖块九-、-数值字面量\" class=\"headerlink\" title=\"糖块九 、 数值字面量\"></a>糖块九 、 数值字面量</h3><p>在java 7中，数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。这些下划线不会对字面量的数值产生影响，目的就是方便阅读。</p>\n<p>比如：<br><code>public class Test {\n    public static void main(String... args) {\n        int i = 10_000;\n        System.out.println(i);\n    }\n}</code></p>\n<p>反编译后：</p>\n<p><code>public class Test\n{\n  public static void main(String[] args)\n  {\n    int i = 10000;\n    System.out.println(i);\n  }\n}</code></p>\n<p>反编译后就是把<code>_</code>删除了。也就是说 <strong>编译器并不认识在数字字面量中的<code>_</code>，需要在编译阶段把他去掉。</strong></p>\n<h3 id=\"糖块十-、-for-each\"><a href=\"#糖块十-、-for-each\" class=\"headerlink\" title=\"糖块十 、 for-each\"></a>糖块十 、 for-each</h3><p>增强for循环（<code>for-each</code>）相信大家都不陌生，日常开发经常会用到的，他会比for循环要少写很多代码，那么这个语法糖背后是如何实现的呢？<br><code>public static void main(String... args) {\n    String[] strs = {&quot;Hollis&quot;, &quot;公众号：Hollis&quot;, &quot;博客：www.hollischuang.com&quot;};\n    for (String s : strs) {\n        System.out.println(s);\n    }\n    List&lt;String&gt; strList = ImmutableList.of(&quot;Hollis&quot;, &quot;公众号：Hollis&quot;, &quot;博客：www.hollischuang.com&quot;);\n    for (String s : strList) {\n        System.out.println(s);\n    }\n}</code></p>\n<p>反编译后代码如下：</p>\n<p>`public static transient void main(String args[])<br>{\n    String strs[] = {<br>        “Hollis”, “\\u516C\\u4F17\\u53F7\\uFF1AHollis”, “\\u535A\\u5BA2\\uFF1A<a href=\"http://www.hollischuang.com&quot;\" target=\"_blank\" rel=\"noopener\">www.hollischuang.com&quot;</a><br>    };<br>    String args1[] = strs;<br>    int i = args1.length;<br>    for(int j = 0; j &lt; i; j++)<br>    {<br>        String s = args1[j];<br>        System.out.println(s);<br>    }</p>\n<pre><code>List strList = ImmutableList.of(&quot;Hollis&quot;, &quot;\\u516C\\u4F17\\u53F7\\uFF1AHollis&quot;, &quot;\\u535A\\u5BA2\\uFF1Awww.hollischuang.com&quot;);\nString s;\nfor(Iterator iterator = strList.iterator(); iterator.hasNext(); System.out.println(s))\n    s = (String)iterator.next();</code></pre><p>}`</p>\n<p>代码很简单，<strong>for-each的实现原理其实就是使用了普通的for循环和迭代器。</strong></p>\n<h3 id=\"糖块十一-、-try-with-resource\"><a href=\"#糖块十一-、-try-with-resource\" class=\"headerlink\" title=\"糖块十一 、 try-with-resource\"></a>糖块十一 、 try-with-resource</h3><p>Java里，对于文件操作IO流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过close方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄露等问题。</p>\n<p>关闭资源的常用方式就是在<code>finally</code>块里是释放，即调用<code>close</code>方法。比如，我们经常会写这样的代码：<br><code>public static void main(String[] args) {\n    BufferedReader br = null;\n    try {\n        String line;\n        br = new BufferedReader(new FileReader(&quot;d:\\\\hollischuang.xml&quot;));\n        while ((line = br.readLine()) != null) {\n            System.out.println(line);\n        }\n    } catch (IOException e) {\n        // handle exception\n    } finally {\n        try {\n            if (br != null) {\n                br.close();\n            }\n        } catch (IOException ex) {\n            // handle exception\n        }\n    }\n}</code></p>\n<p>从Java 7开始，jdk提供了一种更好的方式关闭资源，使用<code>try-with-resources</code>语句，改写一下上面的代码，效果如下：</p>\n<p><code>public static void main(String... args) {\n    try (BufferedReader br = new BufferedReader(new FileReader(&quot;d:\\\\ hollischuang.xml&quot;))) {\n        String line;\n        while ((line = br.readLine()) != null) {\n            System.out.println(line);\n        }\n    } catch (IOException e) {\n        // handle exception\n    }\n}</code></p>\n<p>看，这简直是一大福音啊，虽然我之前一般使用<code>IOUtils</code>去关闭流，并不会使用在<code>finally</code>中写很多代码的方式，但是这种新的语法糖看上去好像优雅很多呢。看下他的背后：</p>\n<p><code>public static transient void main(String args[])\n    {\n        BufferedReader br;\n        Throwable throwable;\n        br = new BufferedReader(new FileReader(&quot;d:\\\\ hollischuang.xml&quot;));\n        throwable = null;\n        String line;\n        try\n        {\n            while((line = br.readLine()) != null)\n                System.out.println(line);\n        }\n        catch(Throwable throwable2)\n        {\n            throwable = throwable2;\n            throw throwable2;\n        }\n        if(br != null)\n            if(throwable != null)\n                try\n                {\n                    br.close();\n                }\n                catch(Throwable throwable1)\n                {\n                    throwable.addSuppressed(throwable1);\n                }\n            else\n                br.close();\n            break MISSING_BLOCK_LABEL_113;\n            Exception exception;\n            exception;\n            if(br != null)\n                if(throwable != null)\n                    try\n                    {\n                        br.close();\n                    }\n                    catch(Throwable throwable3)\n                      {\n                        throwable.addSuppressed(throwable3);\n                    }\n                else\n                    br.close();\n        throw exception;\n        IOException ioexception;\n        ioexception;\n    }\n}</code></p>\n<p><strong>其实背后的原理也很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。所以，再次印证了，语法糖的作用就是方便程序员的使用，但最终还是要转成编译器认识的语言。</strong></p>\n<h3 id=\"糖块十二、Lambda表达式\"><a href=\"#糖块十二、Lambda表达式\" class=\"headerlink\" title=\"糖块十二、Lambda表达式\"></a>糖块十二、Lambda表达式</h3><p>关于lambda表达式，有人可能会有质疑，因为网上有人说他并不是语法糖。其实我想纠正下这个说法。<strong>Labmda表达式不是匿名内部类的语法糖，但是他也是一个语法糖。实现方式其实是依赖了几个JVM底层提供的lambda相关api。</strong></p>\n<p>先来看一个简单的lambda表达式。遍历一个list：<br>`public static void main(String… args) {<br>    List<string> strList = ImmutableList.of(“Hollis”, “公众号：Hollis”, “博客：<a href=\"http://www.hollischuang.com&quot;\" target=\"_blank\" rel=\"noopener\">www.hollischuang.com&quot;</a>);</string></p>\n<pre><code>strList.forEach( s -&gt; { System.out.println(s); } );</code></pre><p>}`</p>\n<p>为啥说他并不是内部类的语法糖呢，前面讲内部类我们说过，内部类在编译之后会有两个class文件，但是，包含lambda表达式的类编译后只有一个文件。</p>\n<p>反编译后代码如下:<br>`public static /* varargs */ void main(String … args) {<br>    ImmutableList strList = ImmutableList.of((Object)”Hollis”, (Object)”\\u516c\\u4f17\\u53f7\\uff1aHollis”, (Object)”\\u535a\\u5ba2\\uff1a<a href=\"http://www.hollischuang.com&quot;\" target=\"_blank\" rel=\"noopener\">www.hollischuang.com&quot;</a>);<br>    strList.forEach((Consumer<string>)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$0(java.lang.String ), (Ljava/lang/String;)V)());<br>}</string></p>\n<p>private static /* synthetic */ void lambda$main$0(String s) {<br>    System.out.println(s);<br>}`</p>\n<p>可以看到，在<code>forEach</code>方法中，其实是调用了<code>java.lang.invoke.LambdaMetafactory#metafactory</code>方法，该方法的第四个参数implMethod指定了方法实现。可以看到这里其实是调用了一个<code>lambda$main$0</code>方法进行了输出。</p>\n<p>再来看一个稍微复杂一点的，先对List进行过滤，然后再输出：<br>`public static void main(String… args) {<br>    List<string> strList = ImmutableList.of(“Hollis”, “公众号：Hollis”, “博客：<a href=\"http://www.hollischuang.com&quot;\" target=\"_blank\" rel=\"noopener\">www.hollischuang.com&quot;</a>);</string></p>\n<pre><code>List HollisList = strList.stream().filter(string -&gt; string.contains(&quot;Hollis&quot;)).collect(Collectors.toList());\n\nHollisList.forEach( s -&gt; { System.out.println(s); } );</code></pre><p>}`</p>\n<p>反编译后代码如下：</p>\n<p>`public static /* varargs */ void main(String … args) {<br>    ImmutableList strList = ImmutableList.of((Object)”Hollis”, (Object)”\\u516c\\u4f17\\u53f7\\uff1aHollis”, (Object)”\\u535a\\u5ba2\\uff1a<a href=\"http://www.hollischuang.com&quot;\" target=\"_blank\" rel=\"noopener\">www.hollischuang.com&quot;</a>);<br>    List<object> HollisList = strList.stream().filter((Predicate<string>)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)Z, lambda$main$0(java.lang.String ), (Ljava/lang/String;)Z)()).collect(Collectors.toList());<br>    HollisList.forEach((Consumer<object>)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$1(java.lang.Object ), (Ljava/lang/Object;)V)());<br>}</object></string></object></p>\n<p>private static /* synthetic */ void lambda$main$1(Object s) {<br>    System.out.println(s);<br>}</p>\n<p>private static /* synthetic */ boolean lambda$main$0(String string) {<br>    return string.contains(“Hollis”);<br>}`</p>\n<p>两个lambda表达式分别调用了<code>lambda$main$1</code>和<code>lambda$main$0</code>两个方法。</p>\n<p><strong>所以，lambda表达式的实现其实是依赖了一些底层的api，在编译阶段，编译器会把lambda表达式进行解糖，转换成调用内部api的方式。</strong></p>\n<h3 id=\"可能遇到的坑\"><a href=\"#可能遇到的坑\" class=\"headerlink\" title=\"可能遇到的坑\"></a>可能遇到的坑</h3><h3 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h3><p><strong>一、当泛型遇到重载</strong> public class GenericTypes {<br>`public static void method(List<string> list) {<br>        System.out.println(“invoke method(List<string> list)”);<br>    }  </string></string></p>\n<pre><code>public static void method(List&lt;Integer&gt; list) {  \n    System.out.println(&quot;invoke method(List&lt;Integer&gt; list)&quot;);  \n}  </code></pre><p>}`</p>\n<p>上面这段代码，有两个重载的函数，因为他们的参数类型不同，一个是List另一个是List ，但是，这段代码是编译通不过的。因为我们前面讲过，参数List和List编译之后都被擦除了，变成了一样的原生类型List，擦除动作导致这两个方法的特征签名变得一模一样。</p>\n<p><strong>二、当泛型遇到catch</strong> 泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型<code>MyException&lt;String&gt;</code>和<code>MyException&lt;Integer&gt;</code>的</p>\n<p><strong>三、当泛型内包含静态变量</strong><br><code>public class StaticTest{\n    public static void main(String[] args){\n        GT&lt;Integer&gt; gti = new GT&lt;Integer&gt;();\n        gti.var=1;\n        GT&lt;String&gt; gts = new GT&lt;String&gt;();\n        gts.var=2;\n        System.out.println(gti.var);\n    }\n}\nclass GT&lt;T&gt;{\n    public static int var=0;\n    public void nothing(T x){}\n}</code></p>\n<p>以上代码输出结果为：2！由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的。</p>\n<h3 id=\"自动装箱与拆箱\"><a href=\"#自动装箱与拆箱\" class=\"headerlink\" title=\"自动装箱与拆箱\"></a>自动装箱与拆箱</h3><p><strong>对象相等比较</strong></p>\n<p>public class BoxingTest {<br><code>public static void main(String[] args) {\n    Integer a = 1000;\n    Integer b = 1000;\n    Integer c = 100;\n    Integer d = 100;\n    System.out.println(&quot;a == b is &quot; + (a == b));\n    System.out.println((&quot;c == d is &quot; + (c == d)));\n}</code></p>\n<p>输出结果：</p>\n<p><code>a == b is false\nc == d is true</code></p>\n<p>在Java 5中，在Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。</p>\n<p>适用于整数值区间-128 至 +127。</p>\n<p>只适用于自动装箱。使用构造函数创建对象不适用。</p>\n<h3 id=\"增强for循环\"><a href=\"#增强for循环\" class=\"headerlink\" title=\"增强for循环\"></a>增强for循环</h3><p><strong>ConcurrentModificationException</strong><br><code>for (Student stu : students) {    \n    if (stu.getId() == 2)     \n        students.remove(stu);    \n}</code></p>\n<p>会抛出<code>ConcurrentModificationException</code>异常。</p>\n<p>Iterator是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出<code>java.util.ConcurrentModificationException</code>异常。</p>\n<p>所以 <code>Iterator</code> 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 <code>Iterator</code> 本身的方法<code>remove()</code>来删除对象，<code>Iterator.remove()</code> 方法会在删除当前迭代对象的同时维护索引的一致性。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>前面介绍了12种Java中常用的语法糖。所谓语法糖就是提供给开发人员便于开发的一种语法而已。但是这种语法只有开发人员认识。要想被执行，需要进行解糖，即转成JVM认识的语法。当我们把语法糖解糖之后，你就会发现其实我们日常使用的这些方便的语法，其实都是一些其他更简单的语法构成的。</p>\n<p>有了这些语法糖，我们在日常开发的时候可以大大提升效率，但是同时也要避免过渡使用。使用之前最好了解下原理，避免掉坑。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/13/16aaec8209852aa9?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p>参考资料： <a href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F58\" target=\"_blank\" rel=\"noopener\">Java的反编译</a> <a href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F61\" target=\"_blank\" rel=\"noopener\">Java中的Switch对整型、字符型、字符串型的具体实现细节</a> <a href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F197\" target=\"_blank\" rel=\"noopener\">深度分析Java的枚举类型—-枚举的线程安全性及序列化问题</a> <a href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F195\" target=\"_blank\" rel=\"noopener\">Java的枚举类型用法介绍</a> <a href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F1776\" target=\"_blank\" rel=\"noopener\">Java中的增强for循环（for each）的实现原理与坑</a> <a href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F230\" target=\"_blank\" rel=\"noopener\">Java中泛型的理解</a> <a href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F1174\" target=\"_blank\" rel=\"noopener\">Java中整型的缓存机制</a> <a href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F1271\" target=\"_blank\" rel=\"noopener\">Java中的可变参数</a></p>\n","text":"本文转载自 https://juejin.im/post/5cd8c5e6f265da03555c9d79 GitHub 2.5k Star 的Java工程师成神之路 ，不来了解一下吗?GitHub 2.5k Star 的Java工程师成神之路 ，真的不来了解一下吗?GitHub","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]},{"title":"PK光明顶？江湖上流传的几大【消息队列】门派，到底有什么本质的区别？","slug":"PK光明顶？江湖上流传的几大【消息队列】门派，到底有什么本质的区别？","date":"2019-05-07T07:02:08.008Z","updated":"2019-05-30T00:52:25.411Z","comments":true,"pin":null,"path":"api/articles/PK光明顶？江湖上流传的几大【消息队列】门派，到底有什么本质的区别？.json","excerpt":"","keywords":null,"cover":"https://user-gold-cdn.xitu.io/2019/5/6/16a8ca53a6eaad0e?imageView2/0/w/1280/h/960/ignore-error/1","content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5ccffb0551882540ab16802b\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ccffb0551882540ab16802b</a><br>公众号：狸猫技术窝</p>\n</blockquote>\n<p>作者：爱钓鱼的桌子哥，阿里巴巴高级技术专家</p>\n<p><strong>目录</strong></p>\n<p>（1）流派1：有Broker的暴力路由</p>\n<p>（2）流派2：有Broker的复杂路由</p>\n<p>（3）流派3：无Broker的通信流派</p>\n<p>（4）总结</p>\n<p>作者：爱钓鱼的桌子哥，资深架构师</p>\n<p>平时经常会看到很多人写文章分析Kafka、RabbitMQ、RocketMQ等各种MQ之间的性能比较，功能比较，但是实际上从MQ消息队列的门派上来说，这些MQ其实是分属不同的门派的。<br>那么这不同的门派之间，到底有什么区别呢？</p>\n<h3 id=\"（1）流派1：有Broker的暴力路由\"><a href=\"#（1）流派1：有Broker的暴力路由\" class=\"headerlink\" title=\"（1）流派1：有Broker的暴力路由\"></a>（1）流派1：有Broker的暴力路由</h3><p>这个流派最典型的就是Kafka了，Kafka实际上为了提升性能，简化了MQ功能模型，仅仅提供了一些最基础的MQ相关的功能，但是大幅度优化和提升了吞吐量。</p>\n<p>首先，这个流派一定是有一个Broker角色的，也就是说，Kafka需要部署一套服务器集群，每台机器上都有一个Kafka Broker进程，这个进程就负责接收请求，存储数据，发送数据。</p>\n<p>Kafka的生产消费模型做的相对是比较暴力简单的，就是简单的数据流模型。</p>\n<p>简单来说，他有一个概念，叫做“<strong>Topic</strong>”，你可以往这个“Topic”里写数据，然后让别人从这里来消费。</p>\n<p>这个Topic可以划分为多个Partition，每个Partition放一台机器上，存储一部分数据。</p>\n<p>在写消息到Topic的时候，会自动把你这个消息给分发到某一个Partition上去。</p>\n<p>然后消费消息的时候，有一个<strong>Consumer Group</strong>的概念，你部署在多台机器上的Consumer可以组成一个Group，一个Partition只能给一个Consumer消费，一个Cosumer可以消费多个Partition，这是最最核心的一点。</p>\n<p>通过这个模型，保证一个Topic里的每条消息，只会交给Consumer Group里的一个Consumer来消费，形成了一个Queue（队列）的效果。</p>\n<p>假如你想要有一个Queue的效果，也就是希望不停的往Queue里写数据，然后多个消费者消费，每条消息就只能给一个消费者，那么通过Kafka来实现，其实就是生产者写多个Partition，每个Partition只能给Consumer Group中的一个Consumer来消费。如下图所示：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/6/16a8ca53a6eaad0e?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p>如果要实现Publish/Subscribe的模型呢？就是说生产者发送的每条消息，都要让所有消费都消费到，怎么实现？</p>\n<p>那就让每个消费者都是一个独立的消费组，这样每条消息都会发送给所有的消费组，每个消费组里那唯一的一个消费者一定会消费到所有的消息。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/6/16a8ca538b2c77fa?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p>但是除此之外，Kafka就没有任何其他的消费功能了，就是如此简单，所以属于一种比较暴力直接的流派。</p>\n<p>它就是简单的消费模型，实现最基础的Queue和Pub/Sub两种消费模型，但是内核中大幅度优化和提升了性能以及吞吐量。</p>\n<p>所以Kafka天生适合的场景，就是大数据领域的实时数据计算的场景。</p>\n<p>因为在大数据的场景下，通常是弱业务的场景，没有太多复杂的业务系统交互，而主要是大量的数据流入Kafka，然后进行实时计算。</p>\n<p>所以就是需要简单的消费模型，但是必须在内核中对吞吐量和性能进行大幅度的优化。</p>\n<p>因此Kafka技术通常是在大数据的实时数据计算领域中使用的，比如说每秒处理几十万条消息，甚至每秒处理上百万条消息。</p>\n<h3 id=\"（2）流派2：有Broker的复杂路由\"><a href=\"#（2）流派2：有Broker的复杂路由\" class=\"headerlink\" title=\"（2）流派2：有Broker的复杂路由\"></a>（2）流派2：有Broker的复杂路由</h3><p>第二个流派，就是<strong>RabbitMQ</strong>为代表的流派，他强调的不是说如何提升性能和吞吐量，关注的是说要提供非常强大、复杂而且完善的消息路由功能。</p>\n<p>所以对于RabbitMQ而言，他就不是那么简单的Topic-Partition的消费模型了。</p>\n<p>在RabbitMQ中引入了一个非常核心的概念，叫做<strong>Exchange</strong>，这个Exchange就是负责根据复杂的业务规则把消息路由到内部的不同的Queue里去。</p>\n<p>举个例子，如果要实现最简单的队列功能，就是让exchange往一个queue里写数据，然后多个消费者来消费这个queue里的数据，每条消息只能给一个消费者，那么可以是类似下面的方式。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/6/16a8ca53a6c4d47c?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p>如果想要实现Pub/Sub的模型，就是一条消息要被所有的消费者给消费到，那么就可以让每个消费者都有一个自己的Queue，然后绑定到一个Exchange上去。</p>\n<p>接着，这个Exchange就设定把消息路由给所有的Queue即可，如下面这样。</p>\n<p>此时Exchange可以把每条消息都路由给所有的Queue，每个Consumer都可以从自己的Queue里拿到所有的消息。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/6/16a8ca53a6b7de77?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p>RabbitMQ这种流派，其实最核心的是，基于Exchange这个概念，他可以做很多复杂的事情。</p>\n<p>比如：如果你想要某个Consumer只能消费到<strong>某一类数据</strong>，那么Exchange可以把消息里比如带“XXX”前缀的消息路由给某个Queue。或者你可以限定某个Consumer就只能消费<strong>某一部分数据</strong>。总之在这里你可以做很多的限制，设置复杂的路由规则。</p>\n<p>但是也正是因为引入了这种复杂的消费模型，支持复杂的路由功能，导致RabbitMQ在内核以及架构设计上没法像Kafka做的那么的轻量级、高性能、可扩展、高吞吐，所以RabbitMQ在吞吐量上要比Kafka低一个数量级。</p>\n<p>所以这种流派的MQ，往往适合用在Java业务系统中，不同的业务系统需要进行复杂的消息路由。</p>\n<p>比如说业务系统A发送了10条消息，其中3条消息是给业务系统B的，7条消息是给业务系统C的，要实现这种复杂的路由模型，就必须依靠RabbitMQ来实现。</p>\n<p>当然，对于这种业务系统之间的消息流转而言，可能不需要那么高的吞吐量，可能每秒业务系统之间也就转发几十条或者几百条消息，那么就完全适合采用RabbitMQ来实现。</p>\n<h3 id=\"（3）流派3：无Broker的通信流派\"><a href=\"#（3）流派3：无Broker的通信流派\" class=\"headerlink\" title=\"（3）流派3：无Broker的通信流派\"></a>（3）流派3：无Broker的通信流派</h3><p>ZeroMQ代表的是第三种MQ。说白了，他是不需要在服务器上部署的，就是一个客户端的库而已。</p>\n<p>也就是说，他主要是封装了底层的Socket网络通讯，然后一个系统要发送一条消息给另外一个消息消费 。</p>\n<p>通过ZeroMQ，本质就是底层ZeroMQ发送一条消息到另外一个系统上去。</p>\n<p>所以ZeroMQ是<strong>去中心化</strong>的，不需要跟Kafka、RabbitMQ一样在服务器上部署的。</p>\n<p>他主要是用来进行业务系统之间的网络通信的，有点类似于比如你是一个分布式系统架构，那么此时分布式架构中的各个子系统互相之间要通信，你是基于Dubbo RPC？还是Spring Cloud HTTP？</p>\n<p>可能上述两种你都不想要，就是要基于原始的Socket进行网络通信，简单的收发消息而已。</p>\n<p>此时就可以使用ZeroMQ作为分布式系统之间的消息通信，如下面那样。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/6/16a8ca53a6d187c4?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<h3 id=\"（4）总结\"><a href=\"#（4）总结\" class=\"headerlink\" title=\"（4）总结\"></a>（4）总结</h3><p>其实现在基本上MQ主要就是这三个流派，很多小众的MQ一般很少有人会用。</p>\n<p>而且用MQ的场景主要就是两大类：</p>\n<pre><code>1. </code></pre><p>业务系统之间异步通信<br>    1.<br>大数据领域的实时数据计算</p>\n<p>所以一般业务系统之间通信就是会采用RabbitMQ/RocketMQ，需要复杂的消息路由功能的支撑。</p>\n<p>大数据的实时计算场景会采用Kafka，需要简单的消费模型，但是超高的吞吐量。</p>\n<p>至于ZeroMQ，一般来说，少数分布式系统中子系统之间的分布式通信时会采用，作为轻量级的异步化的通信组件。</p>\n<p>作者简介：</p>\n<p><strong>爱钓鱼的桌子哥，资深架构师</strong></p>\n<p>作者先后工作于滴滴、百度、字节跳动等国内一线互联网大厂，从事基础架构相关工作。带领团队设计与构建了大规模的分布式存储系统、分布式消息中间件、分布式数据库，对分布式架构设计、系统高可用体系构建、基础中间件架构都有丰富的经验。</p>\n<p><strong>END</strong></p>\n<p>长按下图二维码，即刻关注【狸猫技术窝】 阿里、京东、美团、字节跳动 顶尖技术专家坐镇 为IT人打造一个 “有温度” 的技术窝！</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/23/16a4aea4c6855bb5?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n","text":"本文转载自 https://juejin.im/post/5ccffb0551882540ab16802b<br>公众号：狸猫技术窝作者：爱钓鱼的桌子哥，阿里巴巴高级技术专家目录（1）流派1：有Broker的暴力路由（2）流派2：有Broker的复杂路由（3）流派3：无Broke","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]},{"title":"Token认证，如何快速方便获取用户信息","slug":"Token认证，如何快速方便获取用户信息","date":"2019-05-20T06:31:29.029Z","updated":"2019-05-30T00:52:25.414Z","comments":true,"pin":null,"path":"api/articles/Token认证，如何快速方便获取用户信息.json","excerpt":"","keywords":null,"cover":"https://user-gold-cdn.xitu.io/2019/5/19/16ace69edcd28f75?imageView2/0/w/1280/h/960/ignore-error/1","content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5ce0dfb45188250c942f6c1d\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ce0dfb45188250c942f6c1d</a> </p>\n</blockquote>\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>我们有一个Web项目，这个项目提供了很多的Rest API。也做了权限控制，访问API的请求必须要带上事先认证后获取的Token才可以。</p>\n<p>认证的话就在Filter中进行的，会获取请求的Token进行验证，如果成功了可以得到Token中的用户信息，本文的核心就是讲解如何将用户信息（用户ID）优雅的传递给API接口（Controller）。</p>\n<h1 id=\"方式一（很挫）\"><a href=\"#方式一（很挫）\" class=\"headerlink\" title=\"方式一（很挫）\"></a>方式一（很挫）</h1><p>我们在Filter中进行了统一拦截，在Controller中获取用户ID的话，仍然可以再次解析一遍Token获取用户ID</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@GetMapping(&quot;/hello&quot;)</span><br><span class=\"line\">public String test(HttpServletRequest request) &#123;</span><br><span class=\"line\">    String token = request.getHeader(&quot;token&quot;);</span><br><span class=\"line\">    JWTResult result = JWTUtils.checkToken(token);</span><br><span class=\"line\">    Long userId = result.getUserId();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h1 id=\"方式二（优雅）\"><a href=\"#方式二（优雅）\" class=\"headerlink\" title=\"方式二（优雅）\"></a>方式二（优雅）</h1><p>方式一需要重新解析一遍Token, 浪费资源。我们可以直接将Filter中解析好了的用户ID直接通过Header传递给接口啊。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</span><br><span class=\"line\">\t\t\tthrows IOException, ServletException &#123;</span><br><span class=\"line\">    HttpServletRequest httpRequest = (HttpServletRequest) request;</span><br><span class=\"line\">\tHttpServletResponse httpResponse = (HttpServletResponse) response;</span><br><span class=\"line\">    String token = request.getHeader(&quot;token&quot;);</span><br><span class=\"line\">    JWTResult result = JWTUtils.checkToken(token);</span><br><span class=\"line\">    Long userId = result.getUserId();</span><br><span class=\"line\">\tHttpServletRequestWrapper requestWrapper = new HttpServletRequestWrapper(httpRequest) &#123;</span><br><span class=\"line\">\t\t@Override</span><br><span class=\"line\">\t\tpublic String getHeader(String name) &#123;</span><br><span class=\"line\">\t\t\tif (name.equals(&quot;loginUserId&quot;)) &#123;</span><br><span class=\"line\">\t\t\t\treturn userId .toString();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\treturn super.getHeader(name);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tchain.doFilter(requestWrapper, httpResponse);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>接口中直接从Header中获取解析好了的用户ID:</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@GetMapping(&quot;/hello&quot;)</span><br><span class=\"line\">public String save2(HttpServletRequest request) &#123;</span><br><span class=\"line\">\tLong userId = Long.parseLong(request.getHeader(&quot;loginUserId&quot;));\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h1 id=\"方式三（很优雅）\"><a href=\"#方式三（很优雅）\" class=\"headerlink\" title=\"方式三（很优雅）\"></a>方式三（很优雅）</h1><p>通过Header传递确实很方便，但如果你有代码洁癖的话总会觉得怪怪的，能不能不用Header方式，比如说我就在方法上定义一个loginUserId的参数，你给我直接注入进来，这个有点意思哈，下面我们来实现下：</p>\n<h3 id=\"GET参数方式\"><a href=\"#GET参数方式\" class=\"headerlink\" title=\"GET参数方式\"></a>GET参数方式</h3><p>在Filter中追加参数：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</span><br><span class=\"line\">\t\t\tthrows IOException, ServletException &#123;</span><br><span class=\"line\">    HttpServletRequest httpRequest = (HttpServletRequest) request;</span><br><span class=\"line\">\tHttpServletResponse httpResponse = (HttpServletResponse) response;</span><br><span class=\"line\">    String token = request.getHeader(&quot;token&quot;);</span><br><span class=\"line\">    JWTResult result = JWTUtils.checkToken(token);</span><br><span class=\"line\">    Long userId = result.getUserId();</span><br><span class=\"line\">\tHttpServletRequestWrapper requestWrapper = new HttpServletRequestWrapper(httpRequest) &#123;</span><br><span class=\"line\">\t\t    @Override</span><br><span class=\"line\">\t\t\tpublic String[] getParameterValues(String name) &#123;</span><br><span class=\"line\">\t\t\t\tif (name.equals(&quot;loginUserId&quot;)) &#123;</span><br><span class=\"line\">\t\t\t\t\treturn new String[] &#123; userId .toString() &#125;;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\treturn super.getParameterValues(name);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t@Override</span><br><span class=\"line\">\t\t\tpublic Enumeration&lt;String&gt; getParameterNames() &#123;</span><br><span class=\"line\">\t\t\t\tSet&lt;String&gt; paramNames = new LinkedHashSet&lt;&gt;();</span><br><span class=\"line\">\t\t\t\tparamNames.add(&quot;loginUserId&quot;);</span><br><span class=\"line\">\t\t\t\tEnumeration&lt;String&gt; names =  super.getParameterNames();</span><br><span class=\"line\">\t\t\t\twhile(names.hasMoreElements()) &#123;</span><br><span class=\"line\">\t\t\t\t\tparamNames.add(names.nextElement());</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\treturn Collections.enumeration(paramNames);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tchain.doFilter(requestWrapper, httpResponse);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>接口中直接填写参数即可获取：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@GetMapping(&quot;/hello&quot;)</span><br><span class=\"line\">public String save2(String name, Long loginUserId) &#123;</span><br><span class=\"line\">\t// loginUserId 就是Filter中追加的值</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>对于post请求，也可以用这种方式：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@PostMapping(&quot;/hello&quot;)</span><br><span class=\"line\">public String save2(User user, Long loginUserId) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>可是往往我们在用post请求的时候，要么就是表单提交，要么就是json体的方式提交，一般不会使用get方式参数，这也就意味着这个loginUserId我们需要注入到对象中：</p>\n<p>先创建一个参数实体类:</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class User &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate String name;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tprivate Long loginUserId;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>先模拟表单提交的方式，看看行不行：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@PostMapping(&quot;/hello&quot;)</span><br><span class=\"line\">public User save2(User user) &#123;</span><br><span class=\"line\">\treturn user;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>用PostMan测试一下，表单方式是直接支持的：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/19/16ace69edcd28f75?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p>再次试下Json提交方式：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@PostMapping(&quot;/hello&quot;)</span><br><span class=\"line\">public User save2(@RequestBody User user) &#123;</span><br><span class=\"line\">\treturn user;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>看下图，失败了，得重新想办法实现下</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/19/16ace69edcc90ca7?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p>只需要在HttpServletRequestWrapper中重新对提交的内容进行修改即可：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public ServletInputStream getInputStream() throws IOException &#123;</span><br><span class=\"line\">\tbyte[] requestBody = new byte[0];</span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">\t\trequestBody = StreamUtils.copyToByteArray(request.getInputStream());</span><br><span class=\"line\">\t\tMap map = JsonUtils.toBean(Map.class, new String(requestBody));</span><br><span class=\"line\">\t\tmap.put(&quot;loginUserId&quot;, loginUserId);</span><br><span class=\"line\">\t\trequestBody = JsonUtils.toJson(map).getBytes();</span><br><span class=\"line\">\t&#125; catch (IOException e) &#123;</span><br><span class=\"line\">\t\tthrow new RuntimeException(e);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfinal ByteArrayInputStream bais = new ByteArrayInputStream(requestBody);</span><br><span class=\"line\">\treturn new ServletInputStream() &#123;</span><br><span class=\"line\">\t\t @Override</span><br><span class=\"line\">\t\t  public int read() throws IOException &#123;</span><br><span class=\"line\">\t\t       return bais.read();</span><br><span class=\"line\">\t\t  &#125;</span><br><span class=\"line\">\t\t </span><br><span class=\"line\">\t\t  @Override</span><br><span class=\"line\">\t\t   public boolean isFinished() &#123;</span><br><span class=\"line\">\t\t       return false;</span><br><span class=\"line\">\t\t   &#125;</span><br><span class=\"line\">\t\t </span><br><span class=\"line\">\t\t   @Override</span><br><span class=\"line\">\t\t   public boolean isReady() &#123;</span><br><span class=\"line\">\t\t        return true;</span><br><span class=\"line\">\t\t   &#125;</span><br><span class=\"line\">\t\t </span><br><span class=\"line\">\t\t   @Override</span><br><span class=\"line\">\t\t    public void setReadListener(ReadListener listener) &#123;</span><br><span class=\"line\">\t\t </span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>到此为止，我们就可以直接将Token解析的用户ID直接注入到参数中了，不用去Header中获取，是不是很方便。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/15/16ab91d71d2ab715?imageView2/0/w/1280/h/960/ignore-error/1\" alt=\"猿天地\"></p>\n","text":"本文转载自 https://juejin.im/post/5ce0dfb45188250c942f6c1d 背景我们有一个Web项目，这个项目提供了很多的Rest API。也做了权限控制，访问API的请求必须要带上事先认证后获取的Token才可以。认证的话就在Filter中进行的","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]},{"title":"【Spring】Autowired原理及与Resource注解区别","slug":"【Spring】Autowired原理及与Resource注解区别","date":"2019-05-17T07:03:08.008Z","updated":"2019-05-30T00:52:25.416Z","comments":true,"pin":null,"path":"api/articles/【Spring】Autowired原理及与Resource注解区别.json","excerpt":"","keywords":null,"cover":"https://user-gold-cdn.xitu.io/2018/9/9/165bc4a503dfcc18?imageView2/0/w/1280/h/960/ignore-error/1","content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5cde05fae51d454759351d8c\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5cde05fae51d454759351d8c</a> </p>\n</blockquote>\n<h2 id=\"Autowired注解\"><a href=\"#Autowired注解\" class=\"headerlink\" title=\"Autowired注解\"></a>Autowired注解</h2><p>Autowired顾名思义，表示自动注入，如下是Autowired注解的源代码：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Documented</span><br><span class=\"line\">public @interface Autowired &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Declares whether the annotated dependency is required.</span><br><span class=\"line\">     * &lt;p&gt;Defaults to &#123;@code true&#125;.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    boolean required() default true;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>从Autowired的实现可以看到，Autowired可以用于类的构造方法，类的字段，类的方法以及注解类型上，但是Autowired不能用于类上面。</p>\n<p>关于Autowired注解，有如下问题需要解决：</p>\n<ol>\n<li><p>Autowired作用在不同的范围上(构造方法，字段、方法)上，它的装配策略如何，按名称还是类型？</p>\n</li>\n<li><p>为构造方法，字段和方法添加Autowired注解之后，谁来解析这个Autowired注解，完成装配</p>\n</li>\n<li><p>装配的bean从何处而来，是在Spring的xml文件中定义的bean吗？</p>\n</li>\n</ol>\n<h2 id=\"从Autowired的javadoc开始\"><a href=\"#从Autowired的javadoc开始\" class=\"headerlink\" title=\"从Autowired的javadoc开始\"></a>从Autowired的javadoc开始</h2><p>从Autowired的javadoc中得到如下信息</p>\n<ol>\n<li><p>AutowiredAnnotationBeanPostProcessor负责扫描Autowired注解，然后完成自动注入</p>\n</li>\n<li><p>可以对私有的字段使用Autowired进行自动装配，而无需为私有字段定义getter/setter来read/write这个字段</p>\n</li>\n<li><p>使用Autowired注解的类方法，可以是任意的方法名，任意的参数，Spring会从容器中找到合适的bean进行装配，setter自动注入跟对字段自动注入效果一样</p>\n</li>\n</ol>\n<h2 id=\"Autowired注解的解析\"><a href=\"#Autowired注解的解析\" class=\"headerlink\" title=\"Autowired注解的解析\"></a>Autowired注解的解析</h2><p>当项目中使用了Autowired注解时，需要明确的告诉Spring,配置中引用了自动注入的功能，在Spring的配置文件，做法有两种</p>\n<ol>\n<li><p>配置AutowiredAnnotationBeanPostProcessor</p>\n</li>\n<li><p>使用<a href>context:annotation-config/</a>。<a href>context:annotationconfig/</a> 将隐式地向 Spring 容器注册<code>AutowiredAnnotationBeanPostProcessor</code>、<code>CommonAnnotationBeanPostProcessor</code>、<code>PersistenceAnnotationBeanPostProcessor</code>以及<code>RequiredAnnotationBeanPostProcessor</code> 这 4 个 BeanPostProcessor。</p>\n</li>\n</ol>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><h3 id=\"1-实例一：\"><a href=\"#1-实例一：\" class=\"headerlink\" title=\"1. 实例一：\"></a>1. 实例一：</h3><pre><code>* UserSerice依赖的UserDao使用Autowired注解，\n* UserDao没有在Spring配置文件中定义</code></pre><p><strong>结果：UserDao为null</strong></p>\n<h3 id=\"2-实例二：\"><a href=\"#2-实例二：\" class=\"headerlink\" title=\"2. 实例二：\"></a>2. 实例二：</h3><pre><code>* UserSerice依赖的UserDao使用Autowired注解\n* UserDao在Spring配置文件中有定义</code></pre><p><strong>结果：UserDao为null</strong></p>\n<h3 id=\"3-实例三：\"><a href=\"#3-实例三：\" class=\"headerlink\" title=\"3. 实例三：\"></a>3. 实例三：</h3><pre><code>* UserSerice依赖的UserDao使用Autowired注解\n* UserDao在Spring配置文件中有定义\n* Spring中使用[context:annotation-config/]()</code></pre><p>/<em>/</em> 结果：UserDao正确注入，在Spring中配置的UserDao的实现，而在UserService中的是UserDao的接口，也就是说，虽然它们类型没有完全匹配，但是由于是实现/<em>/</em></p>\n<p><strong>关系，Spring仍然能够完成自动注入</strong></p>\n<h3 id=\"4-实例四：\"><a href=\"#4-实例四：\" class=\"headerlink\" title=\"4. 实例四：\"></a>4. 实例四：</h3><pre><code>* UserSerice依赖的UserDao使用Autowired注解\n* UserDao在Spring配置文件中有定义\n* Spring中配置AutowiredAnnotationBeanPostProcessor</code></pre><p><strong>结果：UserDao正确注入，同实例三</strong></p>\n<h3 id=\"5-实例五：\"><a href=\"#5-实例五：\" class=\"headerlink\" title=\"5. 实例五：\"></a>5. 实例五：</h3><pre><code>* UserSerice依赖的UserDao使用Autowired注解\n* UserDao在Spring配置文件中有两份定义(id不同)\n* Spring中使用[context:annotation-config/]()</code></pre><p><strong>结果：</strong></p>\n<p><strong>1. 如果UserDao的属性名与某个bean的id相同，那么按照属性名和id名称匹配原则，自动装配</strong></p>\n<p><strong>2. 如果UserService中定义的UserDao的属性名，与Spring配置文件中的两个id都不同，那么注入失败，异常抛出，提示，无法完整自动装配</strong></p>\n<h2 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a><strong>结论：</strong></h2><ol>\n<li><p>使用Autowired自动装配，必须在Spring的配置文件中使用<a href>context:annotation-config/</a>来告诉Spring需要进行自动装配扫描（AutowiredAnnotationBeanPostProcessor不推荐使用）</p>\n</li>\n<li><p>Autowired默认按类型进行匹配，当匹配到多个满足条件的bean时，再按照属性名和bean的id进行匹配，如果仍然有多个匹配上或者没有一个匹配上，则抛出异常，提示自动装配失败</p>\n</li>\n<li><p>在使用Autowired时，可以使用Qualifier注解，显式的指定，当冲突发生时，使用那个id对应的bean</p>\n</li>\n<li><p>Autowired注解自动装配功能完成的是依赖的自动注入，因此，在一个bean中，它依赖的bean可以通过自动注入的方式完成而不需要显式的为它的属性进行注入。但是这些依赖的bean仍然不能省略，还是要在Spring中进行配置，省略的仅仅是bean属性的注入配置代码</p>\n</li>\n</ol>\n<h2 id=\"Resource注解\"><a href=\"#Resource注解\" class=\"headerlink\" title=\"Resource注解\"></a>Resource注解</h2><p>Resource注解在功能和目的上，等效于Autowried+Qualifier注解，Resource注解是JSR-250规范的一部分，它定义在JDK的javax.annoation包中，如下是它的定义：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package javax.annotation;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.lang.annotation.*;</span><br><span class=\"line\">import static java.lang.annotation.ElementType.*;</span><br><span class=\"line\">import static java.lang.annotation.RetentionPolicy.*;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * The Resource annotation marks a resource that is needed</span><br><span class=\"line\"> * by the application.  This annotation may be applied to an</span><br><span class=\"line\"> * application component class, or to fields or methods of the</span><br><span class=\"line\"> * component class.  When the annotation is applied to a</span><br><span class=\"line\"> * field or method, the container will inject an instance</span><br><span class=\"line\"> * of the requested resource into the application component</span><br><span class=\"line\"> * when the component is initialized.  If the annotation is</span><br><span class=\"line\"> * applied to the component class, the annotation declares a</span><br><span class=\"line\"> * resource that the application will look up at runtime. &lt;p&gt;</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Even though this annotation is not marked Inherited, deployment</span><br><span class=\"line\"> * tools are required to examine all superclasses of any component</span><br><span class=\"line\"> * class to discover all uses of this annotation in all superclasses.</span><br><span class=\"line\"> * All such annotation instances specify resources that are needed</span><br><span class=\"line\"> * by the application component.  Note that this annotation may</span><br><span class=\"line\"> * appear on private fields and methods of superclasses; the container</span><br><span class=\"line\"> * is required to perform injection in these cases as well.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @since Common Annotations 1.0</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Target(&#123;TYPE, FIELD, METHOD&#125;)</span><br><span class=\"line\">@Retention(RUNTIME)</span><br><span class=\"line\">public @interface Resource &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * The JNDI name of the resource.  For field annotations,</span><br><span class=\"line\">     * the default is the field name.  For method annotations,</span><br><span class=\"line\">     * the default is the JavaBeans property name corresponding</span><br><span class=\"line\">     * to the method.  For class annotations, there is no default</span><br><span class=\"line\">     * and this must be specified.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    String name() default &quot;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * The name of the resource that the reference points to. It can</span><br><span class=\"line\">     * link to any compatible resource using the global JNDI names.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @since Common Annotations 1.1</span><br><span class=\"line\">     */</span><br><span class=\"line\"></span><br><span class=\"line\">    String lookup() default &quot;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * The Java type of the resource.  For field annotations,</span><br><span class=\"line\">     * the default is the type of the field.  For method annotations,</span><br><span class=\"line\">     * the default is the type of the JavaBeans property.</span><br><span class=\"line\">     * For class annotations, there is no default and this must be</span><br><span class=\"line\">     * specified.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    Class&lt;?&gt; type() default java.lang.Object.class;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * The two possible authentication types for a resource.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    enum AuthenticationType &#123;</span><br><span class=\"line\">            CONTAINER,</span><br><span class=\"line\">            APPLICATION</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * The authentication type to use for this resource.</span><br><span class=\"line\">     * This may be specified for resources representing a</span><br><span class=\"line\">     * connection factory of any supported type, and must</span><br><span class=\"line\">     * not be specified for resources of other types.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    AuthenticationType authenticationType() default AuthenticationType.CONTAINER;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Indicates whether this resource can be shared between</span><br><span class=\"line\">     * this component and other components.</span><br><span class=\"line\">     * This may be specified for resources representing a</span><br><span class=\"line\">     * connection factory of any supported type, and must</span><br><span class=\"line\">     * not be specified for resources of other types.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    boolean shareable() default true;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * A product specific name that this resource should be mapped to.</span><br><span class=\"line\">     * The name of this resource, as defined by the &lt;code&gt;name&lt;/code&gt;</span><br><span class=\"line\">     * element or defaulted, is a name that is local to the application</span><br><span class=\"line\">     * component using the resource.  (It&apos;s a name in the JNDI</span><br><span class=\"line\">     * &lt;code&gt;java:comp/env&lt;/code&gt; namespace.)  Many application servers</span><br><span class=\"line\">     * provide a way to map these local names to names of resources</span><br><span class=\"line\">     * known to the application server.  This mapped name is often a</span><br><span class=\"line\">     * &lt;i&gt;global&lt;/i&gt; JNDI name, but may be a name of any form. &lt;p&gt;</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * Application servers are not required to support any particular</span><br><span class=\"line\">     * form or type of mapped name, nor the ability to use mapped names.</span><br><span class=\"line\">     * The mapped name is product-dependent and often installation-dependent.</span><br><span class=\"line\">     * No use of a mapped name is portable.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    String mappedName() default &quot;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Description of this resource.  The description is expected</span><br><span class=\"line\">     * to be in the default language of the system on which the</span><br><span class=\"line\">     * application is deployed.  The description can be presented</span><br><span class=\"line\">     * to the Deployer to help in choosing the correct resource.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    String description() default &quot;&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>Autowried注解，首先根据类型匹配，如果类型匹配到多个，那么在根据属性名和bean的id进行匹配(可以由Qualifier注解强制匹配指定的bean id)。Resource注解则顺序不同，它有如下几种可能的情况：</p>\n<pre><code>* Resource注解指定了name属性和type属性</code></pre><p>策略：首先进行按名称匹配策略： 匹配name属性和bean的id，如果匹配，则判断查找到的bean是否是type属性指定的类型，如果是type属性指定的类型，则匹配成功。如果不是<strong><strong>type属性指定的类型</strong></strong>，则抛出异常，提示匹配失败；如果name属性跟bean的id不匹配，则抛出异常提示没有bean的id匹配name属性</p>\n<pre><code>* Resource注解指定了name属性，未指定type属性</code></pre><p>策略：查找bean的id为name属性的bean，查找到，不关心类型为什么，都是匹配成功；如果找不到name属性指定的bean id，则匹配失败，抛出异常</p>\n<pre><code>* Resource注解指定了type属性，未指定name属性</code></pre><p>策略：首先进行按名称匹配策略： 匹配属性名和bean的id，如果匹配，则判断查找到的bean是否是type属性指定的类型，如果是type属性指定的类型，则匹配成功。如果不是<strong><strong>type属性指定的类型</strong></strong>，则抛出异常，提示匹配失败；其次进行按类型匹配策略： 如果属性名跟bean的id不匹配，则查找类型为type的bean，如果仅仅找到一个，自动装配成功，其它情况失败。</p>\n<pre><code>* Resource注解未指定type属性和name属性</code></pre><p>策略：首先进行按属性名匹配策略，匹配则注入成功；如果属性名不匹配，则进行类型匹配策略，只有为一个类型匹配才成功，其他情况都失败</p>\n<h3 id=\"作者注：欢迎关注笔者公号，定期分享IT互联网、金融等工作经验心得、人生感悟，欢迎交流，目前就职阿里-移动事业部，需要大厂内推的也可到公众号砸简历，或查看我个人资料获取。（公号ID：weknow619）。\"><a href=\"#作者注：欢迎关注笔者公号，定期分享IT互联网、金融等工作经验心得、人生感悟，欢迎交流，目前就职阿里-移动事业部，需要大厂内推的也可到公众号砸简历，或查看我个人资料获取。（公号ID：weknow619）。\" class=\"headerlink\" title=\"作者注：欢迎关注笔者公号，定期分享IT互联网、金融等工作经验心得、人生感悟，欢迎交流，目前就职阿里-移动事业部，需要大厂内推的也可到公众号砸简历，或查看我个人资料获取。（公号ID：weknow619）。\"></a>作者注：欢迎关注笔者公号，定期分享IT互联网、金融等工作经验心得、人生感悟，欢迎交流，目前就职阿里-移动事业部，需要大厂内推的也可到公众号砸简历，或查看我个人资料获取。（公号ID：weknow619）。</h3><p><img src=\"https://user-gold-cdn.xitu.io/2018/9/9/165bc4a503dfcc18?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n","text":"本文转载自 https://juejin.im/post/5cde05fae51d454759351d8c Autowired注解Autowired顾名思义，表示自动注入，如下是Autowired注解的源代码：1<br>2<br>3<br>4<br>5<br>6<br>7<br>","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":2,"path":"api/tags/Spring.json"}]},{"title":"【干货走一波】千万级用户的大型网站，应该如何设计其高并发架构？","slug":"【干货走一波】千万级用户的大型网站，应该如何设计其高并发架构？","date":"2019-05-07T01:59:11.011Z","updated":"2019-05-30T00:52:25.417Z","comments":true,"pin":null,"path":"api/articles/【干货走一波】千万级用户的大型网站，应该如何设计其高并发架构？.json","excerpt":"","keywords":null,"cover":"https://user-gold-cdn.xitu.io/2019/5/5/16a885a0451b894b?imageView2/0/w/1280/h/960/ignore-error/1","content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5cceee97f265da03b20442df\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5cceee97f265da03b20442df</a> </p>\n</blockquote>\n<p><strong>公众号：狸猫技术窝</strong><br><strong>作者：原子弹大侠，阿里巴巴高级技术专家</strong></p>\n<p>目录 （1）单块架构</p>\n<p>（2）初步的高可用架构</p>\n<p>（3）千万级用户量的压力预估</p>\n<p>（4）服务器压力预估</p>\n<p>（5）业务垂直拆分</p>\n<p>（6）用分布式缓存抗下读请求</p>\n<p>（7）基于数据库主从架构做读写分离</p>\n<p>（8）总结</p>\n<p><strong>本文将会从一个大型的网站发展历程出发，一步一步的探索这个网站的架构是如何从单体架构，演化到分布式架构，然后演化到高并发架构的。</strong></p>\n<h2 id=\"（1）单块架构\"><a href=\"#（1）单块架构\" class=\"headerlink\" title=\"（1）单块架构\"></a>（1）单块架构</h2><p>一般一个网站刚开始建立的时候，用户量是很少的，大概可能就几万或者几十万的用户量，每天活跃的用户可能就几百或者几千个。</p>\n<p>这个时候一般网站架构都是采用单体架构来设计的，总共就部署3台服务器，1台应用服务器，1台数据库服务器，1台图片服务器。</p>\n<p>研发团队通常都在10人以内，就是在一个单块应用里写代码，然后写好之后合并代码，接着就是直接在线上的应用服务器上发布。很可能就是手动把应用服务器上的Tomcat给关掉，然后替换系统的代码war包，接着重新启动Tomcat。</p>\n<p>数据库一般就部署在一台独立的服务器上，存放网站的全部核心数据。</p>\n<p>然后在另外一台独立的服务器上部署NFS作为图片服务器，存放网站的全部图片。应用服务器上的代码会连接以及操作数据库以及图片服务器。如下图所示：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/5/16a885a0451b894b?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<h2 id=\"（2）初步的高可用架构\"><a href=\"#（2）初步的高可用架构\" class=\"headerlink\" title=\"（2）初步的高可用架构\"></a>（2）初步的高可用架构</h2><p>但是这种纯单块系统架构下，有高可用问题存在，最大的问题就是应用服务器可能会故障，或者是数据库可能会故障</p>\n<p>所以在这个时期，一般稍微预算充足一点的公司，都会做一个初步的高可用架构出来。</p>\n<p>对于应用服务器而言，一般会集群化部署。当然所谓的集群化部署，在初期用户量很少的情况下，其实一般也就是部署两台应用服务器而已，然后前面会放一台服务器部署负载均衡设备，比如说LVS，均匀的把用户请求打到两台应用服务器上去。</p>\n<p>如果此时某台应用服务器故障了，还有另外一台应用服务器是可以使用的，这样就避免了单点故障问题。如下图所示：<br><img src=\"https://user-gold-cdn.xitu.io/2019/5/5/16a885a2519a865d?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p>对于数据库服务器而言，此时一般也会使用主从架构，部署一台从库来从主库同步数据，这样一旦主库出现问题，可以迅速使用从库继续提供数据库服务，避免数据库故障导致整个系统都彻底故障不可用。如下图：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/5/16a885a8fe3170fa?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<h2 id=\"（3）千万级用户量的压力预估\"><a href=\"#（3）千万级用户量的压力预估\" class=\"headerlink\" title=\"（3）千万级用户量的压力预估\"></a>（3）千万级用户量的压力预估</h2><p>这个假设这个网站预估的用户数是1000万，那么根据28法则，每天会来访问这个网站的用户占到20%，也就是200万用户每天会过来访问。</p>\n<p>通常假设平均每个用户每次过来会有30次的点击，那么总共就有6000万的点击（PV）。</p>\n<p>每天24小时，根据28法则，每天大部分用户最活跃的时间集中在（24小时 /* 0.2）≈ 5小时内，而大部分用户指的是（6000万点击 /* 0.8 ≈ 5000万点击）</p>\n<p>也就是说，在5小时内会有5000万点击进来。</p>\n<p>换算下来，在那5小时的活跃访问期内，大概每秒钟会有3000左右的请求量，然后这5小时中可能又会出现大量用户集中访问的高峰时间段。</p>\n<p>比如在集中半个小时内大量用户涌入形成高峰访问。根据线上经验，一般高峰访问是活跃访问的2~3倍。假设我们按照3倍来计算，那么5小时内可能有短暂的峰值会出现每秒有10000左右的请求。</p>\n<h2 id=\"（4）服务器压力预估\"><a href=\"#（4）服务器压力预估\" class=\"headerlink\" title=\"（4）服务器压力预估\"></a>（4）服务器压力预估</h2><p>大概知道了高峰期每秒钟可能会有1万左右的请求量之后，来看一下系统中各个服务器的压力预估。</p>\n<p>一般来说一台虚拟机部署的应用服务器，上面放一个Tomcat，也就支撑最多每秒几百的请求。</p>\n<p>按每秒支撑500的请求来计算，那么支撑高峰期的每秒1万访问量，需要部署20台应用服务。</p>\n<p>而且应用服务器对数据库的访问量又是要翻几倍的，因为假设一秒钟应用服务器接收到1万个请求，但是应用服务器为了处理每个请求可能要涉及到平均3~5次数据库的访问。</p>\n<p>按照3次数据库访问来算，那么每秒会对数据库形成3万次的请求。</p>\n<p>按照一台数据库服务器最高支撑每秒5000左右的请求量，此时需要通过6台数据库服务器才能支撑每秒3万左右的请求。</p>\n<p>图片服务器的压力同样会很大，因为需要大量的读取图片展示页面，这个不太好估算，但是大致可以推算出来每秒至少也会有几千次请求，因此也需要多台图片服务器来支撑图片访问的请求。</p>\n<h2 id=\"（5）业务垂直拆分\"><a href=\"#（5）业务垂直拆分\" class=\"headerlink\" title=\"（5）业务垂直拆分\"></a>（5）业务垂直拆分</h2><p>一般来说在这个阶段要做的第一件事儿就是业务的垂直拆分</p>\n<p>因为如果所有业务代码都混合在一起部署，会导致多人协作开发时难以维护。在网站到了千万级用户的时候，研发团队一般都有几十人甚至上百人。</p>\n<p>所以这时如果还是在一个单块系统里做开发，是一件非常痛苦的事情，此时需要做的就是进行业务的垂直拆分，把一个单块系统拆分为多个业务系统，然后一个小团队10个人左右就专门负责维护一个业务系统。如下图</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/5/16a885ae541528b8?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<h2 id=\"（6）分布式缓存扛下读请求\"><a href=\"#（6）分布式缓存扛下读请求\" class=\"headerlink\" title=\"（6）分布式缓存扛下读请求\"></a>（6）分布式缓存扛下读请求</h2><p>这个时候应用服务器层面一般没什么大问题，因为无非就是加机器就可以抗住更高的并发请求。</p>\n<p>现在估算出来每秒钟是1万左右的请求，部署个二三十台机器就没问题了。</p>\n<p>但是目前上述系统架构中压力最大的，其实是数据库层面 ，因为估算出来可能高峰期对数据库的读写并发会有3万左右的请求。</p>\n<p>此时就需要引入分布式缓存来抗下对数据库的读请求压力了，也就是引入Redis集群。</p>\n<p>一般来说对数据库的读写请求也大致遵循28法则，所以每秒3万的读写请求中，大概有2.4万左右是读请求</p>\n<p>这些读请求基本上90%都可以通过分布式缓存集群来抗下来，也就是大概2万左右的读请求可以通过 Redis集群来抗住。</p>\n<p>我们完全可以把热点的、常见的数据都在Redis集群里放一份作为缓存，然后对外提供缓存服务。</p>\n<p>在读数据的时候优先从缓存里读，如果缓存里没有，再从数据库里读取。这样2万读请求就落到Redis上了，1万读写请求继续落在数据库上。</p>\n<p>Redis一般单台服务器抗每秒几万请求是没问题的，所以Redis集群一般就部署3台机器，抗下每秒2万读请求是绝对没问题的。如下图所示：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/5/16a885b167cac4c8?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<h2 id=\"（7）基于数据库主从架构做读写分离\"><a href=\"#（7）基于数据库主从架构做读写分离\" class=\"headerlink\" title=\"（7）基于数据库主从架构做读写分离\"></a>（7）基于数据库主从架构做读写分离</h2><p>此时数据库服务器还是存在每秒1万的请求，对于单台服务器来说压力还是过大。</p>\n<p>但是数据库一般都支持主从架构，也就是有一个从库一直从主库同步数据过去。此时可以基于主从架构做读写分离。</p>\n<p>也就是说，每秒大概6000写请求是进入主库，大概还有4000个读请求是在从库上去读，这样就可以把1万读写请求压力分摊到两台服务器上去。</p>\n<p>这么分摊过后，主库每秒最多6000写请求，从库每秒最多4000读请求，基本上可以勉强把压力给抗住。如下图：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/5/16a885b2996544a7?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<h2 id=\"（8）总结\"><a href=\"#（8）总结\" class=\"headerlink\" title=\"（8）总结\"></a>（8）总结</h2><p>本文主要是探讨在千万级用户场景下的大型网站的高并发架构设计，也就是预估出了千万级用户的访问压力以及对应的后台系统为了要抗住高并发，在业务系统、缓存、数据库几个层面的架构设计以及抗高并发的分析。</p>\n<p>但是要记住，大型网站架构中共涉及的技术远远不止这些，还包括了MQ、CDN、静态化、分库分表、NoSQL、搜索、分布式文件系统、反向代理，等等很多话题，但是本文不能一一涉及，主要是在高并发这个角度分析一下系统如何抗下每秒上万的请求。</p>\n<p><strong>END</strong></p>\n<p>长按下图二维码，即刻关注【狸猫技术窝】 阿里、京东、美团、字节跳动 顶尖技术专家坐镇 为IT人打造一个 “有温度” 的技术窝！</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/23/16a4aea4c6855bb5?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n","text":"本文转载自 https://juejin.im/post/5cceee97f265da03b20442df 公众号：狸猫技术窝<br>作者：原子弹大侠，阿里巴巴高级技术专家目录 （1）单块架构（2）初步的高可用架构（3）千万级用户量的压力预估（4）服务器压力预估（5）业务垂直拆分","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]},{"title":"一个简单的基于 Redis 的分布式任务调度器 —— Java 语言实现","slug":"一个简单的基于 Redis 的分布式任务调度器 —— Java 语言实现","date":"2019-04-29T16:00:00.000Z","updated":"2019-05-30T00:52:25.418Z","comments":true,"pin":null,"path":"api/articles/一个简单的基于 Redis 的分布式任务调度器 —— Java 语言实现.json","excerpt":"","keywords":null,"cover":"https://user-gold-cdn.xitu.io/2019/4/29/16a682144a242fdf?imageView2/0/w/1280/h/960/ignore-error/1","content":"<blockquote>\n<p>本文来自于 <a href=\"https://juejin.im/post/5cc6ade4f265da038d0b4fd6\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5cc6ade4f265da038d0b4fd6</a> </p>\n</blockquote>\n<p>折腾了一周的 <code>Java Quartz</code>集群任务调度，很遗憾没能搞定，网上的相关文章也少得可怜，在多节点（多进程）环境下 Quartz 似乎无法动态增减任务，恼火。无奈之下自己撸了一个简单的任务调度器，结果只花了不到 2天时间，而且感觉非常简单好用，代码量也不多，扩展性很好。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/29/16a682144a242fdf?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p>实现一个分布式的任务调度器有几个关键的考虑点</p>\n<ol>\n<li>单次任务和循环任务好做，难的是 cron 表达式的解析和时间计算怎么做？</li>\n<li>多进程同一时间如何保证一个任务的互斥性？</li>\n<li>如何动态变更增加和减少任务？</li>\n</ol>\n<h2 id=\"代码实例\"><a href=\"#代码实例\" class=\"headerlink\" title=\"代码实例\"></a>代码实例</h2><p>在深入讲解实现方法之前，我们先来看看这个调度器是如何使用的</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Demo &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        var redis = new RedisStore();</span><br><span class=\"line\">        // sample 为任务分组名称</span><br><span class=\"line\">        var store = new RedisTaskStore(redis, &quot;sample&quot;);</span><br><span class=\"line\">        // 5s 为任务锁寿命</span><br><span class=\"line\">        var scheduler = new DistributedScheduler(store, 5);</span><br><span class=\"line\">        // 注册一个单次任务</span><br><span class=\"line\">        scheduler.register(Trigger.onceOfDelay(5), Task.of(&quot;once1&quot;, () -&gt; &#123;</span><br><span class=\"line\">            System.out.println(&quot;once1&quot;);</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">        // 注册一个循环任务</span><br><span class=\"line\">        scheduler.register(Trigger.periodOfDelay(5, 5), Task.of(&quot;period2&quot;, () -&gt; &#123;</span><br><span class=\"line\">            System.out.println(&quot;period2&quot;);</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">        // 注册一个 CRON 任务</span><br><span class=\"line\">        scheduler.register(Trigger.cronOfMinutes(1), Task.of(&quot;cron3&quot;, () -&gt; &#123;</span><br><span class=\"line\">            System.out.println(&quot;cron3&quot;);</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">        // 设置全局版本号</span><br><span class=\"line\">        scheduler.version(1);</span><br><span class=\"line\">        // 注册监听器</span><br><span class=\"line\">        scheduler.listener(ctx -&gt; &#123;</span><br><span class=\"line\">            System.out.println(ctx.task().name() + &quot; is complete&quot;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        // 启动调度器</span><br><span class=\"line\">        scheduler.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>当代码升级任务需要增加减少时（或者变更调度时间），只需要递增全局版本号，现有的进程中的任务会自动被重新调度，那些没有被注册的任务（任务减少）会自动清除。新增的任务（新任务）在老代码的进程里是不会被调度的（没有新任务的代码无法调度），被清除的任务（老任务）在老代码的进程里会被取消调度。</p>\n<p>比如我们要取消 period2 任务，增加 period4 任务</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Demo &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        var redis = new RedisStore();</span><br><span class=\"line\">        // sample 为任务分组名称</span><br><span class=\"line\">        var store = new RedisTaskStore(redis, &quot;sample&quot;);</span><br><span class=\"line\">        // 5s 为任务锁寿命</span><br><span class=\"line\">        var scheduler = new DistributedScheduler(store, 5);</span><br><span class=\"line\">        // 注册一个单次任务</span><br><span class=\"line\">        scheduler.register(Trigger.onceOfDelay(5), Task.of(&quot;once1&quot;, () -&gt; &#123;</span><br><span class=\"line\">            System.out.println(&quot;once1&quot;);</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">        // 注册一个 CRON 任务</span><br><span class=\"line\">        scheduler.register(Trigger.cronOfMinutes(1), Task.of(&quot;cron3&quot;, () -&gt; &#123;</span><br><span class=\"line\">            System.out.println(&quot;cron3&quot;);</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">        // 注册一个循环任务</span><br><span class=\"line\">        scheduler.register(Trigger.periodOfDelay(5, 10), Task.of(&quot;period4&quot;, () -&gt; &#123;</span><br><span class=\"line\">            System.out.println(&quot;period4&quot;);</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">        // 递增全局版本号</span><br><span class=\"line\">        scheduler.version(2);</span><br><span class=\"line\">        // 注册监听器</span><br><span class=\"line\">        scheduler.listener(ctx -&gt; &#123;</span><br><span class=\"line\">            System.out.println(ctx.task().name() + &quot; is complete&quot;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        // 启动调度器</span><br><span class=\"line\">        scheduler.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"cron4j\"><a href=\"#cron4j\" class=\"headerlink\" title=\"cron4j\"></a>cron4j</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;it.sauronsoftware.cron4j&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;cron4j&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;2.2.5&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div>\n\n<p>这个开源的 library 包含了基础的 cron 表达式解析功能，它还提供了任务的调度功能，不过这里并不需要使用它的调度器。我只会用到它的表达式解析功能，以及一个简单的方法用来判断当前的时间是否匹配表达式（是否该运行任务了）。</p>\n<p>我们对 cron 的时间精度要求很低，1 分钟判断一次当前的时间是否到了该运行任务的时候就可以了。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class SchedulingPattern &#123;</span><br><span class=\"line\">    // 表达式是否有效</span><br><span class=\"line\">    boolean validate(String cronExpr);</span><br><span class=\"line\">    // 是否应该运行任务了(一分钟判断一次)</span><br><span class=\"line\">    boolean match(long nowTs);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"任务的互斥性\"><a href=\"#任务的互斥性\" class=\"headerlink\" title=\"任务的互斥性\"></a>任务的互斥性</h2><p>因为是分布式任务调度器，多进程环境下要控制同一个任务在调度的时间点只能有一个进程运行。使用 Redis 分布式锁很容易就可以搞定。锁需要保持一定的时间（比如默认 5s）。</p>\n<p>所有的进程都会在同一时间调度这个任务，但是只有一个进程可以抢到锁。因为分布式环境下时间的不一致性，不同机器上的进程会有较小的时间差异窗口，锁必须保持一个窗口时间，这里我默认设置为 5s（可定制），这就要求不同机器的时间差不能超过 5s，超出了这个值就会出现重复调度。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean grabTask(String name) &#123;</span><br><span class=\"line\">    var holder = new Holder&lt;Boolean&gt;();</span><br><span class=\"line\">    redis.execute(jedis -&gt; &#123;</span><br><span class=\"line\">        var lockKey = keyFor(&quot;task_lock&quot;, name);</span><br><span class=\"line\">        var ok = jedis.set(lockKey, &quot;true&quot;, SetParams.setParams().nx().ex(lockAge));</span><br><span class=\"line\">        holder.value(ok != null);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return holder.value();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"全局版本号\"><a href=\"#全局版本号\" class=\"headerlink\" title=\"全局版本号\"></a>全局版本号</h2><p>我们给任务列表附上一个全局的版本号，当业务上需要增加或者减少调度任务时，通过变更版本号来触发进程的任务重加载。这个重加载的过程包含轮询全局版本号（Redis 的一个key），如果发现版本号变动，立即重新加载任务列表配置并重新调度所有的任务。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void scheduleReload() &#123;</span><br><span class=\"line\">    // 1s 对比一次</span><br><span class=\"line\">    this.scheduler.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            if (this.reloadIfChanged()) &#123;</span><br><span class=\"line\">                this.rescheduleTasks();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            LOG.error(&quot;reloading tasks error&quot;, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, 0, 1, TimeUnit.SECONDS);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>重新调度任务先要取消当前所有正在调度的任务，然后调度刚刚加载的所有任务。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void rescheduleTasks() &#123;</span><br><span class=\"line\">    this.cancelAllTasks();</span><br><span class=\"line\">    this.scheduleTasks();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private void cancelAllTasks() &#123;</span><br><span class=\"line\">    this.futures.forEach((name, future) -&gt; &#123;</span><br><span class=\"line\">        LOG.warn(&quot;cancelling task &#123;&#125;&quot;, name);</span><br><span class=\"line\">        future.cancel(false);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    this.futures.clear();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>因为需要将任务持久化，所以设计了一套任务的序列化格式，这个也很简单，使用文本符号分割任务配置属性就行。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一次性任务(startTime)</span><br><span class=\"line\">ONCE@2019-04-29T15:26:29.946+0800</span><br><span class=\"line\">// 循环任务，(startTime,endTime,period)，这里任务的结束时间是天荒地老</span><br><span class=\"line\">PERIOD@2019-04-29T15:26:29.949+0800|292278994-08-17T15:12:55.807+0800|5</span><br><span class=\"line\">// cron 任务，一分钟一次</span><br><span class=\"line\">CRON@*/1 * * * *</span><br><span class=\"line\"></span><br><span class=\"line\">$ redis-cli</span><br><span class=\"line\">127.0.0.1:6379&gt; hgetall sample_triggers</span><br><span class=\"line\">1) &quot;task3&quot;</span><br><span class=\"line\">2) &quot;CRON@*/1 * * * *&quot;</span><br><span class=\"line\">3) &quot;task2&quot;</span><br><span class=\"line\">4) &quot;PERIOD@2019-04-29T15:26:29.949+0800|292278994-08-17T15:12:55.807+0800|5&quot;</span><br><span class=\"line\">5) &quot;task1&quot;</span><br><span class=\"line\">6) &quot;ONCE@2019-04-29T15:26:29.946+0800&quot;</span><br><span class=\"line\">7) &quot;task4&quot;</span><br><span class=\"line\">8) &quot;PERIOD@2019-04-29T15:26:29.957+0800|292278994-08-17T15:12:55.807+0800|10&quot;</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>时间调度会有一个单独的线程（单线程线程池），任务的运行由另外一个线程池来完成（数量可定制）。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class DistributedScheduler &#123;</span><br><span class=\"line\">    private ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();</span><br><span class=\"line\">    private ExecutorService executor = Executors.newFixedThreadPool(threads);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>之所以要将线程池分开，是为了避免任务的执行（IO）影响了时间的精确调度。</p>\n<h2 id=\"FixedDelay-vs-FixedRate\"><a href=\"#FixedDelay-vs-FixedRate\" class=\"headerlink\" title=\"FixedDelay vs FixedRate\"></a>FixedDelay vs FixedRate</h2><p>Java 的内置调度器提供两种调度策略 FixedDelay 和 FixedRate。FixedDelay 保证同一个任务的连续两次运行有相等的时延（nextRun.startTime - lastRun.endTime），FixedRate 保证同一个任务的连续运行有确定的间隔（nextRun.startTime - lastRun.startTime）。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/29/16a68a816b58ca9e?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p>FixedDelay 就好比你加班到深夜12点，可以第二天12点再来上班(保证固定的休息时间)，而 FixedRate 就没那么体贴了，第二天你继续 9点过来上班。如果你不走运到第二天 9 点了还在加班，那你今天就没有休息时间了，继续上班吧。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ScheduledExecutorService &#123;</span><br><span class=\"line\">    void scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit);</span><br><span class=\"line\">    void scheduleAtFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>分布式调度器要求有精确的调度时间，所以必须采用 FixedRate 模式，保证多节点同一个任务在同一时间被争抢。如果采用 FixedDelay 模式，会导致不同进程的调度时间错开了，分布式锁的默认 5s 时间窗口将起不到互斥作用。</p>\n<h2 id=\"支持无互斥任务\"><a href=\"#支持无互斥任务\" class=\"headerlink\" title=\"支持无互斥任务\"></a>支持无互斥任务</h2><p>互斥任务要求任务的单进程运行，无互斥任务就是没有加分布式锁的任务，可以多进程同时运行。默认需要互斥。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Task &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 是否需要考虑多进程互斥（true表示不互斥，多进程能同时跑）</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private boolean concurrent;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private Runnable runner;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    public static Task of(String name, Runnable runner) &#123;</span><br><span class=\"line\">        return new Task(name, false, runner);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static Task concurrent(String name, Runnable runner) &#123;</span><br><span class=\"line\">        return new Task(name, true, runner);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"增加回调接口\"><a href=\"#增加回调接口\" class=\"headerlink\" title=\"增加回调接口\"></a>增加回调接口</h2><p>考虑到调度器的使用者可能需要对任务运行状态进行监控，这里增加了一个简单的回调接口，目前功能比较简单。能汇报运行结果（成功还是异常）和运行的耗时</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TaskContext &#123;</span><br><span class=\"line\">    private Task task;</span><br><span class=\"line\">    private long cost;  // 运行时间</span><br><span class=\"line\">    private boolean ok;</span><br><span class=\"line\">    private Throwable e;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">interface ISchedulerListener &#123;</span><br><span class=\"line\">    public void onComplete(TaskContext ctx);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"支持存储扩展\"><a href=\"#支持存储扩展\" class=\"headerlink\" title=\"支持存储扩展\"></a>支持存储扩展</h2><p>目前只实现了 Redis 和 Memory 形式的任务存储，扩展到 zk、etcd、关系数据库也是可行的，实现下面的接口即可。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface ITaskStore &#123;</span><br><span class=\"line\">  public long getRemoteVersion();</span><br><span class=\"line\">  public Map&lt;String, String&gt; getAllTriggers();</span><br><span class=\"line\">  public void saveAllTriggers(long version, Map&lt;String, String&gt; triggers);</span><br><span class=\"line\">  public boolean grabTask(String name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"代码地址\"><a href=\"#代码地址\" class=\"headerlink\" title=\"代码地址\"></a>代码地址</h2><p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fpyloque%2Ftaskino\" target=\"_blank\" rel=\"noopener\">github.com/pyloque/tas…</a></p>\n","text":"本文来自于 https://juejin.im/post/5cc6ade4f265da038d0b4fd6 折腾了一周的 Java Quartz集群任务调度，很遗憾没能搞定，网上的相关文章也少得可怜，在多节点（多进程）环境下 Quartz 似乎无法动态增减任务，恼火。无奈之下自己","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"},{"name":"分布式","slug":"分布式","count":1,"path":"api/tags/分布式.json"}]},{"title":"【面试】吃透了这些Redis知识点，面试官一定觉得你很NB","slug":"【面试】吃透了这些Redis知识点，面试官一定觉得你很NB","date":"2019-04-29T16:00:00.000Z","updated":"2019-05-30T00:52:25.418Z","comments":true,"pin":null,"path":"api/articles/【面试】吃透了这些Redis知识点，面试官一定觉得你很NB.json","excerpt":"","keywords":null,"cover":"https://juejin.im/equation?tex=%E5%8F%82%E6%95%B01%E7%9A%84%E5%AD%97%E8%8A%82%E6%95%B0CRLF%E5%8F%82%E6%95%B01%E7%9A%84%E6%95%B0%E6%8D%AECRLF...","content":"<blockquote>\n<p>本文来自于 <a href=\"https://juejin.im/post/5cc6bb975188252e8925f0c8\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5cc6bb975188252e8925f0c8</a> </p>\n</blockquote>\n<h1 id=\"是数据结构而非类型\"><a href=\"#是数据结构而非类型\" class=\"headerlink\" title=\"是数据结构而非类型\"></a>是数据结构而非类型</h1><p>很多文章都会说，redis支持5种常用的数据类型，这其实是存在很大的歧义。redis里存的都是二进制数据，其实就是字节数组（byte[]），这些字节数据是没有数据类型的，只有把它们按照合理的格式解码后，可以变成一个字符串，整数或对象，此时才具有数据类型。</p>\n<ul>\n<li>这一点必须要记住。所以任何东西只要能转化成字节数组（byte[]）的，都可以存到redis里。管你是字符串、数字、对象、图片、声音、视频、还是文件，只要变成byte数组。</li>\n<li>因此redis里的String指的并不是字符串，它其实表示的是一种最简单的数据结构，即一个key只能对应一个value。这里的key和value都是byte数组，只不过key一般是由一个字符串转换成的byte数组，value则根据实际需要而定。</li>\n<li>在特定情况下，对value也会有一些要求，比如要进行自增或自减操作，那value对应的byte数组必须要能被解码成一个数字才行，否则会报错。</li>\n<li>那么List这种数据结构，其实表示一个key可以对应多个value，且value之间是有先后顺序的，value值可以重复。</li>\n<li>Set这种数据结构，表示一个key可以对应多个value，且value之间是没有先后顺序的，value值也不可以重复。</li>\n<li>Hash这种数据结构，表示一个key可以对应多个key-value对，此时这些key-value对之间的先后顺序一般意义不大，这是一个按照名称语义来访问的数据结构，而非位置语义。</li>\n<li>Sorted Set这种数据结构，表示一个key可以对应多个value，value之间是有大小排序的，value值不可以重复。每个value都和一个浮点数相关联，该浮点数叫score。元素排序规则是：先按score排序，再按value排序。</li>\n<li>相信现在你对这5种数据结构有了更清晰的认识，那它们的对应命令对你来说就是小case了。</li>\n</ul>\n<h1 id=\"集群带来的问题与解决思路\"><a href=\"#集群带来的问题与解决思路\" class=\"headerlink\" title=\"集群带来的问题与解决思路\"></a>集群带来的问题与解决思路</h1><ul>\n<li>集群带来的好处是显而易见的，比如容量增加、处理能力增强，还可以按需要进行动态的扩容、缩容。但同时也会引入一些新的问题，至少会有下面这两个。</li>\n<li><strong>一是数据分配</strong>：存数据时应该放到哪个节点上，取数据时应该去哪个节点上找。 <strong>二是数据移动</strong>：集群扩容，新增加节点时，该节点上的数据从何处来；集群缩容，要剔除节点时，该节点上的数据往何处去。</li>\n<li>上面这两个问题有一个<strong>共同点</strong>就是，<strong>如何去描述和存储数据与节点的映射关系</strong>。又因为数据的位置是由key决定的，所以问题就演变为如何建立起各个key和集群所有节点的关联关系。</li>\n<li>集群的节点是相对固定和少数的，虽然有增加节点和剔除节点。但集群里存储的key，则是完全随机、没有规律、不可预测、数量庞多，还非常琐碎。</li>\n<li>这就好比一所大学和它的所有学生之间的关系。如果大学和学生直接挂钩的话，一定会比较混乱。现实是它们之间又加入了好几层，首先有院系，其次有专业，再者有年级，最后还有班级。经过这四层映射之后，关系就清爽很多了。</li>\n<li>这其实是一个非常重要的结论，这个世界上没有什么问题是不能通过加入一层来解决的。如果有，那就再加入一层。计算机里也是这样的。</li>\n<li>redis在数据和节点之间又加入了一层，把这层称为槽（slot），因该槽主要和哈希有关，又叫哈希槽。</li>\n<li>最后变成了，节点上放的是槽，槽里放的是数据。槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。哈希解决的是映射问题，使用key的哈希值来计算所在的槽，便于数据分配。</li>\n<li>可以这样来理解，你的学习桌子上堆满了书，乱的很，想找到某本书非常困难。于是你买了几个大的收纳箱，把这些书按照书名的长度放入不同的收纳箱，然后把这些收纳箱放到桌子上。</li>\n<li>这样就变成了，桌子上是收纳箱，收纳箱里是书籍。这样书籍移动很方便，搬起一个箱子就走了。寻找书籍也很方便，只要数一数书名的长度，去对应的箱子里找就行了。</li>\n<li>其实我们也没做什么，只是买了几个箱子，按照某种规则把书装入箱子。就这么简单的举动，就彻底改变了原来一盘散沙的状况。是不是有点小小的神奇呢。</li>\n<li>一个集群只能有16384个槽，编号0-16383。这些槽会分配给集群中的所有主节点，分配策略没有要求。可以指定哪些编号的槽分配给哪个主节点。集群会记录节点和槽的对应关系。</li>\n<li>接下来就需要对key求哈希值，然后对16384取余，余数是几key就落入对应的槽里。slot = CRC16(key) % 16384。</li>\n<li>以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。</li>\n<li>使用哈希函数计算出key的哈希值，这样就可以算出它对应的槽，然后利用集群存储的槽和节点的映射关系查询出槽所在的节点，于是数据和节点就映射起来了，这样数据分配问题就解决了。</li>\n<li>我想说的是，一般的人只会去学习各种技术，高手更在乎如何跳出技术，寻求一种解决方案或思路方向，顺着这个方向走下去，八九不离十能找到你想要的答案。</li>\n</ul>\n<h1 id=\"集群对命令操作的取舍\"><a href=\"#集群对命令操作的取舍\" class=\"headerlink\" title=\"集群对命令操作的取舍\"></a>集群对命令操作的取舍</h1><ul>\n<li><p>客户端只要和集群中的一个节点建立链接后，就可以获取到整个集群的所有节点信息。此外还会获取所有哈希槽和节点的对应关系信息，这些信息数据都会在客户端缓存起来，因为这些信息相当有用。</p>\n</li>\n<li><p>客户端可以向任何节点发送请求，那么拿到一个key后到底该向哪个节点发请求呢？其实就是把集群里的那套key和节点的映射关系理论搬到客户端来就行了。</p>\n</li>\n<li><p>所以客户端需要实现一个和集群端一样的哈希函数，先计算出key的哈希值，然后再对16384取余，这样就找到了该key对应的哈希槽，利用客户端缓存的槽和节点的对应关系信息，就可以找到该key对应的节点了。</p>\n</li>\n<li><p>接下来发送请求就可以了。还可以把key和节点的映射关系缓存起来，下次再请求该key时，直接就拿到了它对应的节点，不用再计算一遍了。</p>\n</li>\n<li><p>理论和现实总是有差距的，集群已经发生了变化，客户端的缓存还没来得及更新。肯定会出现拿到一个key向对应的节点发请求，其实这个key已经不在那个节点上了。此时这个节点应该怎么办？</p>\n</li>\n<li><p>这个节点可以去key实际所在的节点上拿到数据再返回给客户端，也可以直接告诉客户端key已经不在我这里了，同时附上key现在所在的节点信息，让客户端再去请求一次，类似于HTTP的302重定向。</p>\n</li>\n<li><p>这其实是个选择问题，也是个哲学问题。结果就是redis集群选择了后者。因此，节点只处理自己拥有的key，对于不拥有的key将返回重定向错误，即-MOVED key 127.0.0.1:6381，客户端重新向这个新节点发送请求。</p>\n</li>\n<li><p>所以说选择是一种哲学，也是个智慧。稍后再谈这个问题。先来看看另一个情况，和这个问题有些相同点。</p>\n</li>\n<li><p>redis有一种命令可以一次带多个key，如MGET，我把这些称为多key命令。这个多key命令的请求被发送到一个节点上，这里有一个潜在的问题，不知道大家有没有想到，就是这个命令里的多个key一定都位于那同一个节点上吗？</p>\n</li>\n<li><p>就分为两种情况了，如果多个key不在同一个节点上，此时节点只能返回重定向错误了，但是多个key完全可能位于多个不同的节点上，此时返回的重定向错误就会非常乱，所以redis集群选择不支持此种情况。</p>\n</li>\n<li><p>如果多个key位于同一个节点上呢，理论上是没有问题的，redis集群是否支持就和redis的版本有关系了，具体使用时自己测试一下就行了。</p>\n</li>\n<li><p>在这个过程中我们发现了一件颇有意义的事情，就是让一组相关的key映射到同一个节点上是非常有必要的，这样可以提高效率，通过多key命令一次获取多个值。</p>\n</li>\n<li><p>那么问题来了，如何给这些key起名字才能让他们落到同一个节点上，难不成都要先计算个哈希值，再取个余数，太麻烦了吧。当然不是这样了，redis已经帮我们想好了。</p>\n</li>\n<li><p>可以来简单推理下，要想让两个key位于同一个节点上，它们的哈希值必须要一样。要想哈希值一样，传入哈希函数的字符串必须一样。那我们只能传进去两个一模一样的字符串了，那不就变成同一个key了，后面的会覆盖前面的数据。</p>\n</li>\n<li><p>这里的问题是我们都是拿整个key去计算哈希值，这就导致key和参与计算哈希值的字符串耦合了，需要将它们解耦才行，就是key和参与计算哈希值的字符串有关但是又不一样。</p>\n</li>\n<li><p>redis基于这个原理为我们提供了方案，叫做key哈希标签。先看例子，{user1000}.following，{user1000}.followers，相信你已经看出了门道，就是仅使用Key中的位于{和}间的字符串参与计算哈希值。</p>\n</li>\n<li><p>这样可以保证哈希值相同，落到相同的节点上。但是key又是不同的，不会互相覆盖。使用哈希标签把一组相关的key关联了起来，问题就这样被轻松愉快地解决了。</p>\n</li>\n<li><p>相信你已经发现了，要解决问题靠的是巧妙的奇思妙想，而不是非要用牛逼的技术牛逼的算法。这就是小强，小而强大。</p>\n</li>\n<li><p>最后再来谈选择的哲学。redis的核心就是以最快的速度进行常用数据结构的key/value存取，以及围绕这些数据结构的运算。对于与核心无关的或会拖累核心的都选择弱化处理或不处理，这样做是为了保证核心的简单、快速和稳定。</p>\n</li>\n<li><p>其实就是在广度和深度面前，redis选择了深度。所以节点不去处理自己不拥有的key，集群不去支持多key命令。这样一方面可以快速地响应客户端，另一方面可以避免在集群内部有大量的数据传输与合并。</p>\n</li>\n</ul>\n<h1 id=\"单线程模型\"><a href=\"#单线程模型\" class=\"headerlink\" title=\"单线程模型\"></a>单线程模型</h1><ul>\n<li>redis集群的每个节点里只有一个线程负责接受和执行所有客户端发送的请求。技术上使用多路复用I/O，使用Linux的epoll函数，这样一个线程就可以管理很多socket连接。</li>\n</ul>\n<p>除此之外，选择单线程还有以下这些原因：</p>\n<p>1、redis都是对内存的操作，速度极快（10W+QPS）</p>\n<p>2、整体的时间主要都是消耗在了网络的传输上</p>\n<p>3、如果使用了多线程，则需要多线程同步，这样实现起来会变的复杂</p>\n<p>4、线程的加锁时间甚至都超过了对内存操作的时间</p>\n<p>5、多线程上下文频繁的切换需要消耗更多的CPU时间</p>\n<p>6、还有就是单线程天然支持原子操作，而且单线程的代码写起来更简单</p>\n<h1 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h1><p>事务大家都知道，就是把多个操作捆绑在一起，要么都执行（成功了），要么一个也不执行（回滚了）。redis也是支持事务的，但可能和你想要的不太一样，一起来看看吧。</p>\n<ul>\n<li>redis的事务可以分为两步，<strong>定义事务和执行事务</strong>。使用multi命令开启一个事务，然后把要执行的所有命令都依次排上去。这就定义好了一个事务。此时使用exec命令来执行这个事务，或使用discard命令来放弃这个事务。</li>\n<li>你可能希望在你的事务开始前，你关心的key不想被别人操作，那么可以使用watch命令来监视这些key，如果开始执行前这些key被其它命令操作了则会取消事务的。也可以使用unwatch命令来取消对这些key的监视。</li>\n</ul>\n<p>redis事务具有以下特点：</p>\n<p>1、如果开始执行事务前出错，则所有命令都不执行</p>\n<p>2、一旦开始，则保证所有命令一次性按顺序执行完而不被打断</p>\n<p>3、如果执行过程中遇到错误，会继续执行下去，不会停止的</p>\n<p>4、对于执行过程中遇到错误，是不会进行回滚的</p>\n<p><strong>看完这些，真想问一句话，你这能叫事务吗？很显然，这并不是我们通常认为的事务，因为它连原子性都保证不了。保证不了原子性是因为redis不支持回滚，不过它也给出了不支持的理由。</strong></p>\n<p>不支持回滚的理由：</p>\n<p>1、redis认为，失败都是由命令使用不当造成</p>\n<p>2、redis这样做，是为了保持内部实现简单快速</p>\n<p>3、redis还认为，回滚并不能解决所有问题</p>\n<p>哈哈，这就是霸王条款，因此，好像使用redis事务的不太多</p>\n<h1 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h1><ul>\n<li>客户端和集群的交互过程是串行化阻塞式的，即客户端发送了一个命令后必须等到响应回来后才能发第二个命令，这一来一回就是一个往返时间。如果你有很多的命令，都这样一个一个的来进行，会变得很慢。</li>\n<li>redis提供了一种管道技术，可以让客户端一次发送多个命令，期间不需要等待服务器端的响应，等所有的命令都发完了，再依次接收这些命令的全部响应。这就极大地节省了许多时间，提升了效率。</li>\n<li>聪明的你是不是意识到了另外一个问题，多个命令就是多个key啊，这不就是上面提到的多key操作嘛，那么问题来了，你如何保证这多个key都是同一个节点上的啊，哈哈，redis集群又放弃了对管道的支持。</li>\n<li>不过可以在客户端模拟实现，就是使用多个连接往多个节点同时发送命令，然后等待所有的节点都返回了响应，再把它们按照发送命令的顺序整理好，返回给用户代码。哎呀，好麻烦呀。</li>\n</ul>\n<h1 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h1><p>简单了解下redis的协议，知道redis的数据传输格式。</p>\n<p>发送请求的协议：</p>\n<ul>\n<li>参数个数CRLF<img src=\"https://juejin.im/equation?tex=%E5%8F%82%E6%95%B01%E7%9A%84%E5%AD%97%E8%8A%82%E6%95%B0CRLF%E5%8F%82%E6%95%B01%E7%9A%84%E6%95%B0%E6%8D%AECRLF...\" alt=\"参数1的字节数CRLF参数1的数据CRLF...\">参数N的字节数CRLF参数N的数据CRLF</li>\n</ul>\n<p>例如，SET name lixinjie，实际发送的数据是：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*3\\r\\n$3\\r\\nSET\\r\\n$4\\r\\nname\\r\\n$8\\r\\nlixinjie\\r\\n</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>接受响应的协议</strong>：</p>\n<ul>\n<li>单行回复，第一个字节是+</li>\n<li>错误消息，第一个字节是-</li>\n<li>整型数字，第一个字节是:</li>\n<li>批量回复，第一个字节是$</li>\n<li>多个批量回复，第一个字节是/*</li>\n</ul>\n<p>例如，</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+OK\\r\\n</span><br><span class=\"line\"></span><br><span class=\"line\">-ERR Operation against\\r\\n</span><br><span class=\"line\"></span><br><span class=\"line\">:1000\\r\\n</span><br><span class=\"line\"></span><br><span class=\"line\">$6\\r\\nfoobar\\r\\n</span><br><span class=\"line\"></span><br><span class=\"line\">*2\\r\\n$3\\r\\nfoo\\r\\n$3\\r\\nbar\\r\\n</span><br></pre></td></tr></table></figure></div>\n\n<p>可见redis的协议设计的非常简单。</p>\n<hr>\n<p><strong>本文的重点是你有没有收获与成长，其余的都不重要，希望读者们能谨记这一点。同时我经过多年的收藏目前也算收集到了一套完整的学习资料，包括但不限于：分布式架构、高可扩展、高性能、高并发、Jvm性能调优、Spring，MyBatis，Nginx源码分析，Redis，ActiveMQ、、Mycat、Netty、Kafka、Mysql、Zookeeper、Tomcat、Docker、Dubbo、Nginx等多个知识点高级进阶干货，希望对想成为架构师的朋友有一定的参考和帮助</strong></p>\n<p><strong>需要更详细思维导图和以下资料的可以加一下技术交流分享群：“708 701 457”免费获取</strong></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/30/16a6a90239d4db4a?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/30/16a6a905f7393bc9?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n","text":"本文来自于 https://juejin.im/post/5cc6bb975188252e8925f0c8 是数据结构而非类型很多文章都会说，redis支持5种常用的数据类型，这其实是存在很大的歧义。redis里存的都是二进制数据，其实就是字节数组（byte[]），这些字节数据是","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]},{"title":"从模板方法模式到JDBCTemplate","slug":"从模板方法模式到JDBCTemplate","date":"2019-05-22T14:33:24.024Z","updated":"2019-05-30T00:52:25.419Z","comments":true,"pin":null,"path":"api/articles/从模板方法模式到JDBCTemplate.json","excerpt":"","keywords":null,"cover":"https://user-gold-cdn.xitu.io/2019/5/21/16ad9448cb69de5e?imageView2/0/w/1280/h/960/ignore-error/1","content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5cdb7f4af265da037371aa1f\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5cdb7f4af265da037371aa1f</a><br>将大象装进冰箱需要三步，那么老虎了？如何优雅的将大象装进冰箱？</p>\n</blockquote>\n<h3 id=\"把大象装进冰箱\"><a href=\"#把大象装进冰箱\" class=\"headerlink\" title=\"把大象装进冰箱\"></a>把大象装进冰箱</h3><table>\n<thead>\n<tr>\n<th align=\"center\">Step</th>\n<th align=\"center\">大象</th>\n<th align=\"center\">老虎</th>\n<th align=\"center\">…</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">First</td>\n<td align=\"center\">打开冰箱门</td>\n<td align=\"center\">打开冰箱门</td>\n<td align=\"center\">打开冰箱门</td>\n</tr>\n<tr>\n<td align=\"center\">Second</td>\n<td align=\"center\">把大象放进去</td>\n<td align=\"center\">把老虎放进去</td>\n<td align=\"center\">…</td>\n</tr>\n<tr>\n<td align=\"center\">Third</td>\n<td align=\"center\">关闭冰箱门</td>\n<td align=\"center\">关闭冰箱门</td>\n<td align=\"center\">关闭冰箱门</td>\n</tr>\n</tbody></table>\n<p><strong><em>大象类</em></strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Elephant &#123;</span><br><span class=\"line\">        public void putRefrigerator() &#123;</span><br><span class=\"line\">            openDoor();</span><br><span class=\"line\">            putElephant();</span><br><span class=\"line\">            closeDoor();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public void openDoor() &#123;</span><br><span class=\"line\">            System.out.println(&quot;open the door&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public void putElephant() &#123;</span><br><span class=\"line\">            System.out.println(&quot;put in the Elephant&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public void closeDoor() &#123;</span><br><span class=\"line\">            System.out.println(&quot;close the door&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p><strong><em>老虎类</em></strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Tiger &#123;</span><br><span class=\"line\">        public void putRefrigerator() &#123;</span><br><span class=\"line\">            openDoor();</span><br><span class=\"line\">            putTiger();</span><br><span class=\"line\">            closeDoor();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public void openDoor() &#123;</span><br><span class=\"line\">            System.out.println(&quot;open the door&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public void putTiger() &#123;</span><br><span class=\"line\">            System.out.println(&quot;put in the Tiger&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public void closeDoor() &#123;</span><br><span class=\"line\">            System.out.println(&quot;close the door&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>可以看出我们将大象和老虎放进冰箱的过程中出现了大量的重复代码，这显然不是一个好的设计，如果我们在以后的系统升级过程中需要再放入长颈鹿怎么办，我们应该如何从我们的设计中删除这些重复代码？通过观察我们发现放大象和放老虎之间有很多共同点，都需要进行开关门的操作，只是放的过程不尽相同，我们是否可以将共同点抽离？我们一起试试看</p>\n<p><strong><em>抽象超类</em></strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class AbstractPutAnyAnimal &#123;</span><br><span class=\"line\">        //这是一个模板方法，它是一个算法的模板，描述我们将动物放进冰箱的步骤，每一个方法代表了一个步骤</span><br><span class=\"line\">        public void putRefrigerator() &#123;</span><br><span class=\"line\">            openDoor();</span><br><span class=\"line\">            putAnyAnimal();</span><br><span class=\"line\">            closeDoor();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //在超类中实现共同的方法，由超类来处理</span><br><span class=\"line\">        public void openDoor() &#123;</span><br><span class=\"line\">            System.out.println(&quot;open the door&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public void closeDoor() &#123;</span><br><span class=\"line\">            System.out.println(&quot;close the door&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //每个子类可能有不同的方法,我们定义成抽象方法让子类去实现</span><br><span class=\"line\">        abstract void putAnyAnimal();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p><strong><em>大象类</em></strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Elephant extends AbstractPutAnyAnimal &#123;</span><br><span class=\"line\">        //子类实现自己的业务逻辑</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        void putAnyAnimal() &#123;</span><br><span class=\"line\">            System.out.println(&quot;put in the Elephant&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p><strong><em>老虎类</em></strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Tiger extends AbstractPutAnyAnimal &#123;</span><br><span class=\"line\">        //子类实现自己的业务逻辑</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        void putAnyAnimal() &#123;</span><br><span class=\"line\">            System.out.println(&quot;put in the Tiger&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>通过将相同的方法抽离到超类中，并定义一个抽象方法供子类提供不同的实现，事实上我们刚刚实现了一个模板方法模式。</p>\n<h3 id=\"模板方法模式定义？\"><a href=\"#模板方法模式定义？\" class=\"headerlink\" title=\"模板方法模式定义？\"></a>模板方法模式定义？</h3><p><strong>模板方法模式定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现</strong>，putRefrigerator 方法定义了我们将大象装进冰箱的步骤它就是一个模板方法。<strong>模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不在改变算法结构的情况下，重新定义算法的某些步骤</strong>（子类提供自己的实现）</p>\n<h3 id=\"模板方法模式中的钩子\"><a href=\"#模板方法模式中的钩子\" class=\"headerlink\" title=\"模板方法模式中的钩子\"></a>模板方法模式中的钩子</h3><p>我们可以在超类中定义一个空方法，我们称这种方法为钩子（hook）。子类可以依据情况选择覆盖，钩子的存在可以让子类有能力对算法的不同点进行挂载；<strong>钩子可以让子类实现算法中的可选部分，钩子也可以让子类为抽象类做一些决定</strong>我们将大象装进冰箱后可能会想调整冰箱温度，也可能什么都不做使用默认温度，我们可以通过定义一个钩子，让子类来选择是否调整温度，如下：</p>\n<p><strong><em>抽象父类</em></strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class AbstractPutAnyAnimal &#123;</span><br><span class=\"line\">        public void putRefrigerator() &#123;</span><br><span class=\"line\">            openDoor();</span><br><span class=\"line\">            putAnyAnimal();</span><br><span class=\"line\">            closeDoor();</span><br><span class=\"line\">            //默认为false,重新这个方法决定是否执行addTemperature();方法</span><br><span class=\"line\">            if (isAdd()) &#123;</span><br><span class=\"line\">                addTemperature();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public void openDoor() &#123;</span><br><span class=\"line\">            System.out.println(&quot;open the door&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public void closeDoor() &#123;</span><br><span class=\"line\">            System.out.println(&quot;close the door&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        abstract void putAnyAnimal();</span><br><span class=\"line\">        void addTemperature()&#123;</span><br><span class=\"line\">            System.out.println(&quot;plus one&quot;);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        //定义一个空实现，由子类决定是否对其进行实现</span><br><span class=\"line\">        boolean isAdd()&#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p><strong><em>大象类</em></strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Elephant extends AbstractPutAnyAnimal &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        void putAnyAnimal() &#123;</span><br><span class=\"line\">            System.out.println(&quot;put in the Elephant&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //子类实现钩子方法</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        boolean isAdd() &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>我们通过定义一个钩子方法，子类选择是否实现这个钩子方法，来决定是否调整温度；当然钩子方法的用途不止如此，<strong>它还能让子类有机会对模板中即将发生或刚刚发生的步骤做出反应</strong>，这在JDK中有很多的例子，甚至在前端开发领域也有很多例子，我就不具体展开代码演示了，后面在模板方法模式的更多应用中展开。</p>\n<p>JDK以及Spring中使用了很多的设计模式，下面我们通过比较传统JDBC编程和JDBCTemplate来看看模板方法模式是如何帮我们消除样板代码的</p>\n<h3 id=\"传统JDBC编程\"><a href=\"#传统JDBC编程\" class=\"headerlink\" title=\"传统JDBC编程\"></a>传统JDBC编程</h3><p><strong><em>JDBC编程之新增</em></strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String driver = &quot;com.mysql.jdbc.Driver&quot;;</span><br><span class=\"line\">        String url = &quot;jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8&amp;amp;useSSL=true&quot;;</span><br><span class=\"line\">        String username = &quot;root&quot;;</span><br><span class=\"line\">        String password = &quot;1234&quot;;</span><br><span class=\"line\">        Connection connection = null;</span><br><span class=\"line\">        Statement statement = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Class.forName(driver);</span><br><span class=\"line\">            connection = DriverManager.getConnection(url, username, password);</span><br><span class=\"line\">            String sql = &quot;insert into users(nickname,comment,age) values(&apos;小小谭&apos;,&apos;I love three thousand times&apos;, &apos;21&apos;)&quot;;</span><br><span class=\"line\">            statement = connection.createStatement();</span><br><span class=\"line\">            int i = statement.executeUpdate(sql);</span><br><span class=\"line\">            return i;</span><br><span class=\"line\">        &#125; catch (SQLException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                if (null != statement) &#123;</span><br><span class=\"line\">                    statement.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (null != connection) &#123;</span><br><span class=\"line\">                    connection.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; catch (SQLException e) &#123;</span><br><span class=\"line\">                throw new RuntimeException(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return 0;</span><br></pre></td></tr></table></figure></div>\n\n<p><strong><em>JDBC编程之查询</em></strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String driver = &quot;com.mysql.jdbc.Driver&quot;;</span><br><span class=\"line\">        String url = &quot;jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8&amp;amp;useSSL=true&quot;;</span><br><span class=\"line\">        String username = &quot;root&quot;;</span><br><span class=\"line\">        String password = &quot;1234&quot;;</span><br><span class=\"line\">        Connection connection = null;</span><br><span class=\"line\">        Statement statement = null;</span><br><span class=\"line\">        try&#123;</span><br><span class=\"line\">            Class.forName(driver);</span><br><span class=\"line\">            connection = DriverManager.getConnection(url, username, password);</span><br><span class=\"line\">            String sql = &quot;select nickname,comment,age from users&quot;;</span><br><span class=\"line\">            statement = connection.createStatement();</span><br><span class=\"line\">            ResultSet resultSet = statement.executeQuery(sql);</span><br><span class=\"line\">            List&lt;Users&gt; usersList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">            while (resultSet.next()) &#123;</span><br><span class=\"line\">                Users users = new Users();</span><br><span class=\"line\">                users.setNickname(resultSet.getString(1));</span><br><span class=\"line\">                users.setComment(resultSet.getString(2));</span><br><span class=\"line\">                users.setAge(resultSet.getInt(3));</span><br><span class=\"line\">                usersList.add(users);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return usersList;</span><br><span class=\"line\">        &#125; catch (SQLException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                if (null != statement) &#123;</span><br><span class=\"line\">                    statement.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (null != connection) &#123;</span><br><span class=\"line\">                    connection.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; catch (SQLException e) &#123;</span><br><span class=\"line\">                throw new RuntimeException(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return null;</span><br></pre></td></tr></table></figure></div>\n\n<p>上面给出了我们在传统JDBC编程中的两个案例，可以看到传统JDBC的很多缺点，当然在实际项目中我们可能不会这么原始的进行数据库开发，可能会对JDBC进行一定的封装，方便我们的使用。Spring 官方为了简化JDBC的开发也发布了JDBCTemplate，下面我们就看一下它是如何简化开发的，以及模板方法模式在其中的应用</p>\n<h3 id=\"JDBCTemplate是个啥，它到底简化了什么？\"><a href=\"#JDBCTemplate是个啥，它到底简化了什么？\" class=\"headerlink\" title=\"JDBCTemplate是个啥，它到底简化了什么？\"></a>JDBCTemplate是个啥，它到底简化了什么？</h3><p>从JDBCTemplate的名字我们就不难看出，它简化了我们JDBC的开发，而且很可能大量应用了模板方法模式，它到底为我们提供了什么？<strong>它提供了与平台无光的异常处理机制</strong>。使用过原生JDBC开发的同学可能有经历，几乎所有的操作代码都需要我们强制捕获异常，但是在出现异常时我们往往无法通过异常读懂错误。Spring解决了我们的问题它<strong>提供了多个数据访问异常，并且分别描述了他们抛出时对应的问题，同时对异常进行了包装不强制要求我们进行捕获，同时它为我们提供了数据访问的模板化</strong>，从上面的传统JDBC编程我们可以发现，很多操作其实是重复的不变得比如事务控制、资源的获取关闭以及异常处理等，同时结果集的处理实体的绑定，参数的绑定这些东西都是特有的。因此<strong>Spring将数据访问过程中固定部分和可变部分划分为了两个不同的类(Template)和回调(Callback),模板处理过程中不变得部分，回调处理自定义的访问代码</strong>；下面我们具体通过源码来学学习一下</p>\n<h3 id=\"模板方法模式在JDBCTemplate中的应用\"><a href=\"#模板方法模式在JDBCTemplate中的应用\" class=\"headerlink\" title=\"模板方法模式在JDBCTemplate中的应用\"></a>模板方法模式在JDBCTemplate中的应用</h3><p>我所使用的版本是5.1.5.RELEASE</p>\n<p>打开JdbcTemplate类(我这里就不截图了，截图可能不清晰我直接将代码copy出来)：</p>\n<p><strong><em>JdbcTemplate</em></strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class JdbcTemplate extends JdbcAccessor implements JdbcOperations &#123;</span><br><span class=\"line\">        //查询前缀</span><br><span class=\"line\">        private static final String RETURN_RESULT_SET_PREFIX = &quot;#result-set-&quot;;</span><br><span class=\"line\">        //计数前缀</span><br><span class=\"line\">        private static final String RETURN_UPDATE_COUNT_PREFIX = &quot;#update-count-&quot;;</span><br><span class=\"line\">        //是否跳过警告</span><br><span class=\"line\">        private boolean ignoreWarnings = true;</span><br><span class=\"line\">        //查询大小</span><br><span class=\"line\">        private int fetchSize = -1;</span><br><span class=\"line\">        //最大行</span><br><span class=\"line\">        private int maxRows = -1;</span><br><span class=\"line\">        //查询超时</span><br><span class=\"line\">        private int queryTimeout = -1;</span><br><span class=\"line\">        //是否跳过结果集处理</span><br><span class=\"line\">        private boolean skipResultsProcessing = false;</span><br><span class=\"line\">        //是否跳过非公共结果集处理</span><br><span class=\"line\">        private boolean skipUndeclaredResults = false;</span><br><span class=\"line\">        //map结果集是否大小写敏感</span><br><span class=\"line\">        private boolean resultsMapCaseInsensitive = false;</span><br><span class=\"line\">    </span><br><span class=\"line\">        public JdbcTemplate() &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //调用父类方法设置数据源和其他参数</span><br><span class=\"line\">        public JdbcTemplate(DataSource dataSource) &#123;</span><br><span class=\"line\">            this.setDataSource(dataSource);</span><br><span class=\"line\">            this.afterPropertiesSet();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //调用父类方法设置数据源，懒加载策略和其他参数</span><br><span class=\"line\">        public JdbcTemplate(DataSource dataSource, boolean lazyInit) &#123;</span><br><span class=\"line\">            this.setDataSource(dataSource);</span><br><span class=\"line\">            this.setLazyInit(lazyInit);</span><br><span class=\"line\">            this.afterPropertiesSet();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>JdbcTemplate 继承了JdbcAccessor实现了JdbcOperations，JdbcAccessor主要封装了数据源的操作，JdbcOperations主要定义了一些操作接口。我们一起看一下JdbcOperations类；</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class JdbcAccessor implements InitializingBean &#123;</span><br><span class=\"line\">        protected final Log logger = LogFactory.getLog(this.getClass());</span><br><span class=\"line\">        //数据源</span><br><span class=\"line\">        @Nullable</span><br><span class=\"line\">        private DataSource dataSource;</span><br><span class=\"line\">        //异常翻译</span><br><span class=\"line\">        @Nullable</span><br><span class=\"line\">        private volatile SQLExceptionTranslator exceptionTranslator;</span><br><span class=\"line\">        //懒加载策略</span><br><span class=\"line\">        private boolean lazyInit = true;</span><br><span class=\"line\">        public JdbcAccessor() &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public void setDataSource(@Nullable DataSource dataSource) &#123;</span><br><span class=\"line\">            this.dataSource = dataSource;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        @Nullable</span><br><span class=\"line\">        public DataSource getDataSource() &#123;</span><br><span class=\"line\">            return this.dataSource;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        protected DataSource obtainDataSource() &#123;</span><br><span class=\"line\">            DataSource dataSource = this.getDataSource();</span><br><span class=\"line\">            Assert.state(dataSource != null, &quot;No DataSource set&quot;);</span><br><span class=\"line\">            return dataSource;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public void setDatabaseProductName(String dbName) &#123;</span><br><span class=\"line\">            this.exceptionTranslator = new SQLErrorCodeSQLExceptionTranslator(dbName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public void setExceptionTranslator(SQLExceptionTranslator exceptionTranslator) &#123;</span><br><span class=\"line\">            this.exceptionTranslator = exceptionTranslator;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>之所以<strong>前面提到spring让我们更方便的处理异常就是这里他包装了一个SQLExceptionTranslator</strong>，其他的代码都是做数据源的检查之类的设置数据源，我们看一下其中getExceptionTranslator()方法</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public SQLExceptionTranslator getExceptionTranslator() &#123;</span><br><span class=\"line\">        SQLExceptionTranslator exceptionTranslator = this.exceptionTranslator;</span><br><span class=\"line\">        if (exceptionTranslator != null) &#123;</span><br><span class=\"line\">            return exceptionTranslator;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            synchronized(this) &#123;</span><br><span class=\"line\">                SQLExceptionTranslator exceptionTranslator = this.exceptionTranslator;</span><br><span class=\"line\">                if (exceptionTranslator == null) &#123;</span><br><span class=\"line\">                    DataSource dataSource = this.getDataSource();</span><br><span class=\"line\">                    if (dataSource != null) &#123;</span><br><span class=\"line\">                        exceptionTranslator = new SQLErrorCodeSQLExceptionTranslator(dataSource);</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        exceptionTranslator = new SQLStateSQLExceptionTranslator();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    this.exceptionTranslator = (SQLExceptionTranslator)exceptionTranslator;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                return (SQLExceptionTranslator)exceptionTranslator;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>这是一个标准的单例模式，我们在学习模板方法模式的路途中有捕获了一个野生的单例；我们继续看JdbcOperations接口我们调其中一个接口进行解析；</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Nullable</span><br><span class=\"line\">    &lt;T&gt; T execute(StatementCallback&lt;T&gt; var1) throws DataAccessException;</span><br></pre></td></tr></table></figure></div>\n\n<p><strong><em>StatementCallback 接口</em></strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FunctionalInterface</span><br><span class=\"line\">    public interface StatementCallback&lt;T&gt; &#123;</span><br><span class=\"line\">        @Nullable</span><br><span class=\"line\">        T doInStatement(Statement var1) throws SQLException, DataAccessException;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p><strong><em>execute实现</em></strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Nullable</span><br><span class=\"line\">    public &lt;T&gt; T execute(StatementCallback&lt;T&gt; action) throws DataAccessException &#123;</span><br><span class=\"line\">        //参数检查</span><br><span class=\"line\">        Assert.notNull(action, &quot;Callback object must not be null&quot;);</span><br><span class=\"line\">        //获取连接</span><br><span class=\"line\">        Connection con = DataSourceUtils.getConnection(this.obtainDataSource());</span><br><span class=\"line\">        Statement stmt = null;</span><br><span class=\"line\">        Object var11;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            //创建一个Statement</span><br><span class=\"line\">            stmt = con.createStatement();</span><br><span class=\"line\">            //设置查询超时时间，最大行等参数（就是一开始那些成员变量）</span><br><span class=\"line\">            this.applyStatementSettings(stmt);</span><br><span class=\"line\">            //执行回调方法获取结果集</span><br><span class=\"line\">            T result = action.doInStatement(stmt);</span><br><span class=\"line\">            //处理警告</span><br><span class=\"line\">            this.handleWarnings(stmt);</span><br><span class=\"line\">            var11 = result;</span><br><span class=\"line\">        &#125; catch (SQLException var9) &#123;</span><br><span class=\"line\">            //出现错误优雅退出</span><br><span class=\"line\">            String sql = getSql(action);</span><br><span class=\"line\">            JdbcUtils.closeStatement(stmt);</span><br><span class=\"line\">            stmt = null;</span><br><span class=\"line\">            DataSourceUtils.releaseConnection(con, this.getDataSource());</span><br><span class=\"line\">            con = null;</span><br><span class=\"line\">            throw this.translateException(&quot;StatementCallback&quot;, sql, var9);</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            JdbcUtils.closeStatement(stmt);</span><br><span class=\"line\">            DataSourceUtils.releaseConnection(con, this.getDataSource());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return var11;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>这一个方法可谓是展现的淋漓尽致，这是一个典型的模板方法+回调模式，我们不需要再写过多的重复代码只需要实现自己获取result的方法就好（StatementCallback）事实上我们自己也不需要实现这个方法，继续向上看，我们是如何调用execute方法的，以查询为例,我们看他是如何一步步调用的：</p>\n<p><strong><em>查询方法</em></strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;Users&gt; findAll() &#123;</span><br><span class=\"line\">        JdbcTemplate jdbcTemplate = DataSourceConfig.getTemplate();</span><br><span class=\"line\">        String sql = &quot;select nickname,comment,age from users&quot;;</span><br><span class=\"line\">        return jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;Users&gt;(Users.class));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p><strong><em>query实现</em></strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper) throws DataAccessException &#123;</span><br><span class=\"line\">        return (List)result(this.query((String)sql, (ResultSetExtractor)(new RowMapperResultSetExtractor(rowMapper))));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>这里的RowMapper是负责将结果集中一行的数据映射成实体返回，用到了反射技术，这里就不展开了，有兴趣的同学可以自己打开源码阅读，继续向下：</p>\n<p><strong><em>query实现</em></strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Nullable</span><br><span class=\"line\">    public &lt;T&gt; T query(final String sql, final ResultSetExtractor&lt;T&gt; rse) throws DataAccessException &#123;</span><br><span class=\"line\">        Assert.notNull(sql, &quot;SQL must not be null&quot;);</span><br><span class=\"line\">        Assert.notNull(rse, &quot;ResultSetExtractor must not be null&quot;);</span><br><span class=\"line\">        if (this.logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">            this.logger.debug(&quot;Executing SQL query [&quot; + sql + &quot;]&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //实现回调接口</span><br><span class=\"line\">        class QueryStatementCallback implements StatementCallback&lt;T&gt;, SqlProvider &#123;</span><br><span class=\"line\">            QueryStatementCallback() &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            @Nullable</span><br><span class=\"line\">            public T doInStatement(Statement stmt) throws SQLException &#123;</span><br><span class=\"line\">                ResultSet rs = null;</span><br><span class=\"line\">                Object var3;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    //这里真正的执行我们的sql语句</span><br><span class=\"line\">                    rs = stmt.executeQuery(sql);</span><br><span class=\"line\">                    //处理对象映射</span><br><span class=\"line\">                    var3 = rse.extractData(rs);</span><br><span class=\"line\">                &#125; finally &#123;</span><br><span class=\"line\">                    JdbcUtils.closeResultSet(rs);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                return var3;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            public String getSql() &#123;</span><br><span class=\"line\">                return sql;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //调用execute接口</span><br><span class=\"line\">        return this.execute((StatementCallback)(new QueryStatementCallback()));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>看到这里相信你也不得拍手称奇，Spring处理的非常巧妙，请继续向下看：</p>\n<p><strong><em>update详解</em></strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected int update(PreparedStatementCreator psc, @Nullable PreparedStatementSetter pss) throws DataAccessException &#123;</span><br><span class=\"line\">        this.logger.debug(&quot;Executing prepared SQL update&quot;);</span><br><span class=\"line\">        return updateCount((Integer)this.execute(psc, (ps) -&gt; &#123;</span><br><span class=\"line\">            Integer var4;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                if (pss != null) &#123;</span><br><span class=\"line\">                    pss.setValues(ps);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                int rows = ps.executeUpdate();</span><br><span class=\"line\">                if (this.logger.isTraceEnabled()) &#123;</span><br><span class=\"line\">                    this.logger.trace(&quot;SQL update affected &quot; + rows + &quot; rows&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                var4 = rows;</span><br><span class=\"line\">            &#125; finally &#123;</span><br><span class=\"line\">                if (pss instanceof ParameterDisposer) &#123;</span><br><span class=\"line\">                    ((ParameterDisposer)pss).cleanupParameters();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return var4;</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>为什么我要把update函数拎出来讲了，因为update这里使用了lambda函数,回想我们StatementCallback定义只有一个方法的接口，他就是一个函数是接口，所以他是一个函数式接口，所以这里直接使用lambda语法，<strong>lambda函数允许你直接内连，为函数接口的抽象方法提供实现，并且整个表达式作为函数接口的一个实例</strong>。我们在平时学习中可能知道了lambda语法但是可能使用的较少，或者不知道如何用于实战，那么多阅读源码一定可以提升你的实战能力。 我们可以看到JDBCTemplate使用了很多回调。为什么要用回调（Callback)?<strong>如果父类有多个抽象方法，子类需要全部实现这样特别麻烦，而有时候某个子类只需要定制父类中的某一个方法该怎么办呢？这个时候就要用到Callback回调了就可以完美解决这个问题</strong>，可以发现JDBCTemplate并没有完全拘泥于模板方法，非常灵活。我们在实际开发中也可以借鉴这种方法。</p>\n<h3 id=\"模板方法模式的更多应用\"><a href=\"#模板方法模式的更多应用\" class=\"headerlink\" title=\"模板方法模式的更多应用\"></a>模板方法模式的更多应用</h3><p>事实上很多有关生命周期的类都用到了模板方法模式，最典型的也是可能我们最熟悉的莫过于Servlet了，废话不多说上源码</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class HttpServlet extends GenericServlet</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/21/16ad9448cb69de5e?imageView2/0/w/1280/h/960/ignore-error/1\" alt> HttpServlet的所有方法，我们看到HttpServlet继承了GenericServlet，我们继续看：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class GenericServlet </span><br><span class=\"line\">    implements Servlet, ServletConfig, java.io.Serializable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    private static final String LSTRING_FILE = &quot;javax.servlet.LocalStrings&quot;;</span><br><span class=\"line\">    private static ResourceBundle lStrings =</span><br><span class=\"line\">        ResourceBundle.getBundle(LSTRING_FILE);</span><br><span class=\"line\"></span><br><span class=\"line\">    private transient ServletConfig config;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public GenericServlet() &#123; &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //没有实现钩子</span><br><span class=\"line\">    public void destroy() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public String getInitParameter(String name) &#123;</span><br><span class=\"line\">        ServletConfig sc = getServletConfig();</span><br><span class=\"line\">        if (sc == null) &#123;</span><br><span class=\"line\">            throw new IllegalStateException(</span><br><span class=\"line\">                lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return sc.getInitParameter(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public Enumeration&lt;String&gt; getInitParameterNames() &#123;</span><br><span class=\"line\">        ServletConfig sc = getServletConfig();</span><br><span class=\"line\">        if (sc == null) &#123;</span><br><span class=\"line\">            throw new IllegalStateException(</span><br><span class=\"line\">                lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return sc.getInitParameterNames();</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">     </span><br><span class=\"line\">    public ServletConfig getServletConfig() &#123;</span><br><span class=\"line\">\treturn config;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public ServletContext getServletContext() &#123;</span><br><span class=\"line\">        ServletConfig sc = getServletConfig();</span><br><span class=\"line\">        if (sc == null) &#123;</span><br><span class=\"line\">            throw new IllegalStateException(</span><br><span class=\"line\">                lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return sc.getServletContext();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getServletInfo() &#123;</span><br><span class=\"line\">\treturn &quot;&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void init(ServletConfig config) throws ServletException &#123;</span><br><span class=\"line\">\tthis.config = config;</span><br><span class=\"line\">\tthis.init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public void init() throws ServletException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public void log(String msg) &#123;</span><br><span class=\"line\">\tgetServletContext().log(getServletName() + &quot;: &quot;+ msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    public void log(String message, Throwable t) &#123;</span><br><span class=\"line\">\tgetServletContext().log(getServletName() + &quot;: &quot; + message, t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public abstract void service(ServletRequest req, ServletResponse res)</span><br><span class=\"line\">\tthrows ServletException, IOException;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public String getServletName() &#123;</span><br><span class=\"line\">        ServletConfig sc = getServletConfig();</span><br><span class=\"line\">        if (sc == null) &#123;</span><br><span class=\"line\">            throw new IllegalStateException(</span><br><span class=\"line\">                lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return sc.getServletName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>可以看到这就是个典型的模板方法类蛮，而且钩子函数也在这里展现的淋漓尽致，如init、destroy方法等，JDK中很多类都是用了模板方法等着你发现哦。</p>\n<h3 id=\"模板方法模式在Vue-js中的应用\"><a href=\"#模板方法模式在Vue-js中的应用\" class=\"headerlink\" title=\"模板方法模式在Vue.js中的应用\"></a>模板方法模式在Vue.js中的应用</h3><p>模板方法模式在其他语言中也有实现比如Vue.js、React中；比如Vue生命周期肯定使用了模板方法，我就不对源码展开分析了。<br><img src=\"https://user-gold-cdn.xitu.io/2019/5/21/16ad94b7aa8bb518?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>设计模式在Spring中得到了大量的应用，感兴趣的同学可以看看Spring源码加以学习，如果你觉得我写的还不错的话点个赞吧，如果你发现了错误，或者不好的地方也可以及时告诉我加以改正，谢谢！您的赞赏和批评是进步路上的好伙伴。</p>\n","text":"本文转载自 https://juejin.im/post/5cdb7f4af265da037371aa1f<br>将大象装进冰箱需要三步，那么老虎了？如何优雅的将大象装进冰箱？把大象装进冰箱Step大象老虎…First打开冰箱门打开冰箱门打开冰箱门Second把大象放进去把老虎放","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]},{"title":"SpringBoot实现动态控制定时任务-支持多参数","slug":"SpringBoot实现动态控制定时任务-支持多参数","date":"2019-06-01T15:51:17.017Z","updated":"2019-06-01T15:51:17.456Z","comments":true,"pin":null,"path":"api/articles/SpringBoot实现动态控制定时任务-支持多参数.json","excerpt":"","keywords":null,"cover":"https://user-gold-cdn.xitu.io/2019/5/31/16b0be286b6a031a?imageView2/0/w/1280/h/960/ignore-error/1","content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5cf099556fb9a07ef2010716\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5cf099556fb9a07ef2010716</a><br>由于工作上的原因，需要进行定时任务的动态增删改查，网上大部分资料都是整合quertz框架实现的。本人查阅了一些资料，发现springBoot本身就支持实现定时任务的动态控制。并进行改进，现支持任意多参数定时任务配置</p>\n</blockquote>\n<p>实现结果如下图所示：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/31/16b0be286b6a031a?imageView2/0/w/1280/h/960/ignore-error/1\" alt> 后台测试显示如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/31/16b0bf1a0e118b4b?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p>github 简单demo地址如下： <a href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fcaotinging%2Fsimple-demo%2Ftree%2Fmaster%2Fspringboot-dynamic-task\" target=\"_blank\" rel=\"noopener\">springboot-dynamic-task</a></p>\n<h3 id=\"1-定时任务的配置类：SchedulingConfig\"><a href=\"#1-定时任务的配置类：SchedulingConfig\" class=\"headerlink\" title=\"1.定时任务的配置类：SchedulingConfig\"></a>1.定时任务的配置类：SchedulingConfig</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.springframework.context.annotation.Bean;</span><br><span class=\"line\">import org.springframework.context.annotation.Configuration;</span><br><span class=\"line\">import org.springframework.scheduling.TaskScheduler;</span><br><span class=\"line\">import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @program: simple-demo</span><br><span class=\"line\"> * @description: 定时任务配置类</span><br><span class=\"line\"> * @author: CaoTing</span><br><span class=\"line\"> * @date: 2019/5/23</span><br><span class=\"line\"> **/</span><br><span class=\"line\">@Configuration</span><br><span class=\"line\">public class SchedulingConfig &#123;</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public TaskScheduler taskScheduler() &#123;</span><br><span class=\"line\">        ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();</span><br><span class=\"line\">        // 定时任务执行线程池核心线程数</span><br><span class=\"line\">        taskScheduler.setPoolSize(4);</span><br><span class=\"line\">        taskScheduler.setRemoveOnCancelPolicy(true);</span><br><span class=\"line\">        taskScheduler.setThreadNamePrefix(&quot;TaskSchedulerThreadPool-&quot;);</span><br><span class=\"line\">        return taskScheduler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"2-定时任务注册类：CronTaskRegistrar\"><a href=\"#2-定时任务注册类：CronTaskRegistrar\" class=\"headerlink\" title=\"2.定时任务注册类：CronTaskRegistrar\"></a>2.定时任务注册类：CronTaskRegistrar</h3><p>这个类包含了新增定时任务，移除定时任务等等核心功能方法<br> <div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import com.caotinging.demo.task.ScheduledTask;</span><br><span class=\"line\">import org.springframework.beans.factory.DisposableBean;</span><br><span class=\"line\">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\">import org.springframework.scheduling.TaskScheduler;</span><br><span class=\"line\">import org.springframework.scheduling.config.CronTask;</span><br><span class=\"line\">import org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\">import java.util.concurrent.ConcurrentHashMap;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @program: simple-demo</span><br><span class=\"line\"> * @description: 添加定时任务注册类，用来增加、删除定时任务。</span><br><span class=\"line\"> * @author: CaoTing</span><br><span class=\"line\"> * @date: 2019/5/23</span><br><span class=\"line\"> **/</span><br><span class=\"line\">@Component</span><br><span class=\"line\">public class CronTaskRegistrar implements DisposableBean &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final Map&lt;Runnable, ScheduledTask&gt; scheduledTasks = new ConcurrentHashMap&lt;&gt;(16);</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private TaskScheduler taskScheduler;</span><br><span class=\"line\"></span><br><span class=\"line\">    public TaskScheduler getScheduler() &#123;</span><br><span class=\"line\">        return this.taskScheduler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 新增定时任务</span><br><span class=\"line\">     * @param task</span><br><span class=\"line\">     * @param cronExpression</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void addCronTask(Runnable task, String cronExpression) &#123;</span><br><span class=\"line\">        addCronTask(new CronTask(task, cronExpression));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void addCronTask(CronTask cronTask) &#123;</span><br><span class=\"line\">        if (cronTask != null) &#123;</span><br><span class=\"line\">            Runnable task = cronTask.getRunnable();</span><br><span class=\"line\">            if (this.scheduledTasks.containsKey(task)) &#123;</span><br><span class=\"line\">                removeCronTask(task);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            this.scheduledTasks.put(task, scheduleCronTask(cronTask));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 移除定时任务</span><br><span class=\"line\">     * @param task</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void removeCronTask(Runnable task) &#123;</span><br><span class=\"line\">        ScheduledTask scheduledTask = this.scheduledTasks.remove(task);</span><br><span class=\"line\">        if (scheduledTask != null)</span><br><span class=\"line\">            scheduledTask.cancel();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public ScheduledTask scheduleCronTask(CronTask cronTask) &#123;</span><br><span class=\"line\">        ScheduledTask scheduledTask = new ScheduledTask();</span><br><span class=\"line\">        scheduledTask.future = this.taskScheduler.schedule(cronTask.getRunnable(), cronTask.getTrigger());</span><br><span class=\"line\"></span><br><span class=\"line\">        return scheduledTask;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void destroy() &#123;</span><br><span class=\"line\">        for (ScheduledTask task : this.scheduledTasks.values()) &#123;</span><br><span class=\"line\">            task.cancel();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        this.scheduledTasks.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div></p>\n<h3 id=\"3-定时任务执行类：SchedulingRunnable\"><a href=\"#3-定时任务执行类：SchedulingRunnable\" class=\"headerlink\" title=\"3.定时任务执行类：SchedulingRunnable\"></a>3.定时任务执行类：SchedulingRunnable</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import com.caotinging.demo.utils.SpringContextUtils;</span><br><span class=\"line\">import org.slf4j.Logger;</span><br><span class=\"line\">import org.slf4j.LoggerFactory;</span><br><span class=\"line\">import org.springframework.util.ReflectionUtils;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.lang.reflect.Method;</span><br><span class=\"line\">import java.util.Objects;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @program: simple-demo</span><br><span class=\"line\"> * @description: 定时任务运行类</span><br><span class=\"line\"> * @author: CaoTing</span><br><span class=\"line\"> * @date: 2019/5/23</span><br><span class=\"line\"> **/</span><br><span class=\"line\">public class SchedulingRunnable implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final Logger logger = LoggerFactory.getLogger(SchedulingRunnable.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    private String beanName;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String methodName;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Object[] params;</span><br><span class=\"line\"></span><br><span class=\"line\">    public SchedulingRunnable(String beanName, String methodName) &#123;</span><br><span class=\"line\">        this(beanName, methodName, null);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public SchedulingRunnable(String beanName, String methodName, Object...params ) &#123;</span><br><span class=\"line\">        this.beanName = beanName;</span><br><span class=\"line\">        this.methodName = methodName;</span><br><span class=\"line\">        this.params = params;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        logger.info(&quot;定时任务开始执行 - bean：&#123;&#125;，方法：&#123;&#125;，参数：&#123;&#125;&quot;, beanName, methodName, params);</span><br><span class=\"line\">        long startTime = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Object target = SpringContextUtils.getBean(beanName);</span><br><span class=\"line\"></span><br><span class=\"line\">            Method method = null;</span><br><span class=\"line\">            if (null != params &amp;amp;&amp;amp; params.length &gt; 0) &#123;</span><br><span class=\"line\">                Class&lt;?&gt;[] paramCls = new Class[params.length];</span><br><span class=\"line\">                for (int i = 0; i &lt; params.length; i++) &#123;</span><br><span class=\"line\">                    paramCls[i] = params[i].getClass();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                method = target.getClass().getDeclaredMethod(methodName, paramCls);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                method = target.getClass().getDeclaredMethod(methodName);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            ReflectionUtils.makeAccessible(method);</span><br><span class=\"line\">            if (null != params &amp;amp;&amp;amp; params.length &gt; 0) &#123;</span><br><span class=\"line\">                method.invoke(target, params);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                method.invoke(target);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (Exception ex) &#123;</span><br><span class=\"line\">            logger.error(String.format(&quot;定时任务执行异常 - bean：%s，方法：%s，参数：%s &quot;, beanName, methodName, params), ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        long times = System.currentTimeMillis() - startTime;</span><br><span class=\"line\">        logger.info(&quot;定时任务执行结束 - bean：&#123;&#125;，方法：&#123;&#125;，参数：&#123;&#125;，耗时：&#123;&#125; 毫秒&quot;, beanName, methodName, params, times);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean equals(Object o) &#123;</span><br><span class=\"line\">        if (this == o) return true;</span><br><span class=\"line\">        if (o == null || getClass() != o.getClass()) return false;</span><br><span class=\"line\">        SchedulingRunnable that = (SchedulingRunnable) o;</span><br><span class=\"line\">        if (params == null) &#123;</span><br><span class=\"line\">            return beanName.equals(that.beanName) &amp;amp;&amp;amp;</span><br><span class=\"line\">                    methodName.equals(that.methodName) &amp;amp;&amp;amp;</span><br><span class=\"line\">                    that.params == null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return beanName.equals(that.beanName) &amp;amp;&amp;amp;</span><br><span class=\"line\">                methodName.equals(that.methodName) &amp;amp;&amp;amp;</span><br><span class=\"line\">                params.equals(that.params);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int hashCode() &#123;</span><br><span class=\"line\">        if (params == null) &#123;</span><br><span class=\"line\">            return Objects.hash(beanName, methodName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return Objects.hash(beanName, methodName, params);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"4-定时任务控制类：ScheduledTask\"><a href=\"#4-定时任务控制类：ScheduledTask\" class=\"headerlink\" title=\"4.定时任务控制类：ScheduledTask\"></a>4.定时任务控制类：ScheduledTask</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.concurrent.ScheduledFuture;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @program: simple-demo</span><br><span class=\"line\"> * @description: 定时任务控制类</span><br><span class=\"line\"> * @author: CaoTing</span><br><span class=\"line\"> * @date: 2019/5/23</span><br><span class=\"line\"> **/</span><br><span class=\"line\">public final class ScheduledTask &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public volatile ScheduledFuture&lt;?&gt; future;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 取消定时任务</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void cancel() &#123;</span><br><span class=\"line\">        ScheduledFuture&lt;?&gt; future = this.future;</span><br><span class=\"line\">        if (future != null) &#123;</span><br><span class=\"line\">            future.cancel(true);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"5-定时任务的测试\"><a href=\"#5-定时任务的测试\" class=\"headerlink\" title=\"5.定时任务的测试\"></a>5.定时任务的测试</h3><p>编写一个需要用于测试的任务类<br> <div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @program: simple-demo</span><br><span class=\"line\"> * @description:</span><br><span class=\"line\"> * @author: CaoTing</span><br><span class=\"line\"> * @date: 2019/5/23</span><br><span class=\"line\"> **/</span><br><span class=\"line\">@Component(&quot;demoTask&quot;)</span><br><span class=\"line\">public class DemoTask &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void taskWithParams(String param1, Integer param2) &#123;</span><br><span class=\"line\">        System.out.println(&quot;这是有参示例任务：&quot; + param1 + param2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void taskNoParams() &#123;</span><br><span class=\"line\">        System.out.println(&quot;这是无参示例任务&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div></p>\n<p>进行单元测试<br> <div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import com.caotinging.demo.application.DynamicTaskApplication;</span><br><span class=\"line\">import com.caotinging.demo.application.SchedulingRunnable;</span><br><span class=\"line\">import com.caotinging.demo.config.CronTaskRegistrar;</span><br><span class=\"line\">import org.junit.Test;</span><br><span class=\"line\">import org.junit.runner.RunWith;</span><br><span class=\"line\">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class=\"line\">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @program: simple-demo</span><br><span class=\"line\"> * @description: 测试定时任务</span><br><span class=\"line\"> * @author: CaoTing</span><br><span class=\"line\"> * @date: 2019/5/23</span><br><span class=\"line\"> **/</span><br><span class=\"line\">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class=\"line\">@SpringBootTest(classes = DynamicTaskApplication.class)</span><br><span class=\"line\">public class TaskTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    CronTaskRegistrar cronTaskRegistrar;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void testTask() throws InterruptedException &#123;</span><br><span class=\"line\">        SchedulingRunnable task = new SchedulingRunnable(&quot;demoTask&quot;, &quot;taskNoParams&quot;, null);</span><br><span class=\"line\">        cronTaskRegistrar.addCronTask(task, &quot;0/10 * * * * ?&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 便于观察</span><br><span class=\"line\">        Thread.sleep(3000000);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void testHaveParamsTask() throws InterruptedException &#123;</span><br><span class=\"line\">        SchedulingRunnable task = new SchedulingRunnable(&quot;demoTask&quot;, &quot;taskWithParams&quot;, &quot;haha&quot;, 23);</span><br><span class=\"line\">        cronTaskRegistrar.addCronTask(task, &quot;0/10 * * * * ?&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 便于观察</span><br><span class=\"line\">        Thread.sleep(3000000);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div></p>\n<h3 id=\"6-工具类：SpringContextUtils\"><a href=\"#6-工具类：SpringContextUtils\" class=\"headerlink\" title=\"6.工具类：SpringContextUtils\"></a>6.工具类：SpringContextUtils</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.springframework.beans.BeansException;</span><br><span class=\"line\">import org.springframework.context.ApplicationContext;</span><br><span class=\"line\">import org.springframework.context.ApplicationContextAware;</span><br><span class=\"line\">import org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @program: simple-demo</span><br><span class=\"line\"> * @description: spring获取bean工具类</span><br><span class=\"line\"> * @author: CaoTing</span><br><span class=\"line\"> * @date: 2019/5/23</span><br><span class=\"line\"> **/</span><br><span class=\"line\">@Component</span><br><span class=\"line\">public class SpringContextUtils implements ApplicationContextAware &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static ApplicationContext applicationContext = null;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class=\"line\">        if (SpringContextUtils.applicationContext == null) &#123;</span><br><span class=\"line\">            SpringContextUtils.applicationContext = applicationContext;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //获取applicationContext</span><br><span class=\"line\">    public static ApplicationContext getApplicationContext() &#123;</span><br><span class=\"line\">        return applicationContext;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //通过name获取 Bean.</span><br><span class=\"line\">    public static Object getBean(String name) &#123;</span><br><span class=\"line\">        return getApplicationContext().getBean(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //通过class获取Bean.</span><br><span class=\"line\">    public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123;</span><br><span class=\"line\">        return getApplicationContext().getBean(clazz);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //通过name,以及Clazz返回指定的Bean</span><br><span class=\"line\">    public static &lt;T&gt; T getBean(String name, Class&lt;T&gt; clazz) &#123;</span><br><span class=\"line\">        return getApplicationContext().getBean(name, clazz);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"7-我的pom依赖\"><a href=\"#7-我的pom依赖\" class=\"headerlink\" title=\"7.我的pom依赖\"></a>7.我的pom依赖</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;mybatisplus-spring-boot-starter&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;1.0.5&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;2.1.9&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;1.1.9&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;!-- 数据库--&gt;</span><br><span class=\"line\">        &lt;!--&lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;--&gt;</span><br><span class=\"line\">        &lt;!-- https://mvnrepository.com/artifact/com.hynnet/oracle-driver-ojdbc --&gt;</span><br><span class=\"line\">        &lt;!--&lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;com.oracle&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;11.2.0.1.0&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;--&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;!-- 单元测试 --&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;!--redisTemplate --&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;!-- http连接 restTemplate --&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;httpclient-cache&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;!-- 工具--&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;1.2.31&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;commons-lang&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;2.6&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;!-- https://mvnrepository.com/artifact/com.google/guava --&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;10.0.1&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;!-- pinyin4j --&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;com.belerweb&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;pinyin4j&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;2.5.0&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"8-总结\"><a href=\"#8-总结\" class=\"headerlink\" title=\"8.总结\"></a>8.总结</h3><p>建议移步github获取简单demo上手实践哦，在本文文首哦。有帮助的话点个赞吧，笔芯。</p>\n","text":"本文转载自 https://juejin.im/post/5cf099556fb9a07ef2010716<br>由于工作上的原因，需要进行定时任务的动态增删改查，网上大部分资料都是整合quertz框架实现的。本人查阅了一些资料，发现springBoot本身就支持实现定时任务的动","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]},{"title":"杂谈 什么是伪共享（false sharing）？","slug":"杂谈什么是伪共享（falsesharing）？","date":"2019-05-13T07:18:06.006Z","updated":"2019-05-30T00:52:25.423Z","comments":true,"pin":null,"path":"api/articles/杂谈什么是伪共享（falsesharing）？.json","excerpt":"","keywords":null,"cover":"https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/false-sharing1.png","content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5cd644886fb9a032136fe6d7\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5cd644886fb9a032136fe6d7</a> </p>\n</blockquote>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>（1）什么是 CPU 缓存行？</p>\n<p>（2）什么是内存屏障？</p>\n<p>（3）什么是伪共享？</p>\n<p>（4）如何避免伪共享？</p>\n<h2 id=\"CPU缓存架构\"><a href=\"#CPU缓存架构\" class=\"headerlink\" title=\"CPU缓存架构\"></a>CPU缓存架构</h2><p>CPU 是计算机的心脏，所有运算和程序最终都要由它来执行。</p>\n<p>主内存（RAM）是数据存放的地方，CPU 和主内存之间有好几级缓存，因为即使直接访问主内存也是非常慢的。</p>\n<p>如果对一块数据做相同的运算多次，那么在执行运算的时候把它加载到离 CPU 很近的地方就有意义了，比如一个循环计数，你不想每次循环都跑到主内存去取这个数据来增长它吧。</p>\n<p><img src=\"https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/false-sharing1.png\" alt=\"ABA\"></p>\n<p>越靠近 CPU 的缓存越快也越小。</p>\n<p>所以 L1 缓存很小但很快，并且紧靠着在使用它的 CPU 内核。</p>\n<p>L2 大一些，也慢一些，并且仍然只能被一个单独的 CPU 核使用。</p>\n<p>L3 在现代多核机器中更普遍，仍然更大，更慢，并且被单个插槽上的所有 CPU 核共享。</p>\n<p>最后，主存保存着程序运行的所有数据，它更大，更慢，由全部插槽上的所有 CPU 核共享。</p>\n<p>当 CPU 执行运算的时候，它先去 L1 查找所需的数据，再去 L2，然后是 L3，最后如果这些缓存中都没有，所需的数据就要去主内存拿。</p>\n<p>走得越远，运算耗费的时间就越长。</p>\n<p>所以如果进行一些很频繁的运算，要确保数据在 L1 缓存中。</p>\n<h2 id=\"CPU缓存行\"><a href=\"#CPU缓存行\" class=\"headerlink\" title=\"CPU缓存行\"></a>CPU缓存行</h2><p>缓存是由缓存行组成的，通常是 64 字节（常用处理器的缓存行是 64 字节的，比较旧的处理器缓存行是 32 字节），并且它有效地引用主内存中的一块地址。</p>\n<p>一个 Java 的 long 类型是 8 字节，因此在一个缓存行中可以存 8 个 long 类型的变量。</p>\n<p><img src=\"https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/false-sharing2.png\" alt=\"ABA\"></p>\n<p>在程序运行的过程中，缓存每次更新都从主内存中加载连续的 64 个字节。因此，如果访问一个 long 类型的数组时，当数组中的一个值被加载到缓存中时，另外 7 个元素也会被加载到缓存中。</p>\n<p>但是，如果使用的数据结构中的项在内存中不是彼此相邻的，比如链表，那么将得不到免费缓存加载带来的好处。</p>\n<p>不过，这种免费加载也有一个坏处。设想如果我们有个 long 类型的变量 a，它不是数组的一部分，而是一个单独的变量，并且还有另外一个 long 类型的变量 b 紧挨着它，那么当加载 a 的时候将免费加载 b。</p>\n<p>看起来似乎没有什么毛病，但是如果一个 CPU 核心的线程在对 a 进行修改，另一个 CPU 核心的线程却在对 b 进行读取。</p>\n<p>当前者修改 a 时，会把 a 和 b 同时加载到前者核心的缓存行中，更新完 a 后其它所有包含 a 的缓存行都将失效，因为其它缓存中的 a 不是最新值了。</p>\n<p>而当后者读取 b 时，发现这个缓存行已经失效了，需要从主内存中重新加载。</p>\n<p>请记住，我们的缓存都是以缓存行作为一个单位来处理的，所以失效 a 的缓存的同时，也会把 b 失效，反之亦然。</p>\n<p><img src=\"https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/false-sharing3.png\" alt=\"ABA\"></p>\n<p>这样就出现了一个问题，b 和 a 完全不相干，每次却要因为 a 的更新需要从主内存重新读取，它被缓存未命中给拖慢了。</p>\n<p>这就是传说中的伪共享。</p>\n<h2 id=\"伪共享\"><a href=\"#伪共享\" class=\"headerlink\" title=\"伪共享\"></a>伪共享</h2><p>好了，上面介绍完CPU的缓存架构及缓存行机制，下面进入我们的正题——伪共享。</p>\n<p>当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</p>\n<p>我们来看看下面这个例子，充分说明了伪共享是怎么回事。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class FalseSharingTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        testPointer(new Pointer());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void testPointer(Pointer pointer) throws InterruptedException &#123;</span><br><span class=\"line\">        long start = System.currentTimeMillis();</span><br><span class=\"line\">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class=\"line\">            for (int i = 0; i &lt; 100000000; i++) &#123;</span><br><span class=\"line\">                pointer.x++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread t2 = new Thread(() -&gt; &#123;</span><br><span class=\"line\">            for (int i = 0; i &lt; 100000000; i++) &#123;</span><br><span class=\"line\">                pointer.y++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">        t1.join();</span><br><span class=\"line\">        t2.join();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(System.currentTimeMillis() - start);</span><br><span class=\"line\">        System.out.println(pointer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Pointer &#123;</span><br><span class=\"line\">    volatile long x;</span><br><span class=\"line\">    volatile long y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>这个例子中，我们声明了一个 Pointer 的类，它包含 x 和 y 两个变量（必须声明为volatile，保证可见性，关于内存屏障的东西我们后面再讲），一个线程对 x 进行自增1亿次，一个线程对 y 进行自增1亿次。</p>\n<p>可以看到，x 和 y 完全没有任何关系，但是更新 x 的时候会把其它包含 x 的缓存行失效，同时也就失效了 y，运行这段程序输出的时间为<code>3890ms</code>。</p>\n<h2 id=\"避免伪共享\"><a href=\"#避免伪共享\" class=\"headerlink\" title=\"避免伪共享\"></a>避免伪共享</h2><p>伪共享的原理我们知道了，一个缓存行是 64 个字节，一个 long 类型是 8 个字节，所以避免伪共享也很简单，笔者总结了下大概有以下三种方式：</p>\n<p>（1）在两个 long 类型的变量之间再加 7 个 long 类型</p>\n<p>我们把上面的Pointer改成下面这个结构：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Pointer &#123;</span><br><span class=\"line\">    volatile long x;</span><br><span class=\"line\">    long p1, p2, p3, p4, p5, p6, p7;</span><br><span class=\"line\">    volatile long y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>再次运行程序，会发现输出时间神奇的缩短为了<code>695ms</code>。</p>\n<p>（2）重新创建自己的 long 类型，而不是 java 自带的 long</p>\n<p>修改Pointer如下：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Pointer &#123;</span><br><span class=\"line\">    MyLong x = new MyLong();</span><br><span class=\"line\">    MyLong y = new MyLong();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class MyLong &#123;</span><br><span class=\"line\">    volatile long value;</span><br><span class=\"line\">    long p1, p2, p3, p4, p5, p6, p7;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>同时把 <code>pointer.x++;</code> 修改为 <code>pointer.x.value++;</code>，把 <code>pointer.y++;</code> 修改为 <code>pointer.y.value++;</code>，再次运行程序发现时间是<code>724ms</code>。</p>\n<p>（3）使用 @sun.misc.Contended 注解（java8）</p>\n<p>修改 MyLong 如下：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@sun.misc.Contended</span><br><span class=\"line\">class MyLong &#123;</span><br><span class=\"line\">    volatile long value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>默认使用这个注解是无效的，需要在JVM启动参数加上<code>-XX:-RestrictContended</code>才会生效，，再次运行程序发现时间是<code>718ms</code>。</p>\n<p>注意，以上三种方式中的前两种是通过加字段的形式实现的，加的字段又没有地方使用，可能会被jvm优化掉，所以建议使用第三种方式。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>（1）CPU具有多级缓存，越接近CPU的缓存越小也越快；</p>\n<p>（2）CPU缓存中的数据是以缓存行为单位处理的；</p>\n<p>（3）CPU缓存行能带来免费加载数据的好处，所以处理数组性能非常高；</p>\n<p>（4）CPU缓存行也带来了弊端，多线程处理不相干的变量时会相互影响，也就是伪共享；</p>\n<p>（5）避免伪共享的主要思路就是让不相干的变量不要出现在同一个缓存行中；</p>\n<p>（6）一是每两个变量之间加七个 long 类型；</p>\n<p>（7）二是创建自己的 long 类型，而不是用原生的；</p>\n<p>（8）三是使用 java8 提供的注解；</p>\n<h2 id=\"彩蛋\"><a href=\"#彩蛋\" class=\"headerlink\" title=\"彩蛋\"></a>彩蛋</h2><p>java中有哪些类避免了伪共享的干扰呢？</p>\n<p>还记得我们前面介绍过的 ConcurrentHashMap 的源码解析吗？</p>\n<p>里面的 size() 方法使用的是分段的思想来构造的，每个段使用的类是 CounterCell，它的类上就有 @sun.misc.Contended 注解。</p>\n<p>不知道的可以关注我的公众号“彤哥读源码”查看历史消息找到这篇文章看看。</p>\n<p>除了这个类，java中还有个 LongAdder 也使用了这个注解避免伪共享，下一章我们将一起学习 LongAdder 的源码分析，敬请期待。</p>\n<p>你还知道哪些避免伪共享的应用呢？</p>\n<hr>\n<p>欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。</p>\n<p><img src=\"https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode_ss.jpg\" alt=\"qrcode\"></p>\n","text":"本文转载自 https://juejin.im/post/5cd644886fb9a032136fe6d7 问题（1）什么是 CPU 缓存行？（2）什么是内存屏障？（3）什么是伪共享？（4）如何避免伪共享？CPU缓存架构CPU 是计算机的心脏，所有运算和程序最终都要由它来执行。主","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]},{"title":"如何优化代码中大量的if/else,switch/case?","slug":"如何优化代码中大量的if-else,switch-case","date":"2019-04-30T16:00:00.000Z","updated":"2019-05-30T00:52:25.421Z","comments":true,"pin":null,"path":"api/articles/如何优化代码中大量的if-else,switch-case.json","excerpt":"<p>随着项目的迭代，代码中存在的分支判断可能会越来越多，当里面涉及到的逻辑比较复杂或者分支数量实在是多的难以维护的时候，我们就要考虑下，有办法能让这些代码变得更优雅吗？</p>","keywords":null,"cover":"https://user-gold-cdn.xitu.io/2019/4/17/16a28c18805b08e1?imageView2/0/w/1280/h/960/ignore-error/1","content":null,"text":"随着项目的迭代，代码中存在的分支判断可能会越来越多，当里面涉及到的逻辑比较复杂或者分支数量实在是多的难以维护的时候，我们就要考虑下，有办法能让这些代码变得更优雅吗？ 本文来自于 https://juejin.im/post/5cc6a7fc5188250f015b5843 正文使","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]},{"title":"感受lambda之美，推荐收藏，需要时查阅","slug":"感受lambda之美，推荐收藏，需要时查阅","date":"2019-05-31T08:43:37.037Z","updated":"2019-05-31T08:43:37.745Z","comments":true,"pin":null,"path":"api/articles/感受lambda之美，推荐收藏，需要时查阅.json","excerpt":"","keywords":null,"cover":"https://user-gold-cdn.xitu.io/2019/5/23/16ae40638d420acd?imageView2/0/w/1280/h/960/ignore-error/1","content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5ce66801e51d455d850d3a4a\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ce66801e51d455d850d3a4a</a><br><a href=\"#h\">一、引言</a><a href=\"#hjava\">二、java重要的函数式接口</a><a href=\"#h1\">1、什么是函数式接口</a><a href=\"#h11java8\">1.1 java8自带的常用函数式接口。</a><a href=\"#h12\">1.2 惰性求值与及早求值</a><a href=\"#h2\">2、常用的流</a><a href=\"#h21collectcollectorstolist\">2.1 collect(Collectors.toList())</a><a href=\"#h22filter\">2.2 filter</a><a href=\"#h23map\">2.3 map</a><a href=\"#h24flatmap\">2.4 flatMap</a><a href=\"#h25maxmin\">2.5 max和min</a><a href=\"#h26count\">2.6 count</a><a href=\"#h27reduce\">2.7 reduce</a><a href=\"#h-1\">三、高级集合类及收集器</a><a href=\"#h31\">3.1 转换成值</a><a href=\"#h32\">3.2 转换成块</a><a href=\"#h33\">3.3 数据分组</a><a href=\"#h34\">3.4 字符串拼接</a><a href=\"#h-2\">四、总结</a></p>\n</blockquote>\n<h3 id=\"一、引言\"><a href=\"#一、引言\" class=\"headerlink\" title=\"一、引言\"></a>一、引言</h3><p>java8最大的特性就是引入Lambda表达式，即函数式编程，可以将行为进行传递。<strong>总结就是：使用不可变值与函数，函数对不可变值进行处理，映射成另一个值。</strong></p>\n<h3 id=\"二、java重要的函数式接口\"><a href=\"#二、java重要的函数式接口\" class=\"headerlink\" title=\"二、java重要的函数式接口\"></a>二、java重要的函数式接口</h3><h3 id=\"1、什么是函数式接口\"><a href=\"#1、什么是函数式接口\" class=\"headerlink\" title=\"1、什么是函数式接口\"></a>1、什么是函数式接口</h3><p><strong>函数接口是只有一个抽象方法的接口，用作 Lambda 表达式的类型。使用@FunctionalInterface注解修饰的类，编译器会检测该类是否只有一个抽象方法或接口，否则，会报错。可以有多个默认方法，静态方法。</strong></p>\n<h3 id=\"1-1-java8自带的常用函数式接口。\"><a href=\"#1-1-java8自带的常用函数式接口。\" class=\"headerlink\" title=\"1.1 java8自带的常用函数式接口。\"></a>1.1 java8自带的常用函数式接口。</h3><table>\n<thead>\n<tr>\n<th align=\"center\">函数接口</th>\n<th align=\"center\">抽象方法</th>\n<th align=\"center\">功能</th>\n<th align=\"center\">参数</th>\n<th align=\"center\">返回类型</th>\n<th align=\"center\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Predicate</td>\n<td align=\"center\">test(T t)</td>\n<td align=\"center\">判断真假</td>\n<td align=\"center\">T</td>\n<td align=\"center\">boolean</td>\n<td align=\"center\">9龙的身高大于185cm吗？</td>\n</tr>\n<tr>\n<td align=\"center\">Consumer</td>\n<td align=\"center\">accept(T t)</td>\n<td align=\"center\">消费消息</td>\n<td align=\"center\">T</td>\n<td align=\"center\">void</td>\n<td align=\"center\">输出一个值</td>\n</tr>\n<tr>\n<td align=\"center\">Function</td>\n<td align=\"center\">R apply(T t)</td>\n<td align=\"center\">将T映射为R（转换功能）</td>\n<td align=\"center\">T</td>\n<td align=\"center\">R</td>\n<td align=\"center\">获得student对象的名字</td>\n</tr>\n<tr>\n<td align=\"center\">Supplier</td>\n<td align=\"center\">T get()</td>\n<td align=\"center\">生产消息</td>\n<td align=\"center\">None</td>\n<td align=\"center\">T</td>\n<td align=\"center\">工厂方法</td>\n</tr>\n<tr>\n<td align=\"center\">UnaryOperator</td>\n<td align=\"center\">T apply(T t)</td>\n<td align=\"center\">一元操作</td>\n<td align=\"center\">T</td>\n<td align=\"center\">T</td>\n<td align=\"center\">逻辑非（!）</td>\n</tr>\n<tr>\n<td align=\"center\">BinaryOperator</td>\n<td align=\"center\">apply(T t, U u)</td>\n<td align=\"center\">二元操作</td>\n<td align=\"center\">(T，T)</td>\n<td align=\"center\">(T)</td>\n<td align=\"center\">求两个数的乘积（*）</td>\n</tr>\n<tr>\n<td align=\"center\"><code>{     {         Predicate&lt;Integer&gt; predicate = x -&gt; x &gt; ;         Student student =  Student(, , );         System.out.println(              + predicate.test(student.getStature()));         Consumer&lt;String&gt; consumer = System.out::println;         consumer.accept();         Function&lt;Student, String&gt; function = Student::getName;         String name = function.apply(student);         System.out.println(name);         Supplier&lt;Integer&gt; supplier =              () -&gt; Integer.valueOf(BigDecimal.TEN.toString());         System.out.println(supplier.get());         UnaryOperator&lt;Boolean&gt; unaryOperator = uglily -&gt; !uglily;         Boolean apply2 = unaryOperator.apply();         System.out.println(apply2);         BinaryOperator&lt;Integer&gt; operator = (x, y) -&gt; x * y;         Integer integer = operator.apply(, );         System.out.println(integer);         test(() -&gt; );     }          {         String work = worker.work();         System.out.println(work);     }      {         ;     } }</code></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>以上演示了lambda接口的使用及自定义一个函数式接口并使用。下面，我们看看java8将函数式接口封装到流中如何高效的帮助我们处理集合。</p>\n<p><strong>注意：Student::getName</strong>例子中这种编写lambda表达式的方式称为<strong>方法引用。</strong>格式为<strong>ClassNmae::methodName</strong>。是不是很神奇，java8就是这么迷人。</p>\n<p><strong>示例：本篇所有示例都基于以下三个类。OutstandingClass：班级；Student：学生；SpecialityEnum：特长。</strong><br><img src=\"https://user-gold-cdn.xitu.io/2019/5/23/16ae40638d420acd?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<h3 id=\"1-2-惰性求值与及早求值\"><a href=\"#1-2-惰性求值与及早求值\" class=\"headerlink\" title=\"1.2 惰性求值与及早求值\"></a>1.2 惰性求值与及早求值</h3><p><strong>惰性求值：只描述Stream，操作的结果也是Stream，这样的操作称为惰性求值。</strong>惰性求值可以像建造者模式一样链式使用，最后再使用及早求值得到最终结果。</p>\n<p><strong>及早求值：得到最终的结果而不是Stream，这样的操作称为及早求值。</strong></p>\n<h3 id=\"2、常用的流\"><a href=\"#2、常用的流\" class=\"headerlink\" title=\"2、常用的流\"></a>2、常用的流</h3><h3 id=\"2-1-collect-Collectors-toList\"><a href=\"#2-1-collect-Collectors-toList\" class=\"headerlink\" title=\"2.1 collect(Collectors.toList())\"></a>2.1 collect(Collectors.toList())</h3><p><strong>将流转换为list。还有toSet()，toMap()等。及早求值</strong>。\n<code>{     {         List&lt;Student&gt; studentList = Stream.of( Student(, , ),                  Student(, , ),                  Student(, , )).collect(Collectors.toList());         System.out.println(studentList);     } }</code></p>\n<h3 id=\"2-2-filter\"><a href=\"#2-2-filter\" class=\"headerlink\" title=\"2.2 filter\"></a>2.2 filter</h3><p>顾名思义，起<strong>过滤筛选</strong>的作用。<strong>内部就是Predicate接口。惰性求值。</strong><br><img src=\"https://user-gold-cdn.xitu.io/2019/5/23/16ae40638d2c0a51?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p>比如我们筛选出出身高小于180的同学。</p>\n<p><code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));         List&lt;Student&gt; list = students.stream()             .filter(stu -&gt; stu.getStature() &lt; )             .collect(Collectors.toList());         System.out.println(list);     } }</code></p>\n<h3 id=\"2-3-map\"><a href=\"#2-3-map\" class=\"headerlink\" title=\"2.3 map\"></a>2.3 map</h3><p><strong>转换功能，内部就是Function接口。惰性求值</strong><br><img src=\"https://user-gold-cdn.xitu.io/2019/5/23/16ae40638d1c6610?imageView2/0/w/1280/h/960/ignore-error/1\" alt> <code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));         List&lt;String&gt; names = students.stream().map(student -&gt; student.getName())                 .collect(Collectors.toList());         System.out.println(names);     } }</code></p>\n<p>例子中将student对象转换为String对象，获取student的名字。</p>\n<h3 id=\"2-4-flatMap\"><a href=\"#2-4-flatMap\" class=\"headerlink\" title=\"2.4 flatMap\"></a>2.4 flatMap</h3><p><strong>将多个Stream合并为一个Stream。惰性求值</strong><br><img src=\"https://user-gold-cdn.xitu.io/2019/5/23/16ae40638c4cca86?imageView2/0/w/1280/h/960/ignore-error/1\" alt> <code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));         List&lt;Student&gt; studentList = Stream.of(students,                 asList( Student(, , ),                          Student(, , )))                 .flatMap(students1 -&gt; students1.stream()).collect(Collectors.toList());         System.out.println(studentList);     } }</code></p>\n<p>调用Stream.of的静态方法将两个list转换为Stream，再通过flatMap将两个流合并为一个。</p>\n<h3 id=\"2-5-max和min\"><a href=\"#2-5-max和min\" class=\"headerlink\" title=\"2.5 max和min\"></a>2.5 max和min</h3><p>我们经常会在集合中<strong>求最大或最小值</strong>，使用流就很方便。<strong>及早求值。</strong><br><code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));         Optional&lt;Student&gt; max = students.stream()             .max(Comparator.comparing(stu -&gt; stu.getAge()));         Optional&lt;Student&gt; min = students.stream()             .min(Comparator.comparing(stu -&gt; stu.getAge()));                   (max.isPresent()) {             System.out.println(max.get());         }          (min.isPresent()) {             System.out.println(min.get());         }     } }</code></p>\n<p><strong>max、min接收一个Comparator</strong>（例子中使用java8自带的静态函数，只需要传进需要比较值即可。）并且返回一个Optional对象，该对象是java8新增的类，专门为了防止null引发的空指针异常。可以使用max.isPresent()判断是否有值；可以使用max.orElse(new Student())，当值为null时就使用给定值；也可以使用max.orElseGet(() -&gt; new Student());这需要传入一个Supplier的lambda表达式。</p>\n<h3 id=\"2-6-count\"><a href=\"#2-6-count\" class=\"headerlink\" title=\"2.6 count\"></a>2.6 count</h3><p><strong>统计功能，一般都是结合filter使用，因为先筛选出我们需要的再统计即可。及早求值</strong><br><code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));          count = students.stream().filter(s1 -&gt; s1.getAge() &lt; ).count();         System.out.println( + count);     } }</code></p>\n<h3 id=\"2-7-reduce\"><a href=\"#2-7-reduce\" class=\"headerlink\" title=\"2.7 reduce\"></a>2.7 reduce</h3><p><strong>reduce 操作可以实现从一组值中生成一个值</strong>。在上述例子中用到的 count 、 min 和 max 方<br>法，因为常用而被纳入标准库中。事实上，这些方法都是 reduce 操作。<strong>及早求值。</strong><br><img src=\"https://user-gold-cdn.xitu.io/2019/5/23/16ae40638c52397b?imageView2/0/w/1280/h/960/ignore-error/1\" alt> <code>{     {         Integer reduce = Stream.of(, , , ).reduce(, (acc, x) -&gt; acc+ x);         System.out.println(reduce);     } }</code></p>\n<p>我们看得reduce接收了一个初始值为0的累加器，依次取出值与累加器相加，最后累加器的值就是最终的结果。</p>\n<h3 id=\"三、高级集合类及收集器\"><a href=\"#三、高级集合类及收集器\" class=\"headerlink\" title=\"三、高级集合类及收集器\"></a>三、高级集合类及收集器</h3><h3 id=\"3-1-转换成值\"><a href=\"#3-1-转换成值\" class=\"headerlink\" title=\"3.1 转换成值\"></a>3.1 转换成值</h3><p><strong>收集器，一种通用的、从流生成复杂值的结构。</strong>只要将它传给 collect 方法，所有<br>的流就都可以使用它了。标准类库已经提供了一些有用的收集器，<strong>以下示例代码中的收集器都是从 java.util.stream.Collectors 类中静态导入的。</strong><br><code>{     {         List&lt;Student&gt; students1 =  ArrayList&lt;&gt;();         students1.add( Student(, , ));         students1.add( Student(, , ));         students1.add( Student(, , ));         OutstandingClass ostClass1 =  OutstandingClass(, students1);                  List&lt;Student&gt; students2 =  ArrayList&lt;&gt;(students1);         students2.remove();         OutstandingClass ostClass2 =  OutstandingClass(, students2);                  Stream&lt;OutstandingClass&gt; classStream = Stream.of(ostClass1, ostClass2);         OutstandingClass outstandingClass = biggestGroup(classStream);         System.out.println( + outstandingClass.getName());         System.out.println( + averageNumberOfStudent(students1));     }          {          outstandingClasses.collect(                 maxBy(comparing(ostClass -&gt; ostClass.getStudents().size())))                 .orElseGet(OutstandingClass::);     }          {          students.stream().collect(averagingInt(Student::getAge));     } }</code></p>\n<p>maxBy或者minBy就是求最大值与最小值。</p>\n<h3 id=\"3-2-转换成块\"><a href=\"#3-2-转换成块\" class=\"headerlink\" title=\"3.2 转换成块\"></a>3.2 转换成块</h3><p><strong>常用的流操作是将其分解成两个集合，Collectors.partitioningBy帮我们实现了，接收一个Predicate函数式接口。</strong><br><img src=\"https://user-gold-cdn.xitu.io/2019/5/23/16ae4063943b9487?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p>将示例学生分为会唱歌与不会唱歌的两个集合。</p>\n<p><code>{     {                  Map&lt;Boolean, List&lt;Student&gt;&gt; listMap = students.stream().collect(             Collectors.partitioningBy(student -&gt; student.getSpecialities().                                       contains(SpecialityEnum.SING)));     } }</code></p>\n<h3 id=\"3-3-数据分组\"><a href=\"#3-3-数据分组\" class=\"headerlink\" title=\"3.3 数据分组\"></a>3.3 数据分组</h3><p>数据分组是一种更自然的分割数据操作，与将数据分成 ture 和 false 两部分不同，<strong>可以使</strong><br><strong>用任意值对数据分组。Collectors.groupingBy接收一个Function做转换。</strong><br><img src=\"https://user-gold-cdn.xitu.io/2019/5/23/16ae4063f5d78c78?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p><strong>如图，我们使用groupingBy将根据进行分组为圆形一组，三角形一组，正方形一组。</strong></p>\n<p>例子：根据学生第一个特长进行分组<br><code>{     {                   Map&lt;SpecialityEnum, List&lt;Student&gt;&gt; listMap =               students.stream().collect(              Collectors.groupingBy(student -&gt; student.getSpecialities().get()));     } }</code></p>\n<p><strong>Collectors.groupingBy与SQL 中的 group by 操作是一样的。</strong></p>\n<h3 id=\"3-4-字符串拼接\"><a href=\"#3-4-字符串拼接\" class=\"headerlink\" title=\"3.4 字符串拼接\"></a>3.4 字符串拼接</h3><p>如果将所有学生的名字拼接起来，怎么做呢？通常只能创建一个StringBuilder，循环拼接。使用Stream，使用Collectors.joining()简单容易。<br><code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));          String names = students.stream()              .map(Student::getName).collect(Collectors.joining(,,));         System.out.println(names);     } }</code></p>\n<p><strong>joining接收三个参数，第一个是分界符，第二个是前缀符，第三个是结束符。也可以不传入参数Collectors.joining()，这样就是直接拼接。</strong></p>\n<h3 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h3><p>本篇主要从实际使用讲述了常用的方法及流，使用java8可以很清晰表达你要做什么，代码也很简洁。本篇例子主要是为了讲解较为简单，大家可以去使用java8重构自己现有的代码，自行领会lambda的奥妙。本文说的Stream要组合使用才会发挥更大的功能，链式调用很迷人，根据自己的业务去做吧。</p>\n<p><strong>整理不易，希望点赞支持支持。</strong></p>\n","text":"本文转载自 https://juejin.im/post/5ce66801e51d455d850d3a4a<br>一、引言二、java重要的函数式接口1、什么是函数式接口1.1 java8自带的常用函数式接口。1.2 惰性求值与及早求值2、常用的流2.1 collect(Coll","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]},{"title":"万万没想到，JVM内存结构的面试题可以问的这么难？","slug":"万万没想到，JVM内存结构的面试题可以问的这么难？","date":"2019-08-06T03:41:56.056Z","updated":"2019-08-06T03:41:56.563Z","comments":true,"pin":null,"path":"api/articles/万万没想到，JVM内存结构的面试题可以问的这么难？.json","excerpt":"","keywords":null,"cover":"https://user-gold-cdn.xitu.io/2019/8/5/16c5f71ceedef2ff?imageView2/0/w/1280/h/960/ignore-error/1","content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5d4789afe51d453b386a62ac\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5d4789afe51d453b386a62ac</a> </p>\n</blockquote>\n<p>在我的博客中，之前有很多文章介绍过JVM内存结构，相信很多看多我文章的朋友对这部分知识都有一定的了解了。</p>\n<p>那么，请大家尝试着回答一下以下问题：</p>\n<p>1、JVM管理的内存结构是怎样的？<br>2、不同的虚拟机在实现运行时内存的时候有什么区别？<br>3、运行时数据区中哪些区域是线程共享的？哪些是独享的？<br>4、除了JVM运行时内存以外，还有什么区域可以用吗？<br>5、堆和栈的区别是什么？<br>6、Java中的数组是存储在堆上还是栈上的？<br>7、Java中的对象创建有多少种方式？<br>8、Java中对象创建的过程是怎么样的？<br>9、Java中的对象一定在堆上分配内存吗？<br>10、如何获取堆和栈的dump文件？</p>\n<p>以上10道题，如果您可以全部准确无误的回答的话，那说明你真的很了解JVM的内存结构以及内存分配相关的知识了，如果有哪些知识点是不了解的，那么本文正好可以帮你答疑解惑。<br>JVM管理的内存结构是怎样的？</p>\n<p>Java虚拟机在执行Java程序的过程中会把他所管理的内存划分为若干个不同的数据区域。《Java虚拟机规范》中规定了JVM所管理的内存需要包括一下几个运行时区域：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/5/16c5f71ceedef2ff?imageView2/0/w/1280/h/960/ignore-error/1\" alt>￼</p>\n<p>主要包含了PC寄存器（程序计数器）、Java虚拟机栈、本地方法栈、Java堆、方法区以及运行时常量池。</p>\n<p>各个区域有各自不同的作用，关于各个区域的作用就不在本文中相信介绍了。</p>\n<p>但是，需要注意的是，上面的区域划分只是逻辑区域，对于有些区域的限制是比较松的，所以不同的虚拟机厂商在实现上，甚至是同一款虚拟机的不同版本也是不尽相同的。<br>不同的虚拟机在实现运行时内存的时候有什么区别？</p>\n<p>前面提到过《Java虚拟机规范》定义的JVM运行时所需的内存区域，不同的虚拟机实现上有所不同，而在这么多区域中，规范对于方法区的管理是最宽松的，规范中关于这部分的描述如下：</p>\n<p>方法区在虚拟机启动的时候创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择在这个区域不实现垃圾收集与压缩。本版本的规范也不限定实现方法区的内存位置和代码编译的管理策略。方法区的容量可以是固定的，也可以随着程序执行的需求动态扩展，并在不需要过多的空间时自行收缩。方法区在实际内存空间站可以是不连续的。</p>\n<p>这一规定，可以说是给了虚拟机厂商很大的自由。</p>\n<p>虚拟机规范对方法区实现的位置并没有明确要求，在最著名的HotSopt虚拟机实现中（在Java 8 之前），方法区仅是逻辑上的独立区域，在物理上并没有独立于堆而存在，而是位于永久代中。所以，这时候方法区也是可以被垃圾回收的。<br>实践证明，JVM中存在着大量的声明短暂的对象，还有一些生命周期比较长的对象。为了对他们采用不同的收集策略，采用了分代收集算法，所以HotSpot虚拟机把的根据对象的年龄不同，把堆分位新生代、老年代和永久代。</p>\n<p>在Java 8中 ，HotSpot虚拟机移除了永久代，使用本地内存来存储类元数据信息并称之为：元空间（Metaspace）</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/5/16c5f71cedf925ff?imageView2/0/w/1280/h/960/ignore-error/1\" alt>￼\n运行时数据区中哪些区域是线程共享的？哪些是独享的？</p>\n<p>在JVM运行时内存区域中，PC寄存器、虚拟机栈和本地方法栈是线程独享的。</p>\n<p>而Java堆、方法区是线程共享的。但是值得注意的是，Java堆其实还未每一个线程单独分配了一块<a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.hollischuang.com%2Farchives%2F3855\" target=\"_blank\" rel=\"noopener\">TLAB空间</a>，这部分空间在分配时是线程独享的，在使用时是线程共享的。<br>除了JVM运行时内存以外，还有什么区域可以用吗？</p>\n<p>除了我们前面介绍的虚拟机运行时数据区以外，还有一部分内存也被频繁使用，他不是运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，他就是——直接内存。</p>\n<p>直接内存的分配不受Java堆大小的限制，但是他还是会收到服务器总内存的影响。</p>\n<p>在JDK 1.4中引入的NIO中，引入了一种基于Channel和Buffer的I/O方式，他可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的应用进行操作。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/5/16c5f71cf1ef6818?imageView2/0/w/1280/h/960/ignore-error/1\" alt>￼\n堆和栈的区别是什么？</p>\n<p>堆和栈（虚拟机栈）是完全不同的两块内存区域，一个是线程独享的，一个是线程共享的，二者之间最大的区别就是存储的内容不同：</p>\n<p>堆中主要存放对象实例。<br>栈（局部变量表）中主要存放各种基本数据类型、对象的引用。<br>Java中的数组是存储在堆上还是栈上的？</p>\n<p>在Java中，数组同样是一个对象，所以对象在内存中如何存放同样适用于数组；</p>\n<p>所以，数组的实例是保存在堆中，而数组的引用是保存在栈上的。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/5/16c5f71ceef4b84d?imageView2/0/w/1280/h/960/ignore-error/1\" alt>￼\nJava中的对象创建有多少种方式？</p>\n<p>Java中有很多方式可以创建一个对象，最简单的方式就是使用new关键字。</p>\n<p><code>User user = new User();</code></p>\n<p>除此以外，还可以使用反射机制创建对象：</p>\n<p><code>User user = User.class.newInstance();</code></p>\n<p>或者使用Constructor类的newInstance：</p>\n<p><code>Constructor&lt;User&gt; constructor = User.class.getConstructor();\nUser user = constructor.newInstance();</code></p>\n<p>除此之外还可以使用clone方法和反序列化的方式，这两种方式不常用并且代码比较复杂，就不在这里展示了，感兴趣的可以自行了解下。</p>\n<p>Java中对象创建的过程是怎么样的？</p>\n<p>对于一个普通的Java对象的创建，大致过程如下：</p>\n<p>1、虚拟机遇到new指令，到常量池定位到这个类的符号引用。<br>2、检查符号引用代表的类是否被加载、解析、初始化过。<br>3、虚拟机为对象分配内存。<br>4、虚拟机将分配到的内存空间都初始化为零值。<br>5、虚拟机对对象进行必要的设置。<br>6、执行方法，成员变量进行初始化。<br>Java中的对象一定在堆上分配内存吗？</p>\n<p>前面我们说过，Java堆中主要保存了对象实例，但是，随着JIT编译期的发展与<a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2583\" target=\"_blank\" rel=\"noopener\">逃逸分析</a>技术逐渐成熟，<a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2398\" target=\"_blank\" rel=\"noopener\">栈上分配</a>、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>\n<p>其实，在编译期间，JIT会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，其中一种重要的技术叫做逃逸分析。</p>\n<p>如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/5/16c5f71cf10db7bf?imageView2/0/w/1280/h/960/ignore-error/1\" alt>￼\n10、如何获取堆和栈的dump文件？</p>\n<p>Java Dump，Java虚拟机的运行时快照。将Java虚拟机运行时的状态和信息保存到文件。</p>\n<p>可以使用在服务器上使用<a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.hollischuang.com%2Farchives%2F303\" target=\"_blank\" rel=\"noopener\">jmap</a>命令来获取堆dump，使用<a href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F110\" target=\"_blank\" rel=\"noopener\">jstack</a>命令来获取线程的调用栈dump。</p>\n<p>最后，欢迎大家关注我的公众号：<br><img src=\"https://user-gold-cdn.xitu.io/2019/8/5/16c5f71f7d7e8f51?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n","text":"本文转载自 https://juejin.im/post/5d4789afe51d453b386a62ac 在我的博客中，之前有很多文章介绍过JVM内存结构，相信很多看多我文章的朋友对这部分知识都有一定的了解了。那么，请大家尝试着回答一下以下问题：1、JVM管理的内存结构是怎样的","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":1,"path":"api/tags/JVM.json"}]},{"title":"深入了解Synchronized原理","slug":"深入了解Synchronized原理","date":"2019-05-12T14:57:08.008Z","updated":"2019-05-30T00:52:25.431Z","comments":true,"pin":null,"path":"api/articles/深入了解Synchronized原理.json","excerpt":"","keywords":null,"cover":"https://user-gold-cdn.xitu.io/2019/5/4/16a82cef40900b6b?imageView2/0/w/1280/h/960/ignore-error/1","content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5ccd84dee51d456e3428c1af\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ccd84dee51d456e3428c1af</a> </p>\n</blockquote>\n<h3 id=\"Synchronized\"><a href=\"#Synchronized\" class=\"headerlink\" title=\"Synchronized\"></a>Synchronized</h3><h3 id=\"互斥性\"><a href=\"#互斥性\" class=\"headerlink\" title=\"互斥性\"></a>互斥性</h3><p>同一个时间只允许一个线程拥有一个对象锁，这样在同一时间只有一个线程对需要同步的代码块进行访问</p>\n<h3 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h3><p>必须确保在某个线程的某个对象锁在释放之前，对某个共享变量所做的改变，对于下一个拥有在这个对象锁的线程是可见的，否则另外线程读取的是本地的副本从而进行操作，导致结果不一致。</p>\n<h3 id=\"重入性\"><a href=\"#重入性\" class=\"headerlink\" title=\"重入性\"></a>重入性</h3><p>从互斥锁的设计上来说，一个线程试图操作一个由其他线程持有的临界资源的时候，这个线程会处于堵塞状态。</p>\n<p>如果一个线程再次请求自己持有对象锁的临界资源的时候，这就属于重入锁。</p>\n<p>因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性。</p>\n<h3 id=\"获取对象锁的方式\"><a href=\"#获取对象锁的方式\" class=\"headerlink\" title=\"获取对象锁的方式\"></a>获取对象锁的方式</h3><h3 id=\"获取对象锁的方式-1\"><a href=\"#获取对象锁的方式-1\" class=\"headerlink\" title=\"获取对象锁的方式\"></a>获取对象锁的方式</h3><pre><code>1. 修饰实例方法，作用于当前实例加锁，进行同步代码块之前需要获得当前实例的锁（Synchronized method）\n1. 修饰代码块，指定加锁对象，作用于给定对象加锁，进入同步代码快之前要获得给定对象的锁（Synchronized instance）\n1. 修饰静态方法，作用于当前类对象加锁，进入同步代码块之前要获得当前类对象的锁（Synchronized static method）\n1. 修饰类对象，作用于类对象加锁，进入同步代码块之前要获得指定类对象的锁（Synchronized /*/*.class）</code></pre><h3 id=\"对象锁和类锁的区别\"><a href=\"#对象锁和类锁的区别\" class=\"headerlink\" title=\"对象锁和类锁的区别\"></a>对象锁和类锁的区别</h3><pre><code>1. 一个线程可以访问对象的同步代码块时，另外一个线程也可以访问同一个对象的非同步代码块\n1. 若锁住的是同一个对象，其他线程访问对象的同步代码块或者同步方法的时候会被阻塞\n1. 同一个类的不同对象的对象锁互不干扰\n1. 类锁是一种特殊的锁，因为类就是Class的实例，所以只要不同对象都是属于同一个类，那么他们的类锁都是一样的\n1. 类锁和对象锁互不干扰</code></pre><h3 id=\"底层原理\"><a href=\"#底层原理\" class=\"headerlink\" title=\"底层原理\"></a>底层原理</h3><p><img src=\"https://user-gold-cdn.xitu.io/2019/5/4/16a82cef40900b6b?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p><strong>锁对象</strong>存储在Java对象头里面</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">位数</th>\n<th align=\"center\">头对象结构</th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">32</td>\n<td align=\"center\">Mark word</td>\n<td align=\"center\">存储对象的HashCode,GC分代年龄，锁类型，锁标记</td>\n</tr>\n<tr>\n<td align=\"center\">32</td>\n<td align=\"center\">Class MeteDataAddress</td>\n<td align=\"center\">类型指针：指向实例对象所属的类</td>\n</tr>\n</tbody></table>\n<p>MarkWord被设定为一个非固定的数据结构，用来存储更多的数据，结构如下（这里不是很懂）</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/4/16a82cef40c43f45?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p>Monitor（内部锁，Monitor锁，管程，监视器锁，也就是和对象锁对应的对象）</p>\n<p>每个对象都存在这一个Monitor与之关联</p>\n<p>每个Java对象天生带有这把看不见的锁，在MarkWord的结构中，重量级锁的标记为是10，也就是指针就是指向Monitor对象的起始地址，在这里也就说明了Synchronized的默认锁是重量级锁。monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当<strong>一个 monitor 被某个线程持有后，它便处于锁定状态</strong>。</p>\n<p>在Java虚拟机中，Monitor是有MonitorObject所实现的，部分结构如下</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/4/16a82cef411d31aa?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p>_owner：指向持有ObjectMonitor对象的线程</p>\n<p>_WaitSet：存放处于wait状态的线程队列</p>\n<p>_EntryList：存放处于等待锁block状态的线程队列</p>\n<p>_count：用来记录该线程获取锁的次数</p>\n<p>ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向<strong>持有</strong>ObjectMonitor对象的线程，当有多个线程访问同一块同步代码块的时候，线程会线程会进入_EntryList，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1，若线程调用 wait() 方法，<strong>将释放当前持有的monitor，owner变量恢复为null</strong>，count自减1，同时该线程进入 WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。</p>\n<p><strong>Monitorenter和Monitorexit</strong></p>\n<p><strong>Synchronized代码块执行原理</strong></p>\n<p>字节码中可知同步语句块的实现使用的是<strong>monitorenter</strong> 和 <strong>monitorexit</strong> 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置 。当执行monitorenter指令时，如果当前线程获取<strong>对象锁所对应的monitor的特权</strong>的时候</p>\n<p>1 会去检查monitor的对象的count是否为0</p>\n<p>2 如果为0的话就获取成功，并且将count置为1</p>\n<p>3 倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。</p>\n<p>编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。一般字节码文件中都会多出一条monitorexit指令。</p>\n<p><strong>Synchronized方法执行原理</strong></p>\n<p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从<strong>ACC_SYNCHRONIZED</strong> 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会检查方法的 <strong>ACC_SYNCHRONIZED</strong> 访问标志是否被设置，如果设置了，执行线程将先持有monitor，然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。</p>\n<p>如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放</p>\n<h3 id=\"锁的类型\"><a href=\"#锁的类型\" class=\"headerlink\" title=\"锁的类型\"></a>锁的类型</h3><p><strong>自旋锁</strong></p>\n<p>synchronized在jdk1.6之前的锁是重量级锁，对于互斥同步的性能来说，阻塞挂起的是影响最大的。因为挂起线程和恢复线程都是要让操作系统从<strong>用户态</strong>转化到<strong>内核态</strong>中完成，而这两个状态的转换是比较影响性能的。</p>\n<p>大多数情况下，线程拥有锁的时间不会太长，如果直接挂起的话，会影响系统的性能。因为前面说过，线程切换是需要在操作系统的用户态和内核态之间转换的。所以为了解决这个问题，引进了自旋锁。</p>\n<p>自旋锁假设在不久，当前线程可以获得这个锁，因此JVM就让这个想要获得锁的线程，先做几个空循环先，让这个线程先不要放弃占有CPU资源的机会，经过若干次空循环之后，如果获得锁，那么就顺利的进入临界区。否则，你也不能让这个线程一直占有CPU资源呀，所以经过大概10次空循环之后，就只能老老实实地挂起了。</p>\n<p><strong>自旋适应锁</strong></p>\n<p>自旋适应锁就是从自旋锁改进而来的。在自旋锁的基础上，假如A线程通过自旋一定的时间之后获得了锁，然后释放锁。这时B线程也获得了这个锁，如果此时A线程再次想得到这个锁，那么JVM就会根据之前A线程曾经获得过这个锁，那么我就给你适当地增加一点空循环的次数，比如说从10次空循环到100次。假如有个C线程，他也想获得这个锁，也得自旋等待，可是很少轮到他或者没得到过这个锁（可能是被A抢了机会或者其他的），那么JVM就会认为C线程以后可能没什么机会获得了，就适当地减少C线程的空循坏次数甚至不让他做空循环。</p>\n<p><strong>偏向锁</strong></p>\n<p>如果A线程第一次获得锁，那么锁就进入偏向模式（虚拟机把对象头中的标志位设为“01”），MarkWord的结构也变成偏向锁结构，如果没有其他线程和A线程竞争，A线程再次请求该锁时，无需任何同步操作</p>\n<p><strong>只需要检查MarkWord的锁标记位是否为偏向锁和当前线程的Id是否为ThreadId即可。</strong></p>\n<p>也就是说当一个线程访问同步块并且获取锁的时候，会通过<strong>CAS操作</strong>在对象头的偏向锁结构里记录线程的ID，如果记录成功，线程在进入和退出同步块时，<strong>不需要进行CAS操作来加锁和解锁</strong>，从而提高程序的性能。</p>\n<p>TIPS:偏向锁只能被第一个获取它的线程进行 CAS 操作，一旦出现线程竞争锁对象，其它线程无论何时进行 CAS 操作都会失败。</p>\n<p>加锁具体步骤如下</p>\n<pre><code>1. </code></pre><p>先检查Mark Word是否为可偏向状态，也就是说是否 是偏向锁1，锁标识位为01<br>    1.<br>如果是<strong>可偏向状态</strong>，那么就测试Mark Word结构的线程ID是不是和当前线程的ID一致，</p>\n<p>如果是就直接执行同步代码块。</p>\n<p>如果不是就通过CAS操作竞争锁，</p>\n<p>如果操作成功，就把Mark Word的线程ID设置为线程的ID</p>\n<p>如果操作失败，那么就说明此时有<strong>多线程竞争</strong>的状态，等到安全点，获得偏向锁的线程就挂起，进行解锁操作。偏向锁升级为轻量锁，被阻塞在安全点的线程继续往下执行同步代码块。</p>\n<p>解锁</p>\n<p>当获得偏向锁的<strong>线程挂起</strong>之后，就会进行解锁操作。</p>\n<p>在解锁成功之后，JVM判断此时线程的状态，</p>\n<p>如果还没有执行完同步代码，则直接将偏向锁升级为轻量级锁，然后继续执行剩下的代码块。</p>\n<p>如果此时已经执行完同步代码，则撤销锁为<strong>无锁状态</strong>，以后执行同步代码的时候JVM则会直接升级为轻量锁。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/4/16a82cef41476b9a?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p><strong>轻量锁</strong>（加锁解锁操作是需要依赖多次CAS原子指令的）</p>\n<p>偏向锁一旦受到多线程竞争，就会膨胀为轻量锁</p>\n<p>获取锁</p>\n<pre><code>1. 先判断当前对象是否处于无锁状态，如果是，JVM就首先在想要获取这个锁的线程的栈帧中建立一个锁记录（Lock Record）的空间，其中header部分用来存储Mark Word的备份，否则执行3。\n1. JVM利用CAS操作尝试将对象的Mark Word更新为指向锁记录的指针，如果成功，那么就获得轻量锁，就将标志位设置为00，执行同步代码块，否则执行3。\n1. 判断当前对象的Mark Word是否指向当前想要竞争的线程的锁记录，如果是表示则该线程拥有这个轻量锁，继续执行同步代码块，也就是重入。否则，说明这个轻量锁已经被其他线程拥有，那么这个先进行**自旋**获取锁，如果一直没有得到锁，那么轻量锁则要膨胀为重量锁（也就是将标记为设置为10），锁标记设置为10，后面等待的线程则会进入阻塞状态，如果通过自旋成功获取了锁，那么轻量锁不会膨胀为重量锁。</code></pre><p>释放锁</p>\n<pre><code>1. 取出线程锁记录之前保存的轻量锁的Mark Word记录，通过CAS操作将取出的记录替换当前对象的Mark Word中\n1. 判断当前对象的Mark Word是否指向当前线程的锁记录\n1. 如果1,2都成功，那么就成功释放锁\n1. 如果1失败，那么就是之前有过线程对当前对象的锁竞争过，但是失败了，由轻量级锁变为重量级锁，导致Mark Word的结够发生了改变。那么后面就释放锁，唤醒等待的线程，进行新一轮的竞争。</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/5/4/16a82cef42898e7d?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p><strong>重量级锁</strong></p>\n<p>重量级锁通过对象内部的监视器（monitor）实现</p>\n<p>其中monitor的本质是依赖于底层操作系统的Mutex Lock实现</p>\n<p>操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p>\n<h3 id=\"锁的升级\"><a href=\"#锁的升级\" class=\"headerlink\" title=\"锁的升级\"></a>锁的升级</h3><p>锁主要存在四种状态，无状态锁，偏向锁，轻量锁，重量锁，会随着线程竞争的程度逐渐增大。锁只可以单向升级，不可以降级。</p>\n<p>主要是为了提高获得锁和解锁的效率。</p>\n<h3 id=\"各个状态锁的优缺点对比\"><a href=\"#各个状态锁的优缺点对比\" class=\"headerlink\" title=\"各个状态锁的优缺点对比\"></a>各个状态锁的优缺点对比</h3><table>\n<thead>\n<tr>\n<th align=\"center\">锁类型</th>\n<th align=\"center\">特征</th>\n<th align=\"center\">优点</th>\n<th align=\"center\">缺点</th>\n<th align=\"center\">使用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">偏向锁</td>\n<td align=\"center\">只需要比较ThreadId</td>\n<td align=\"center\">加锁和解锁不需要额外的消耗，和执行非同步代码块时间相差无几</td>\n<td align=\"center\">如果线程之间有竞争，会增加锁撤销的消耗</td>\n<td align=\"center\">当程序大部分只有一个线程操作的时候</td>\n</tr>\n<tr>\n<td align=\"center\">轻量锁</td>\n<td align=\"center\">自旋</td>\n<td align=\"center\">竞争线程不会阻塞，提高了程序的响应速度</td>\n<td align=\"center\">始终得不到锁的线程使用自旋会消耗CPU</td>\n<td align=\"center\">追求响应时间，同步执行代码比较快的时候</td>\n</tr>\n<tr>\n<td align=\"center\">重量锁</td>\n<td align=\"center\">依赖Mutex（操作系统的互斥）</td>\n<td align=\"center\">线程竞争不使用自旋，不怎么会消耗CPU</td>\n<td align=\"center\">线程阻塞，响应缓慢</td>\n<td align=\"center\">同步代码执行比较慢的情况</td>\n</tr>\n</tbody></table>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>这里有一张原理图（盗用别人的图），把上述的文字都进行了一个总结</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/4/16a82cef42a0936d?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://juejin.im/entry/589981fc1b69e60059a2156a\" target=\"_blank\" rel=\"noopener\">juejin.im/entry/58998…</a></p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fchampionhengyi%2Farticle%2Fdetails%2F80105718\" target=\"_blank\" rel=\"noopener\">blog.csdn.net/championhen…</a></p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fjavazejian%2Farticle%2Fdetails%2F72828483\" target=\"_blank\" rel=\"noopener\">blog.csdn.net/javazejian/…</a></p>\n","text":"本文转载自 https://juejin.im/post/5ccd84dee51d456e3428c1af Synchronized互斥性同一个时间只允许一个线程拥有一个对象锁，这样在同一时间只有一个线程对需要同步的代码块进行访问可见性必须确保在某个线程的某个对象锁在释放之前，对","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]},{"title":"死磕 java并发包之LongAdder源码分析","slug":"死磕java并发包之LongAdder源码分析","date":"2019-05-13T03:14:06.006Z","updated":"2019-05-30T00:52:25.430Z","comments":true,"pin":null,"path":"api/articles/死磕java并发包之LongAdder源码分析.json","excerpt":"","keywords":null,"cover":"https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/LongAdder1.png","content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5cd842aa6fb9a032332b4bb8\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5cd842aa6fb9a032332b4bb8</a> </p>\n</blockquote>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>（1）java8中为什么要新增LongAdder？</p>\n<p>（2）LongAdder的实现方式？</p>\n<p>（3）LongAdder与AtomicLong的对比？</p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>LongAdder是java8中新增的原子类，在多线程环境中，它比AtomicLong性能要高出不少，特别是写多的场景。</p>\n<p>它是怎么实现的呢？让我们一起来学习吧。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>LongAdder的原理是，在最初无竞争时，只更新base的值，当有多线程竞争时通过分段的思想，让不同的线程更新不同的段，最后把这些段相加就得到了完整的LongAdder存储的值。</p>\n<p><img src=\"https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/LongAdder1.png\" alt=\"LongAdder\"></p>\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><p>LongAdder继承自Striped64抽象类，Striped64中定义了Cell内部类和各重要属性。</p>\n<h3 id=\"主要内部类\"><a href=\"#主要内部类\" class=\"headerlink\" title=\"主要内部类\"></a>主要内部类</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Striped64中的内部类，使用@sun.misc.Contended注解，说明里面的值消除伪共享</span><br><span class=\"line\">@sun.misc.Contended static final class Cell &#123;</span><br><span class=\"line\">    // 存储元素的值，使用volatile修饰保证可见性</span><br><span class=\"line\">    volatile long value;</span><br><span class=\"line\">    Cell(long x) &#123; value = x; &#125;</span><br><span class=\"line\">    // CAS更新value的值</span><br><span class=\"line\">    final boolean cas(long cmp, long val) &#123;</span><br><span class=\"line\">        return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Unsafe实例</span><br><span class=\"line\">    private static final sun.misc.Unsafe UNSAFE;</span><br><span class=\"line\">    // value字段的偏移量</span><br><span class=\"line\">    private static final long valueOffset;</span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class=\"line\">            Class&lt;?&gt; ak = Cell.class;</span><br><span class=\"line\">            valueOffset = UNSAFE.objectFieldOffset</span><br><span class=\"line\">                (ak.getDeclaredField(&quot;value&quot;));</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            throw new Error(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>Cell类使用@sun.misc.Contended注解，说明是要避免伪共享的。</p>\n<p>使用Unsafe的CAS更新value的值，其中value的值使用volatile修饰，保证可见性。</p>\n<p>关于Unsafe的介绍请查看【<a href=\"https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F0s-u-MysppIaIHVrshp9fA\" target=\"_blank\" rel=\"noopener\">死磕 java魔法类之Unsafe解析</a>】。</p>\n<p>关于伪共享的介绍请查看【<a href=\"https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Frd13SOSxhLA6TT13N9ni8Q\" target=\"_blank\" rel=\"noopener\">杂谈 什么是伪共享（false sharing）？</a>】。</p>\n<h3 id=\"主要属性\"><a href=\"#主要属性\" class=\"headerlink\" title=\"主要属性\"></a>主要属性</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这三个属性都在Striped64中</span><br><span class=\"line\">// cells数组，存储各个段的值</span><br><span class=\"line\">transient volatile Cell[] cells;</span><br><span class=\"line\">// 最初无竞争时使用的，也算一个特殊的段</span><br><span class=\"line\">transient volatile long base;</span><br><span class=\"line\">// 标记当前是否有线程在创建或扩容cells，或者在创建Cell</span><br><span class=\"line\">// 通过CAS更新该值，相当于是一个锁</span><br><span class=\"line\">transient volatile int cellsBusy;</span><br></pre></td></tr></table></figure></div>\n\n<p>最初无竞争或有其它线程在创建cells数组时使用base更新值，有过竞争时使用cells更新值。</p>\n<p>最初无竞争是指一开始没有线程之间的竞争，但也有可能是多线程在操作，只是这些线程没有同时去更新base的值。</p>\n<p>有过竞争是指只要出现过竞争不管后面有没有竞争都使用cells更新值，规则是不同的线程hash到不同的cell上去更新，减少竞争。</p>\n<h3 id=\"add-x-方法\"><a href=\"#add-x-方法\" class=\"headerlink\" title=\"add(x)方法\"></a>add(x)方法</h3><p>add(x)方法是LongAdder的主要方法，使用它可以使LongAdder中存储的值增加x，x可为正可为负。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void add(long x) &#123;</span><br><span class=\"line\">    // as是Striped64中的cells属性</span><br><span class=\"line\">    // b是Striped64中的base属性</span><br><span class=\"line\">    // v是当前线程hash到的Cell中存储的值</span><br><span class=\"line\">    // m是cells的长度减1，hash时作为掩码使用</span><br><span class=\"line\">    // a是当前线程hash到的Cell</span><br><span class=\"line\">    Cell[] as; long b, v; int m; Cell a;</span><br><span class=\"line\">    // 条件1：cells不为空，说明出现过竞争，cells已经创建</span><br><span class=\"line\">    // 条件2：cas操作base失败，说明其它线程先一步修改了base，正在出现竞争</span><br><span class=\"line\">    if ((as = cells) != null || !casBase(b = base, b + x)) &#123;</span><br><span class=\"line\">        // true表示当前竞争还不激烈</span><br><span class=\"line\">        // false表示竞争激烈，多个线程hash到同一个Cell，可能要扩容</span><br><span class=\"line\">        boolean uncontended = true;</span><br><span class=\"line\">        // 条件1：cells为空，说明正在出现竞争，上面是从条件2过来的</span><br><span class=\"line\">        // 条件2：应该不会出现</span><br><span class=\"line\">        // 条件3：当前线程所在的Cell为空，说明当前线程还没有更新过Cell，应初始化一个Cell</span><br><span class=\"line\">        // 条件4：更新当前线程所在的Cell失败，说明现在竞争很激烈，多个线程hash到了同一个Cell，应扩容</span><br><span class=\"line\">        if (as == null || (m = as.length - 1) &lt; 0 ||</span><br><span class=\"line\">            // getProbe()方法返回的是线程中的threadLocalRandomProbe字段</span><br><span class=\"line\">            // 它是通过随机数生成的一个值，对于一个确定的线程这个值是固定的</span><br><span class=\"line\">            // 除非刻意修改它</span><br><span class=\"line\">            (a = as[getProbe() &amp;amp; m]) == null ||</span><br><span class=\"line\">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class=\"line\">            // 调用Striped64中的方法处理</span><br><span class=\"line\">            longAccumulate(x, null, uncontended);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>（1）最初无竞争时只更新base；</p>\n<p>（2）直到更新base失败时，创建cells数组；</p>\n<p>（3）当多个线程竞争同一个Cell比较激烈时，可能要扩容；</p>\n<h2 id=\"longAccumulate-方法\"><a href=\"#longAccumulate-方法\" class=\"headerlink\" title=\"longAccumulate()方法\"></a>longAccumulate()方法</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final void longAccumulate(long x, LongBinaryOperator fn,</span><br><span class=\"line\">                              boolean wasUncontended) &#123;</span><br><span class=\"line\">    // 存储线程的probe值</span><br><span class=\"line\">    int h;</span><br><span class=\"line\">    // 如果getProbe()方法返回0，说明随机数未初始化</span><br><span class=\"line\">    if ((h = getProbe()) == 0) &#123;</span><br><span class=\"line\">        // 强制初始化</span><br><span class=\"line\">        ThreadLocalRandom.current(); // force initialization</span><br><span class=\"line\">        // 重新获取probe值</span><br><span class=\"line\">        h = getProbe();</span><br><span class=\"line\">        // 都未初始化，肯定还不存在竞争激烈</span><br><span class=\"line\">        wasUncontended = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 是否发生碰撞</span><br><span class=\"line\">    boolean collide = false;                // True if last slot nonempty</span><br><span class=\"line\">    for (;;) &#123;</span><br><span class=\"line\">        Cell[] as; Cell a; int n; long v;</span><br><span class=\"line\">        // cells已经初始化过</span><br><span class=\"line\">        if ((as = cells) != null &amp;amp;&amp;amp; (n = as.length) &gt; 0) &#123;</span><br><span class=\"line\">            // 当前线程所在的Cell未初始化</span><br><span class=\"line\">            if ((a = as[(n - 1) &amp;amp; h]) == null) &#123;</span><br><span class=\"line\">                // 当前无其它线程在创建或扩容cells，也没有线程在创建Cell</span><br><span class=\"line\">                if (cellsBusy == 0) &#123;       // Try to attach new Cell</span><br><span class=\"line\">                    // 新建一个Cell，值为当前需要增加的值</span><br><span class=\"line\">                    Cell r = new Cell(x);   // Optimistically create</span><br><span class=\"line\">                    // 再次检测cellsBusy，并尝试更新它为1</span><br><span class=\"line\">                    // 相当于当前线程加锁</span><br><span class=\"line\">                    if (cellsBusy == 0 &amp;amp;&amp;amp; casCellsBusy()) &#123;</span><br><span class=\"line\">                        // 是否创建成功</span><br><span class=\"line\">                        boolean created = false;</span><br><span class=\"line\">                        try &#123;               // Recheck under lock</span><br><span class=\"line\">                            Cell[] rs; int m, j;</span><br><span class=\"line\">                            // 重新获取cells，并找到当前线程hash到cells数组中的位置</span><br><span class=\"line\">                            // 这里一定要重新获取cells，因为as并不在锁定范围内</span><br><span class=\"line\">                            // 有可能已经扩容了，这里要重新获取</span><br><span class=\"line\">                            if ((rs = cells) != null &amp;amp;&amp;amp;</span><br><span class=\"line\">                                (m = rs.length) &gt; 0 &amp;amp;&amp;amp;</span><br><span class=\"line\">                                rs[j = (m - 1) &amp;amp; h] == null) &#123;</span><br><span class=\"line\">                                // 把上面新建的Cell放在cells的j位置处</span><br><span class=\"line\">                                rs[j] = r;</span><br><span class=\"line\">                                // 创建成功</span><br><span class=\"line\">                                created = true;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125; finally &#123;</span><br><span class=\"line\">                            // 相当于释放锁</span><br><span class=\"line\">                            cellsBusy = 0;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        // 创建成功了就返回</span><br><span class=\"line\">                        // 值已经放在新建的Cell里面了</span><br><span class=\"line\">                        if (created)</span><br><span class=\"line\">                            break;</span><br><span class=\"line\">                        continue;           // Slot is now non-empty</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                // 标记当前未出现冲突</span><br><span class=\"line\">                collide = false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 当前线程所在的Cell不为空，且更新失败了</span><br><span class=\"line\">            // 这里简单地设为true，相当于简单地自旋一次</span><br><span class=\"line\">            // 通过下面的语句修改线程的probe再重新尝试</span><br><span class=\"line\">            else if (!wasUncontended)       // CAS already known to fail</span><br><span class=\"line\">                wasUncontended = true;      // Continue after rehash</span><br><span class=\"line\">            // 再次尝试CAS更新当前线程所在Cell的值，如果成功了就返回</span><br><span class=\"line\">            else if (a.cas(v = a.value, ((fn == null) ? v + x :</span><br><span class=\"line\">                                         fn.applyAsLong(v, x))))</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            // 如果cells数组的长度达到了CPU核心数，或者cells扩容了</span><br><span class=\"line\">            // 设置collide为false并通过下面的语句修改线程的probe再重新尝试</span><br><span class=\"line\">            else if (n &gt;= NCPU || cells != as)</span><br><span class=\"line\">                collide = false;            // At max size or stale</span><br><span class=\"line\">            // 上上个elseif都更新失败了，且上个条件不成立，说明出现冲突了</span><br><span class=\"line\">            else if (!collide)</span><br><span class=\"line\">                collide = true;</span><br><span class=\"line\">            // 明确出现冲突了，尝试占有锁，并扩容</span><br><span class=\"line\">            else if (cellsBusy == 0 &amp;amp;&amp;amp; casCellsBusy()) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    // 检查是否有其它线程已经扩容过了</span><br><span class=\"line\">                    if (cells == as) &#123;      // Expand table unless stale</span><br><span class=\"line\">                        // 新数组为原数组的两倍</span><br><span class=\"line\">                        Cell[] rs = new Cell[n &lt;&lt; 1];</span><br><span class=\"line\">                        // 把旧数组元素拷贝到新数组中</span><br><span class=\"line\">                        for (int i = 0; i &lt; n; ++i)</span><br><span class=\"line\">                            rs[i] = as[i];</span><br><span class=\"line\">                        // 重新赋值cells为新数组</span><br><span class=\"line\">                        cells = rs;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; finally &#123;</span><br><span class=\"line\">                    // 释放锁</span><br><span class=\"line\">                    cellsBusy = 0;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                // 已解决冲突</span><br><span class=\"line\">                collide = false;</span><br><span class=\"line\">                // 使用扩容后的新数组重新尝试</span><br><span class=\"line\">                continue;                   // Retry with expanded table</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 更新失败或者达到了CPU核心数，重新生成probe，并重试</span><br><span class=\"line\">            h = advanceProbe(h);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 未初始化过cells数组，尝试占有锁并初始化cells数组</span><br><span class=\"line\">        else if (cellsBusy == 0 &amp;amp;&amp;amp; cells == as &amp;amp;&amp;amp; casCellsBusy()) &#123;</span><br><span class=\"line\">            // 是否初始化成功</span><br><span class=\"line\">            boolean init = false;</span><br><span class=\"line\">            try &#123;                           // Initialize table</span><br><span class=\"line\">                // 检测是否有其它线程初始化过</span><br><span class=\"line\">                if (cells == as) &#123;</span><br><span class=\"line\">                    // 新建一个大小为2的Cell数组</span><br><span class=\"line\">                    Cell[] rs = new Cell[2];</span><br><span class=\"line\">                    // 找到当前线程hash到数组中的位置并创建其对应的Cell</span><br><span class=\"line\">                    rs[h &amp;amp; 1] = new Cell(x);</span><br><span class=\"line\">                    // 赋值给cells数组</span><br><span class=\"line\">                    cells = rs;</span><br><span class=\"line\">                    // 初始化成功</span><br><span class=\"line\">                    init = true;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; finally &#123;</span><br><span class=\"line\">                // 释放锁</span><br><span class=\"line\">                cellsBusy = 0;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 初始化成功直接返回</span><br><span class=\"line\">            // 因为增加的值已经同时创建到Cell中了</span><br><span class=\"line\">            if (init)</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 如果有其它线程在初始化cells数组中，就尝试更新base</span><br><span class=\"line\">        // 如果成功了就返回</span><br><span class=\"line\">        else if (casBase(v = base, ((fn == null) ? v + x :</span><br><span class=\"line\">                                    fn.applyAsLong(v, x))))</span><br><span class=\"line\">            break;                          // Fall back on using base</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>（1）如果cells数组未初始化，当前线程会尝试占有cellsBusy锁并创建cells数组；</p>\n<p>（2）如果当前线程尝试创建cells数组时，发现有其它线程已经在创建了，就尝试更新base，如果成功就返回；</p>\n<p>（3）通过线程的probe值找到当前线程应该更新cells数组中的哪个Cell；</p>\n<p>（4）如果当前线程所在的Cell未初始化，就占有占有cellsBusy锁并在相应的位置创建一个Cell；</p>\n<p>（5）尝试CAS更新当前线程所在的Cell，如果成功就返回，如果失败说明出现冲突；</p>\n<p>（5）当前线程更新Cell失败后并不是立即扩容，而是尝试更新probe值后再重试一次；</p>\n<p>（6）如果在重试的时候还是更新失败，就扩容；</p>\n<p>（7）扩容时当前线程占有cellsBusy锁，并把数组容量扩大到两倍，再迁移原cells数组中元素到新数组中；</p>\n<p>（8）cellsBusy在创建cells数组、创建Cell、扩容cells数组三个地方用到；</p>\n<h2 id=\"sum-方法\"><a href=\"#sum-方法\" class=\"headerlink\" title=\"sum()方法\"></a>sum()方法</h2><p>sum()方法是获取LongAdder中真正存储的值的大小，通过把base和所有段相加得到。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public long sum() &#123;</span><br><span class=\"line\">    Cell[] as = cells; Cell a;</span><br><span class=\"line\">    // sum初始等于base</span><br><span class=\"line\">    long sum = base;</span><br><span class=\"line\">    // 如果cells不为空</span><br><span class=\"line\">    if (as != null) &#123;</span><br><span class=\"line\">        // 遍历所有的Cell</span><br><span class=\"line\">        for (int i = 0; i &lt; as.length; ++i) &#123;</span><br><span class=\"line\">            // 如果所在的Cell不为空，就把它的value累加到sum中</span><br><span class=\"line\">            if ((a = as[i]) != null)</span><br><span class=\"line\">                sum += a.value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 返回sum</span><br><span class=\"line\">    return sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>可以看到sum()方法是把base和所有段的值相加得到，那么，这里有一个问题，如果前面已经累加到sum上的Cell的value有修改，不是就没法计算到了么？</p>\n<p>答案确实如此，所以LongAdder可以说不是强一致性的，它是最终一致性的。</p>\n<h2 id=\"LongAdder-VS-AtomicLong\"><a href=\"#LongAdder-VS-AtomicLong\" class=\"headerlink\" title=\"LongAdder VS AtomicLong\"></a>LongAdder VS AtomicLong</h2><p>直接上代码：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class LongAdderVSAtomicLongTest &#123;</span><br><span class=\"line\">    public static void main(String[] args)&#123;</span><br><span class=\"line\">        testAtomicLongVSLongAdder(1, 10000000);</span><br><span class=\"line\">        testAtomicLongVSLongAdder(10, 10000000);</span><br><span class=\"line\">        testAtomicLongVSLongAdder(20, 10000000);</span><br><span class=\"line\">        testAtomicLongVSLongAdder(40, 10000000);</span><br><span class=\"line\">        testAtomicLongVSLongAdder(80, 10000000);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static void testAtomicLongVSLongAdder(final int threadCount, final int times)&#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            System.out.println(&quot;threadCount：&quot; + threadCount + &quot;, times：&quot; + times);</span><br><span class=\"line\">            long start = System.currentTimeMillis();</span><br><span class=\"line\">            testLongAdder(threadCount, times);</span><br><span class=\"line\">            System.out.println(&quot;LongAdder elapse：&quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">            long start2 = System.currentTimeMillis();</span><br><span class=\"line\">            testAtomicLong(threadCount, times);</span><br><span class=\"line\">            System.out.println(&quot;AtomicLong elapse：&quot; + (System.currentTimeMillis() - start2) + &quot;ms&quot;);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static void testAtomicLong(final int threadCount, final int times) throws InterruptedException &#123;</span><br><span class=\"line\">        AtomicLong atomicLong = new AtomicLong();</span><br><span class=\"line\">        List&lt;Thread&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (int i=0;i&lt;threadCount;i++)&#123;</span><br><span class=\"line\">            list.add(new Thread(() -&gt; &#123;</span><br><span class=\"line\">                for (int j = 0; j&lt;times; j++)&#123;</span><br><span class=\"line\">                    atomicLong.incrementAndGet();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (Thread thread : list)&#123;</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (Thread thread : list)&#123;</span><br><span class=\"line\">            thread.join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static void testLongAdder(final int threadCount, final int times) throws InterruptedException &#123;</span><br><span class=\"line\">        LongAdder longAdder = new LongAdder();</span><br><span class=\"line\">        List&lt;Thread&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (int i=0;i&lt;threadCount;i++)&#123;</span><br><span class=\"line\">            list.add(new Thread(() -&gt; &#123;</span><br><span class=\"line\">                for (int j = 0; j&lt;times; j++)&#123;</span><br><span class=\"line\">                    longAdder.add(1);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (Thread thread : list)&#123;</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (Thread thread : list)&#123;</span><br><span class=\"line\">            thread.join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>运行结果如下：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">threadCount：1, times：10000000</span><br><span class=\"line\">LongAdder elapse：158ms</span><br><span class=\"line\">AtomicLong elapse：64ms</span><br><span class=\"line\">threadCount：10, times：10000000</span><br><span class=\"line\">LongAdder elapse：206ms</span><br><span class=\"line\">AtomicLong elapse：2449ms</span><br><span class=\"line\">threadCount：20, times：10000000</span><br><span class=\"line\">LongAdder elapse：429ms</span><br><span class=\"line\">AtomicLong elapse：5142ms</span><br><span class=\"line\">threadCount：40, times：10000000</span><br><span class=\"line\">LongAdder elapse：840ms</span><br><span class=\"line\">AtomicLong elapse：10506ms</span><br><span class=\"line\">threadCount：80, times：10000000</span><br><span class=\"line\">LongAdder elapse：1369ms</span><br><span class=\"line\">AtomicLong elapse：20482ms</span><br></pre></td></tr></table></figure></div>\n\n<p>可以看到当只有一个线程的时候，AtomicLong反而性能更高，随着线程越来越多，AtomicLong的性能急剧下降，而LongAdder的性能影响很小。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>（1）LongAdder通过base和cells数组来存储值；</p>\n<p>（2）不同的线程会hash到不同的cell上去更新，减少了竞争；</p>\n<p>（3）LongAdder的性能非常高，最终会达到一种无竞争的状态；</p>\n<h2 id=\"彩蛋\"><a href=\"#彩蛋\" class=\"headerlink\" title=\"彩蛋\"></a>彩蛋</h2><p>在longAccumulate()方法中有个条件是<code>n &gt;= NCPU</code>就不会走到扩容逻辑了，而n是2的倍数，那是不是代表cells数组最大只能达到大于等于NCPU的最小2次方？</p>\n<p>答案是明确的。因为同一个CPU核心同时只会运行一个线程，而更新失败了说明有两个不同的核心更新了同一个Cell，这时会重新设置更新失败的那个线程的probe值，这样下一次它所在的Cell很大概率会发生改变，如果运行的时间足够长，最终会出现同一个核心的所有线程都会hash到同一个Cell（大概率，但不一定全在一个Cell上）上去更新，所以，这里cells数组中长度并不需要太长，达到CPU核心数足够了。</p>\n<p>比如，笔者的电脑是8核的，所以这里cells的数组最大只会到8，达到8就不会扩容了。</p>\n<p><img src=\"https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/LongAdder2.png\" alt=\"LongAdder\"></p>\n<hr>\n<p>欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。</p>\n<p><img src=\"https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode_ss.jpg\" alt=\"qrcode\"></p>\n","text":"本文转载自 https://juejin.im/post/5cd842aa6fb9a032332b4bb8 问题（1）java8中为什么要新增LongAdder？（2）LongAdder的实现方式？（3）LongAdder与AtomicLong的对比？简介LongAdder是ja","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]},{"title":"惊！史上最全的select加锁分析(Mysql)","slug":"惊！史上最全的select加锁分析(Mysql)","date":"2019-08-20T03:08:21.021Z","updated":"2019-08-20T03:08:21.724Z","comments":true,"pin":null,"path":"api/articles/惊！史上最全的select加锁分析(Mysql).json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5d5671a2e51d45620821cea7\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5d5671a2e51d45620821cea7</a> </p>\n</blockquote>\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>大家在面试中有没遇到面试官问你下面六句Sql的区别呢</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from table where id = ?</span><br><span class=\"line\">select * from table where id &lt; ?</span><br><span class=\"line\">select * from table where id = ? lock in share mode</span><br><span class=\"line\">select * from table where id &lt; ? lock in share mode</span><br><span class=\"line\">select * from table where id = ? for update</span><br><span class=\"line\">select * from table where id &lt; ? for update</span><br></pre></td></tr></table></figure></div>\n\n<p>如果你能清楚的说出，这六句sql在不同的事务隔离级别下，是否加锁，加的是共享锁还是排他锁，是否存在间隙锁，那这篇文章就没有看的意义了。 之所以写这篇文章是因为目前为止网上这方面的文章太片面，都只说了一半，且大多没指明隔离级别，以及<code>where</code>后跟的是否为索引条件列。在此，我就不一一列举那些有误的文章了，大家可以自行百度一下，大多都是讲不清楚。 OK，要回答这个问题，先问自己三个问题</p>\n<pre><code>* 当前事务隔离级别是什么\n* id列是否存在索引\n* 如果存在索引是聚簇索引还是非聚簇索引呢？</code></pre><p>OK，开始回答</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><pre><code>* innodb一定存在聚簇索引，默认以主键作为聚簇索引\n* 有几个索引，就有几棵B+树(不考虑hash索引的情形)\n* 聚簇索引的叶子节点为磁盘上的真实数据。非聚簇索引的叶子节点还是索引，指向聚簇索引B+树。</code></pre><p>下面啰嗦点基础知识</p>\n<h3 id=\"锁类型\"><a href=\"#锁类型\" class=\"headerlink\" title=\"锁类型\"></a>锁类型</h3><p><strong>共享锁</strong>(S锁):假设事务T1对数据A加上共享锁，那么事务T2<strong>可以</strong>读数据A，<strong>不能</strong>修改数据A。</p>\n<p><strong>排他锁</strong>(X锁):假设事务T1对数据A加上共享锁，那么事务T2<strong>不能</strong>读数据A，<strong>不能</strong>修改数据A。 我们通过<code>update</code>、<code>delete</code>等语句加上的锁都是行级别的锁。只有<code>LOCK TABLE … READ</code>和<code>LOCK TABLE … WRITE</code>才能申请表级别的锁。</p>\n<p><strong>意向共享锁</strong>(IS锁):一个事务在获取（任何一行/或者全表）S锁之前，一定会先在所在的表上加IS锁。</p>\n<p><strong>意向排他锁</strong>(IX锁):一个事务在获取（任何一行/或者全表）X锁之前，一定会先在所在的表上加IX锁。<br><strong>意向锁存在的目的?</strong></p>\n<p>OK，这里说一下意向锁存在的目的。假设事务T1，用X锁来锁住了表上的几条记录，那么此时表上存在IX锁，即意向排他锁。那么此时事务T2要进行<code>LOCK TABLE … WRITE</code>的表级别锁的请求，可以直接根据意向锁是否存在而判断是否有锁冲突。</p>\n<h3 id=\"加锁算法\"><a href=\"#加锁算法\" class=\"headerlink\" title=\"加锁算法\"></a>加锁算法</h3><p>我的说法是来自官方文档: <code>https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html</code> 加上自己矫揉造作的见解得出。</p>\n<p>ok，记得如下三种，本文就够用了</p>\n<p><code>Record Locks</code>：简单翻译为行锁吧。注意了，该锁是对索引记录进行加锁！锁是在加索引上而不是行上的。注意了，innodb一定存在聚簇索引，因此行锁最终都会落到聚簇索引上！</p>\n<p><code>Gap Locks</code>：简单翻译为间隙锁，是对索引的间隙加锁，其目的只有一个，防止其他事物插入数据。在<code>Read Committed</code>隔离级别下，不会使用间隙锁。这里我对官网补充一下，隔离级别比<code>Read Committed</code>低的情况下，也不会使用间隙锁，如隔离级别为<code>Read Uncommited</code>时，也不存在间隙锁。当隔离级别为<code>Repeatable Read</code>和<code>Serializable</code>时，就会存在间隙锁。</p>\n<p><code>Next-Key Locks</code>：这个理解为<code>Record Lock</code>+索引前面的<code>Gap Lock</code>。记住了，锁住的是索引前面的间隙！比如一个索引包含值，10，11，13和20。那么，间隙锁的范围如下</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(negative infinity, 10]</span><br><span class=\"line\">(10, 11]</span><br><span class=\"line\">(11, 13]</span><br><span class=\"line\">(13, 20]</span><br><span class=\"line\">(20, positive infinity)</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"快照读和当前读\"><a href=\"#快照读和当前读\" class=\"headerlink\" title=\"快照读和当前读\"></a>快照读和当前读</h3><p>最后一点基础知识了，大家坚持看完，这些是后面分析的基础！ 在mysql中select分为快照读和当前读，执行下面的语句</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from table where id = ?;</span><br></pre></td></tr></table></figure></div>\n\n<p>执行的是快照读，读的是数据库记录的快照版本，是不加锁的。（这种说法在隔离级别为<code>Serializable</code>中不成立，后面我会补充。） 那么，执行</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from table where id = ? lock in share mode;</span><br></pre></td></tr></table></figure></div>\n\n<p>会对读取记录加S锁 (共享锁)，执行</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from table where id = ? for update</span><br></pre></td></tr></table></figure></div>\n\n<p>会对读取记录加X锁 (排他锁)，那么</p>\n<p><strong>加的是表锁还是行锁呢？</strong></p>\n<p>针对这点，我们先回忆一下事务的四个隔离级别，他们由弱到强如下所示:</p>\n<pre><code>* `Read Uncommited(RU)`：读未提交，一个事务可以读到另一个事务未提交的数据！\n* `Read Committed (RC)`：读已提交，一个事务可以读到另一个事务已提交的数据!\n* `Repeatable Read (RR)`:可重复读，加入间隙锁，一定程度上避免了幻读的产生！注意了，只是一定程度上，并没有完全避免!我会在下一篇文章说明!另外就是记住从该级别才开始加入间隙锁(这句话记下来，后面有用到)!\n* `Serializable`：串行化，该级别下读写串行化，且所有的`select`语句后都自动加上`lock in share mode`，即使用了共享锁。因此在该隔离级别下，使用的是当前读，而不是快照读。</code></pre><p>那么关于是表锁还是行锁，大家可以看到网上最流传的一个说法是这样的，<br><strong>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。 InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong></p>\n<p>这句话大家可以搜一下，都是你抄我的，我抄你的。那么，这句话本身有两处错误！ <strong>错误一</strong>:并不是用表锁来实现锁表的操作，而是利用了<code>Next-Key Locks</code>，也可以理解为是用了行锁+间隙锁来实现锁表的操作! 为了便于说明，我来个例子，假设有表数据如下，pId为主键索引</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">pId(int)</th>\n<th align=\"center\">name(varchar)</th>\n<th align=\"center\">num(int)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">aaa</td>\n<td align=\"center\">100</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">bbb</td>\n<td align=\"center\">200</td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"center\">ccc</td>\n<td align=\"center\">200</td>\n</tr>\n</tbody></table>\n<p>执行语句(name列无索引)</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from table where name = `aaa` for update</span><br></pre></td></tr></table></figure></div>\n\n<p>那么此时在pId=1,2,7这三条记录上存在行锁(把行锁住了)。另外，在(-∞,1)(1,2)(2,7)(7,+∞)上存在间隙锁(把间隙锁住了)。因此，给人一种整个表锁住的错觉！</p>\n<p><code>ps:</code>对该结论有疑问的，可自行执行<code>show engine innodb status;</code>语句进行分析。</p>\n<p><strong>错误二</strong>:所有文章都不提隔离级别！</p>\n<p>注意我上面说的，之所以能够锁表，是通过行锁+间隙锁来实现的。那么，<code>RU</code>和<code>RC</code>都不存在间隙锁，这种说法在<code>RU</code>和<code>RC</code>中还能成立么？ 因此，该说法只在<code>RR</code>和<code>Serializable</code>中是成立的。如果隔离级别为<code>RU</code>和<code>RC</code>，无论条件列上是否有索引，都不会锁表，只锁行！</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>下面来对开始的问题作出解答，假设有表如下，pId为主键索引</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">pId(int)</th>\n<th align=\"center\">name(varchar)</th>\n<th align=\"center\">num(int)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">aaa</td>\n<td align=\"center\">100</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">bbb</td>\n<td align=\"center\">200</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">bbb</td>\n<td align=\"center\">300</td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"center\">ccc</td>\n<td align=\"center\">200</td>\n</tr>\n</tbody></table>\n<h3 id=\"RC-RU-条件列非索引\"><a href=\"#RC-RU-条件列非索引\" class=\"headerlink\" title=\"RC/RU+条件列非索引\"></a>RC/RU+条件列非索引</h3><p>(1)<code>select * from table where num = 200</code></p>\n<p>不加任何锁，是快照读。</p>\n<p>(2)<code>select * from table where num &gt; 200</code></p>\n<p>不加任何锁，是快照读。</p>\n<p>(3)<code>select * from table where num = 200 lock in share mode</code></p>\n<p>当num = 200，有两条记录。这两条记录对应的pId=2，7，因此在pId=2，7的聚簇索引上加行级S锁，采用当前读。</p>\n<p>(4)<code>select * from table where num &gt; 200 lock in share mode</code></p>\n<p>当num &gt; 200，有一条记录。这条记录对应的pId=3，因此在pId=3的聚簇索引上加上行级S锁，采用当前读。</p>\n<p>(5)<code>select * from table where num = 200 for update</code></p>\n<p>当num = 200，有两条记录。这两条记录对应的pId=2，7，因此在pId=2，7的聚簇索引上加行级X锁，采用当前读。</p>\n<p>(6)<code>select * from table where num &gt; 200 for update</code></p>\n<p>当num &gt; 200，有一条记录。这条记录对应的pId=3，因此在pId=3的聚簇索引上加上行级X锁，采用当前读。</p>\n<h3 id=\"RC-RU-条件列是聚簇索引\"><a href=\"#RC-RU-条件列是聚簇索引\" class=\"headerlink\" title=\"RC/RU+条件列是聚簇索引\"></a>RC/RU+条件列是聚簇索引</h3><p>恩，大家应该知道pId是主键列，因此pId用的就是聚簇索引。此情况其实和<strong>RC/RU+条件列非索引</strong>情况是类似的。</p>\n<p>(1)<code>select * from table where pId = 2</code></p>\n<p>不加任何锁，是快照读。</p>\n<p>(2)<code>select * from table where pId &gt; 2</code></p>\n<p>不加任何锁，是快照读。</p>\n<p>(3)<code>select * from table where pId = 2 lock in share mode</code></p>\n<p>在pId=2的聚簇索引上，加S锁，为当前读。</p>\n<p>(4)<code>select * from table where pId &gt; 2 lock in share mode</code></p>\n<p>在pId=3，7的聚簇索引上，加S锁，为当前读。</p>\n<p>(5)<code>select * from table where pId = 2 for update</code></p>\n<p>在pId=2的聚簇索引上，加X锁，为当前读。</p>\n<p>(6)<code>select * from table where pId &gt; 2 for update</code></p>\n<p>在pId=3，7的聚簇索引上，加X锁，为当前读。</p>\n<p>这里，大家可能有疑问<br><strong>为什么条件列加不加索引，加锁情况是一样的？</strong></p>\n<p>ok,其实是不一样的。在RC/RU隔离级别中，MySQL Server做了优化。在条件列没有索引的情况下，尽管通过聚簇索引来扫描全表，进行全表加锁。但是，MySQL Server层会进行过滤并把不符合条件的锁当即释放掉，因此你看起来最终结果是一样的。但是<strong>RC/RU+条件列非索引</strong>比本例多了一个释放不符合条件的锁的过程！</p>\n<h3 id=\"RC-RU-条件列是非聚簇索引\"><a href=\"#RC-RU-条件列是非聚簇索引\" class=\"headerlink\" title=\"RC/RU+条件列是非聚簇索引\"></a>RC/RU+条件列是非聚簇索引</h3><p>我们在num列上建上非唯一索引。此时有一棵聚簇索引(主键索引，pId)形成的B+索引树，其叶子节点为硬盘上的真实数据。以及另一棵非聚簇索引(非唯一索引，num)形成的B+索引树，其叶子节点依然为索引节点，保存了num列的字段值，和对应的聚簇索引。</p>\n<p>接下来分析开始</p>\n<p>(1)<code>select * from table where num = 200</code></p>\n<p>不加任何锁，是快照读。</p>\n<p>(2)<code>select * from table where num &gt; 200</code></p>\n<p>不加任何锁，是快照读。</p>\n<p>(3)<code>select * from table where num = 200 lock in share mode</code></p>\n<p>当num = 200，由于num列上有索引，因此先在 num = 200的两条索引记录上加行级S锁。接着，去聚簇索引树上查询，这两条记录对应的pId=2，7，因此在pId=2，7的聚簇索引上加行级S锁，采用当前读。</p>\n<p>(4)<code>select * from table where num &gt; 200 lock in share mode</code></p>\n<p>当num &gt; 200，由于num列上有索引，因此先在符合条件的 num = 300的一条索引记录上加行级S锁。接着，去聚簇索引树上查询，这条记录对应的pId=3，因此在pId=3的聚簇索引上加行级S锁，采用当前读。</p>\n<p>(5)<code>select * from table where num = 200 for update</code></p>\n<p>当num = 200，由于num列上有索引，因此先在 num = 200的两条索引记录上加行级X锁。接着，去聚簇索引树上查询，这两条记录对应的pId=2，7，因此在pId=2，7的聚簇索引上加行级X锁，采用当前读。</p>\n<p>(6)<code>select * from table where num &gt; 200 for update</code></p>\n<p>当num &gt; 200，由于num列上有索引，因此先在符合条件的 num = 300的一条索引记录上加行级X锁。接着，去聚簇索引树上查询，这条记录对应的pId=3，因此在pId=3的聚簇索引上加行级X锁，采用当前读。</p>\n<h3 id=\"RR-Serializable-条件列非索引\"><a href=\"#RR-Serializable-条件列非索引\" class=\"headerlink\" title=\"RR/Serializable+条件列非索引\"></a>RR/Serializable+条件列非索引</h3><p>RR级别需要多考虑的就是gap lock，他的加锁特征在于，无论你怎么查都是锁全表。如下所示 接下来分析开始</p>\n<p>(1)<code>select * from table where num = 200</code></p>\n<p>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，在pId = 1,2,3,7（全表所有记录）的聚簇索引上加S锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock</p>\n<p>(2)<code>select * from table where num &gt; 200</code></p>\n<p>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，在pId = 1,2,3,7（全表所有记录）的聚簇索引上加S锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock</p>\n<p>(3)<code>select * from table where num = 200 lock in share mode</code></p>\n<p>在pId = 1,2,3,7（全表所有记录）的聚簇索引上加S锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock</p>\n<p>(4)<code>select * from table where num &gt; 200 lock in share mode</code></p>\n<p>在pId = 1,2,3,7（全表所有记录）的聚簇索引上加S锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock</p>\n<p>(5)<code>select * from table where num = 200 for update</code></p>\n<p>在pId = 1,2,3,7（全表所有记录）的聚簇索引上加X锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock</p>\n<p>(6)<code>select * from table where num &gt; 200 for update</code></p>\n<p>在pId = 1,2,3,7（全表所有记录）的聚簇索引上加X锁。并且在 聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock</p>\n<h3 id=\"RR-Serializable-条件列是聚簇索引\"><a href=\"#RR-Serializable-条件列是聚簇索引\" class=\"headerlink\" title=\"RR/Serializable+条件列是聚簇索引\"></a>RR/Serializable+条件列是聚簇索引</h3><p>恩，大家应该知道pId是主键列，因此pId用的就是聚簇索引。该情况的加锁特征在于，如果<code>where</code>后的条件为精确查询(<code>=</code>的情况)，那么只存在record lock。如果<code>where</code>后的条件为范围查询(<code>&gt;</code>或<code>&lt;</code>的情况)，那么存在的是record lock+gap lock。</p>\n<p>(1)<code>select * from table where pId = 2</code></p>\n<p>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，是当前读，在pId=2的聚簇索引上加S锁，不存在gap lock。</p>\n<p>(2)<code>select * from table where pId &gt; 2</code></p>\n<p>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，是当前读，在pId=3,7的聚簇索引上加S锁。在(2,3)(3,7)(7,+∞)加上gap lock</p>\n<p>(3)<code>select * from table where pId = 2 lock in share mode</code></p>\n<p>是当前读，在pId=2的聚簇索引上加S锁，不存在gap lock。</p>\n<p>(4)<code>select * from table where pId &gt; 2 lock in share mode</code></p>\n<p>是当前读，在pId=3,7的聚簇索引上加S锁。在(2,3)(3,7)(7,+∞)加上gap lock</p>\n<p>(5)<code>select * from table where pId = 2 for update</code></p>\n<p>是当前读，在pId=2的聚簇索引上加X锁。</p>\n<p>(6)<code>select * from table where pId &gt; 2 for update</code></p>\n<p>在pId=3,7的聚簇索引上加X锁。在(2,3)(3,7)(7,+∞)加上gap lock</p>\n<p>(7)<code>select * from table where pId = 6 [lock in share mode|for update]</code></p>\n<p>注意了，pId=6是不存在的列，这种情况会在(3,7)上加gap lock。</p>\n<p>(8)<code>select * from table where pId &gt; 18 [lock in share mode|for update]</code></p>\n<p>注意了，pId&gt;18，查询结果是空的。在这种情况下，是在(7,+∞)上加gap lock。</p>\n<h3 id=\"RR-Serializable-条件列是非聚簇索引\"><a href=\"#RR-Serializable-条件列是非聚簇索引\" class=\"headerlink\" title=\"RR/Serializable+条件列是非聚簇索引\"></a>RR/Serializable+条件列是非聚簇索引</h3><p>这里非聚簇索引，需要区分是否为唯一索引。因为如果是非唯一索引，间隙锁的加锁方式是有区别的。</p>\n<p>先说一下，唯一索引的情况。如果是唯一索引，情况和<strong>RR/Serializable+条件列是聚簇索引</strong>类似，唯一有区别的是:这个时候有两棵索引树，加锁是加在对应的非聚簇索引树和聚簇索引树上！大家可以自行推敲!</p>\n<p>下面说一下，非聚簇索引是非唯一索引的情况，他和唯一索引的区别就是通过索引进行精确查询以后，不仅存在record lock，还存在gap lock。而通过唯一索引进行精确查询后，只存在record lock，不存在gap lock。老规矩在num列建立非唯一索引</p>\n<p>(1)<code>select * from table where num = 200</code></p>\n<p>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，是当前读，在pId=2，7的聚簇索引上加S锁，在num=200的非聚集索引上加S锁，在(100,200)(200,300)加上gap lock。</p>\n<p>(2)<code>select * from table where num &gt; 200</code></p>\n<p>在RR级别下，不加任何锁，是快照读。 在Serializable级别下，是当前读，在pId=3的聚簇索引上加S锁，在num=300的非聚集索引上加S锁。在(200,300)(300,+∞)加上gap lock</p>\n<p>(3)<code>select * from table where num = 200 lock in share mode</code></p>\n<p>是当前读，在pId=2，7的聚簇索引上加S锁，在num=200的非聚集索引上加S锁，在(100,200)(200,300)加上gap lock。</p>\n<p>(4)<code>select * from table where num &gt; 200 lock in share mode</code></p>\n<p>是当前读，在pId=3的聚簇索引上加S锁，在num=300的非聚集索引上加S锁。在(200,300)(300,+∞)加上gap lock。</p>\n<p>(5)<code>select * from table where num = 200 for update</code></p>\n<p>是当前读，在pId=2，7的聚簇索引上加S锁，在num=200的非聚集索引上加X锁，在(100,200)(200,300)加上gap lock。</p>\n<p>(6)<code>select * from table where num &gt; 200 for update</code></p>\n<p>是当前读，在pId=3的聚簇索引上加S锁，在num=300的非聚集索引上加X锁。在(200,300)(300,+∞)加上gap lock</p>\n<p>(7)<code>select * from table where num = 250 [lock in share mode|for update]</code></p>\n<p>注意了，num=250是不存在的列，这种情况会在(200,300)上加gap lock。</p>\n<p>(8)<code>select * from table where num &gt; 400 [lock in share mode|for update]</code></p>\n<p>注意了，pId&gt;400，查询结果是空的。在这种情况下，是在(400,+∞)上加gap lock。</p>\n","text":"本文转载自 https://juejin.im/post/5d5671a2e51d45620821cea7 引言大家在面试中有没遇到面试官问你下面六句Sql的区别呢1<br>2<br>3<br>4<br>5<br>6<br>select * from table where id","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]},{"title":"熟练掌握各种MQ？那面试官很可能用这道题目先摸摸你的老底！","slug":"熟练掌握各种MQ？那面试官很可能用这道题目先摸摸你的老底！","date":"2019-05-28T07:38:06.006Z","updated":"2019-05-30T00:52:25.432Z","comments":true,"pin":null,"path":"api/articles/熟练掌握各种MQ？那面试官很可能用这道题目先摸摸你的老底！.json","excerpt":"","keywords":null,"cover":"https://user-gold-cdn.xitu.io/2019/5/27/16af7d5d9e1690c5?imageView2/0/w/1280/h/960/ignore-error/1","content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5ceb79fef265da1bb47d4222\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ceb79fef265da1bb47d4222</a><br><strong>公众号：狸猫技术窝</strong></p>\n</blockquote>\n<p><strong>作者：爱钓鱼的桌子哥，资深架构师</strong></p>\n<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a><strong>目录</strong></h3><p>1.有Broker的暴力路由：<strong>Kafka</strong></p>\n<p>2.有Broker的复杂路由：<strong>RabbitMQ</strong></p>\n<p>3.无Broker的通信流派：<strong>ZeroMQ</strong></p>\n<p>4.总结</p>\n<h3 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a><strong>写在前面</strong></h3><p>我们知道，目前市面上的MQ包括Kafka、RabbitMQ、ZeroMQ、RocketMQ等等。</p>\n<p>那么他们之间究竟有什么本质区别，分别适用于什么场景呢？</p>\n<p>上述抛出的问题，同样在不少公司的Java工程师面试中出现，特别是当你简历上的技术栈包含了这些技术，面试官往往喜欢用这个问题，对你进行摸底考察。</p>\n<p>本文我们就一起来探讨一下。</p>\n<h3 id=\"（1）有Broker的暴力路由\"><a href=\"#（1）有Broker的暴力路由\" class=\"headerlink\" title=\"（1）有Broker的暴力路由\"></a><strong>（1）有Broker的暴力路由</strong></h3><p>这个流派最典型的就是<strong>Kafka</strong>，Kafka实际上为了提升性能，简化了MQ功能模型，仅仅提供了一些最基础的MQ相关的功能，但是大幅度优化和提升了吞吐量。</p>\n<p>首先，这个流派一定是有一个Broker角色的，也就是说，Kafka需要部署一套服务器集群，每台机器上都有一个Kafka Broker进程，这个进程就负责接收请求，存储数据，发送数据。</p>\n<p>Kafka的生产消费模型做的相对是比较暴力简单的，就是简单的数据流模型。</p>\n<p>简单来说，他有一个概念，叫做“<strong>Topic</strong>”，你可以往这个“Topic”里写数据，然后让别人从这里来消费。</p>\n<p>这个Topic可以划分为多个Partition，每个Partition放一台机器上，存储一部分数据。</p>\n<p>在写消息到Topic的时候，会自动把你这个消息给分发到某一个Partition上去。</p>\n<p>然后消费消息的时候，有一个<strong>Consumer Group</strong>的概念，你部署在多台机器上的Consumer可以组成一个Group，一个Partition只能给一个Consumer消费，一个Cosumer可以消费多个Partition，这是最最核心的一点。</p>\n<p>通过这个模型，保证一个Topic里的每条消息，只会交给Consumer Group里的一个Consumer来消费，形成了一个Queue（队列）的效果。</p>\n<p>假如你想要有一个Queue的效果，也就是希望不停的往Queue里写数据，然后多个消费者消费，每条消息就只能给一个消费者，那么通过Kafka来实现，其实就是生产者写多个Partition，每个Partition只能给Consumer Group中的一个Consumer来消费。如下图所示：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/27/16af7d5d9e1690c5?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p>如果要实现Publish/Subscribe的模型呢？就是说生产者发送的每条消息，都要让所有消费都消费到，怎么实现？</p>\n<p>那就让每个消费者都是一个独立的消费组，这样每条消息都会发送给所有的消费组，每个消费组里那唯一的一个消费者一定会消费到所有的消息。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/27/16af7d5d918ca40f?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p>但是除此之外，Kafka就没有任何其他的消费功能了，就是如此简单，所以属于一种比较暴力直接的流派。</p>\n<p>它就是简单的消费模型，实现最基础的Queue和Pub/Sub两种消费模型，但是内核中大幅度优化和提升了性能以及吞吐量。</p>\n<p>所以Kafka天生适合的场景，就是大数据领域的实时数据计算的场景。</p>\n<p>因为在大数据的场景下，通常是弱业务的场景，没有太多复杂的业务系统交互，而主要是大量的数据流入Kafka，然后进行实时计算。</p>\n<p>所以就是需要简单的消费模型，但是必须在内核中对吞吐量和性能进行大幅度的优化。</p>\n<p>因此Kafka技术通常是在大数据的实时数据计算领域中使用的，比如说每秒处理几十万条消息，甚至每秒处理上百万条消息。</p>\n<h3 id=\"（2）有Broker的复杂路由\"><a href=\"#（2）有Broker的复杂路由\" class=\"headerlink\" title=\"（2）有Broker的复杂路由\"></a>（2）有Broker的复杂路由</h3><p>第二个流派，就是<strong>RabbitMQ</strong>为代表的流派，他强调的不是说如何提升性能和吞吐量，关注的是说要提供非常强大、复杂而且完善的消息路由功能。</p>\n<p>所以对于RabbitMQ而言，他就不是那么简单的Topic-Partition的消费模型了。</p>\n<p>在RabbitMQ中引入了一个非常核心的概念，叫做<strong>Exchange</strong>，这个Exchange就是负责根据复杂的业务规则把消息路由到内部的不同的Queue里去。</p>\n<p>举个例子，如果要实现最简单的队列功能，就是让exchange往一个queue里写数据，然后多个消费者来消费这个queue里的数据，每条消息只能给一个消费者，那么可以是类似下面的方式。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/27/16af7d5d91903b11?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p>如果想要实现Pub/Sub的模型，就是一条消息要被所有的消费者给消费到，那么就可以让每个消费者都有一个自己的Queue，然后绑定到一个Exchange上去。</p>\n<p>接着，这个Exchange就设定把消息路由给所有的Queue即可，如下面这样。</p>\n<p>此时Exchange可以把每条消息都路由给所有的Queue，每个Consumer都可以从自己的Queue里拿到所有的消息。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/27/16af7d5d91efcb5b?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p>RabbitMQ这种流派，其实最核心的是，基于Exchange这个概念，他可以做很多复杂的事情。</p>\n<p>比如：如果你想要某个Consumer只能消费到<strong>某一类数据</strong>，那么Exchange可以把消息里比如带“XXX”前缀的消息路由给某个Queue。或者你可以限定某个Consumer就只能消费<strong>某一部分数据</strong>。总之在这里你可以做很多的限制，设置复杂的路由规则。</p>\n<p>但是也正是因为引入了这种复杂的消费模型，支持复杂的路由功能，导致RabbitMQ在内核以及架构设计上没法像Kafka做的那么的轻量级、高性能、可扩展、高吞吐，所以RabbitMQ在吞吐量上要比Kafka低一个数量级。</p>\n<p>所以这种流派的MQ，往往适合用在Java业务系统中，不同的业务系统需要进行复杂的消息路由。</p>\n<p>比如说业务系统A发送了10条消息，其中3条消息是给业务系统B的，7条消息是给业务系统C的，要实现这种复杂的路由模型，就必须依靠RabbitMQ来实现。</p>\n<p>当然，对于这种业务系统之间的消息流转而言，可能不需要那么高的吞吐量，可能每秒业务系统之间也就转发几十条或者几百条消息，那么就完全适合采用RabbitMQ来实现。</p>\n<h3 id=\"（3）无Broker的通信流派\"><a href=\"#（3）无Broker的通信流派\" class=\"headerlink\" title=\"（3）无Broker的通信流派\"></a>（3）无Broker的通信流派</h3><p><strong>ZeroMQ</strong>代表的是第三种MQ。说白了，他是不需要在服务器上部署的，就是一个客户端的库而已。</p>\n<p>也就是说，他主要是封装了底层的Socket网络通讯，然后一个系统要发送一条消息给另外一个消息消费 。</p>\n<p>通过ZeroMQ，本质就是底层ZeroMQ发送一条消息到另外一个系统上去。</p>\n<p>所以ZeroMQ是<strong>去中心化</strong>的，不需要跟Kafka、RabbitMQ一样在服务器上部署的。</p>\n<p>他主要是用来进行业务系统之间的网络通信的，有点类似于比如你是一个分布式系统架构，那么此时分布式架构中的各个子系统互相之间要通信，你是基于Dubbo RPC？还是Spring Cloud HTTP？</p>\n<p>可能上述两种你都不想要，就是要基于原始的Socket进行网络通信，简单的收发消息而已。</p>\n<p>此时就可以使用ZeroMQ作为分布式系统之间的消息通信，如下面那样。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/27/16af7d5d91f778d7?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<h3 id=\"（4）总结\"><a href=\"#（4）总结\" class=\"headerlink\" title=\"（4）总结\"></a>（4）总结</h3><p>其实现在基本上MQ主要就是这三个流派，很多小众的MQ一般很少有人会用。</p>\n<p>而且用MQ的场景主要就是两大类：</p>\n<pre><code>1. </code></pre><p><strong>业务系统之间异步通信</strong><br>    1.<br><strong>大数据领域的实时数据计算</strong></p>\n<p>所以一般业务系统之间通信就是会采用RabbitMQ/RocketMQ，需要复杂的消息路由功能的支撑。</p>\n<p>大数据的实时计算场景会采用Kafka，需要简单的消费模型，但是超高的吞吐量。</p>\n<p>至于ZeroMQ，一般来说，少数分布式系统中子系统之间的分布式通信时会采用，作为轻量级的异步化的通信组件。</p>\n<p><strong>END</strong></p>\n<p><strong>作者简介：</strong></p>\n<p><strong>爱钓鱼的桌子哥，资深架构师</strong></p>\n<p>作者先后工作于滴滴、百度、字节跳动等国内一线互联网大厂，从事基础架构相关工作。带领团队设计与构建了大规模的分布式存储系统、分布式消息中间件、分布式数据库，对分布式架构设计、系统高可用体系构建、基础中间件架构都有丰富的经验。</p>\n<p><strong>END</strong></p>\n<p>长按下图二维码，即刻关注【狸猫技术窝】 阿里、京东、美团、字节跳动 顶尖技术专家坐镇 为IT人打造一个 “有温度” 的技术窝！</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/23/16a4aea4c6855bb5?imageView2/0/w/1280/h/960/ignore-error/1\" alt><br>作者：狸猫技术窝<br>链接：<a href=\"https://juejin.im/post/5ce1975af265da1bd42450b5\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ce1975af265da1bd42450b5</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n","text":"本文转载自 https://juejin.im/post/5ceb79fef265da1bb47d4222<br>公众号：狸猫技术窝作者：爱钓鱼的桌子哥，资深架构师目录1.有Broker的暴力路由：Kafka2.有Broker的复杂路由：RabbitMQ3.无Broker的通信流","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]},{"title":"面试官：说说你对ThreadLocal的了解","slug":"面试官：说说你对ThreadLocal的了解","date":"2019-05-10T02:49:48.048Z","updated":"2019-05-30T00:52:25.435Z","comments":true,"pin":null,"path":"api/articles/面试官：说说你对ThreadLocal的了解.json","excerpt":"","keywords":null,"cover":"https://user-gold-cdn.xitu.io/2019/5/8/16a97cde94bb4de0?imageView2/0/w/1280/h/960/ignore-error/1","content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5cd2dcf4f265da03804386d0\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5cd2dcf4f265da03804386d0</a> </p>\n</blockquote>\n<p>一般有多个孩子的家庭，买玩具都得买多个。如果就买一个，嘿嘿就比较刺激了。这就是<strong>避免共享</strong>，给孩子每人一个玩具对应到我们Java中也就是每个线程都有自己的本地变量，咱们自己玩自己的，避免争抢，和谐相处使得线程安全。</p>\n<p>Java就是通过<code>ThreadLocal</code>来实现线程本地存储的。</p>\n<p>这思路也很清晰，就是每个线程要有自己的本地变量呗，那就Thread里面搞一个私有属性呗<code>ThreadLocal.ThreadLocalMap threadLocals = null;</code> 就是如下图所示的这个关系</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/8/16a97cde94bb4de0?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<h2 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h2><p>简单的应用如下</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo &#123;</span><br><span class=\"line\">\t\tprivate static final ThreadLocal&lt;Foo&gt; fooLocal = new ThreadLocal&lt;Foo&gt;();</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tpublic static Foo getFoo() &#123;</span><br><span class=\"line\">\t\t\treturn fooLocal.get();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tpublic static void setFoo(Foo foo) &#123;</span><br><span class=\"line\">\t\t\tfooLocal.set(foo);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>再深入了解一下内部情况，<code>ThreadLocalMap</code>是<code>ThreadLocal</code>的内部静态类，它虽然叫<code>Map</code>但是和<code>java.util.Map</code>没有啥亲戚关系，只是它实现的功能像<code>Map</code></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static class ThreadLocalMap &#123;</span><br><span class=\"line\">        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class=\"line\">            Object value;</span><br><span class=\"line\">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">                super(k);</span><br><span class=\"line\">                value = v;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        private static final int INITIAL_CAPACITY = 16;</span><br><span class=\"line\">        private Entry[] table;</span><br></pre></td></tr></table></figure></div>\n\n<p>可以看到<code>ThreadLocalMap</code>里面有个<code>Entry</code>数组，只有数组没有像<code>HashMap</code>那样有链表，因此当hash冲突的之后，<code>ThreadLocalMap</code>是<strong>采用线性探测的方式解决hash冲突。</strong></p>\n<p>线性探测，就是先根据初始<code>key</code>的<code>hashcode</code>值确定元素在<code>table</code>数组中的位置，如果这个位置上已经有其他<code>key</code>值的元素被占用，则利用固定的算法寻找一定步长的下个位置，依次直至找到能够存放的位置。在<code>ThreadLocalMap</code>步长是1。</p>\n<p><strong>用这种方式解决hash冲突的效率很低，因此要注意ThreadLocal的数量</strong>。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">         * Increment i modulo len. </span><br><span class=\"line\">         */</span><br><span class=\"line\">        private static int nextIndex(int i, int len) &#123;</span><br><span class=\"line\">            return ((i + 1 &lt; len) ? i + 1 : 0);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * Decrement i modulo len.</span><br><span class=\"line\">         */</span><br><span class=\"line\">        private static int prevIndex(int i, int len) &#123;</span><br><span class=\"line\">            return ((i - 1 &gt;= 0) ? i - 1 : len - 1);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>而且可以看到这个<code>Entry</code>把<code>ThreadLocal</code>的弱引用作为key。那为什么要搞成弱引用(只要发生了GC弱引用对象就会被回收)呢？</p>\n<p>首先<code>ThreadLocal</code>内部没有存储任何的值，它的作用只是当我们的<code>ThreadLocalMap的key</code>，让线程可以拿到对应的<code>value</code>。当我们不需要用这个key的时候我们，我们把<code>fooLocal=null</code>这样强引用就没了。假设Entry里面也是强引用的话，那等于这个<code>ThreadLocal</code>实例还有个强引用在，那么我们想让GC回收<code>fooLocal</code>就回收不了了。那可能有人想，你弄成弱引用不是很危险啊，万一GC一下不是没了？别怕只要<code>fooLocal</code>这个强引用在这个<code>ThreadLocal</code>实例就不会回收的。(关于强软弱虚引用可以看我之前的文章<a href=\"https://juejin.im/post/5cd386be51882511282b8746\" target=\"_blank\" rel=\"noopener\">四种引用方式的区别</a>)</p>\n<p>因此弄成弱引用，主要是让没用的<code>ThreadLocal</code>得以GC清除。</p>\n<p>这里可能还有人问那key清除掉了，value咋办，这个Entry还在的呀。是的，当在使用线程池的情况下，由于线程的生命周期很长，某些大对象的key被移除了之后，value一直存在的就可能会导致内存泄漏。</p>\n<p>不过java考虑到这点了。当调用<code>get()、set()</code>方法时会去找到那个key被干掉的entry然后干掉它。并且提供了<code>remove()</code>方法。虽然<code>get()、set()</code>会清理<code>key</code>为<code>null的Entry</code>,但是不是每次调用就会清理的，只有当<code>get</code>时候直接hash没中，或者<code>set</code>时候也是直接hash没中，开始线性探测时候，碰到key为null的才会清理。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//get 方法</span><br><span class=\"line\">        private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class=\"line\">            int i = key.threadLocalHashCode &amp;amp; (table.length - 1);</span><br><span class=\"line\">            Entry e = table[i];</span><br><span class=\"line\">            if (e != null &amp;amp;&amp;amp; e.get() == key)</span><br><span class=\"line\">                return e;                           //命中就直接返回</span><br><span class=\"line\">            else</span><br><span class=\"line\">                return getEntryAfterMiss(key, i, e); //直接没命中</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class=\"line\">            Entry[] tab = table;</span><br><span class=\"line\">            int len = tab.length;</span><br><span class=\"line\">            while (e != null) &#123; //开始探测了</span><br><span class=\"line\">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">                if (k == key)  //命中了就返回</span><br><span class=\"line\">                    return e;</span><br><span class=\"line\">                if (k == null)  //探测到key是null的就清理</span><br><span class=\"line\">                    expungeStaleEntry(i);</span><br><span class=\"line\">                else</span><br><span class=\"line\">                    i = nextIndex(i, len); //否则继续</span><br><span class=\"line\">                e = tab[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //set 方法</span><br><span class=\"line\">        private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class=\"line\">            Entry[] tab = table;</span><br><span class=\"line\">            int len = tab.length;</span><br><span class=\"line\">            int i = key.threadLocalHashCode &amp;amp; (len-1);</span><br><span class=\"line\">            for (Entry e = tab[i];</span><br><span class=\"line\">                 e != null;</span><br><span class=\"line\">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">                if (k == key) &#123;</span><br><span class=\"line\">                    e.value = value;    //如果已经有就替换原有的value</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (k == null) &#123;</span><br><span class=\"line\">                    replaceStaleEntry(key, value, i);</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tab[i] = new Entry(key, value);</span><br><span class=\"line\">            int sz = ++size;</span><br><span class=\"line\">            if (!cleanSomeSlots(i, sz) &amp;amp;&amp;amp; sz &gt;= threshold)</span><br><span class=\"line\">                rehash();</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>因此，当不需要<code>threadlocal</code>的时候还是显示调用<code>remove()</code>方法较好。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>线程本地存储本质就是<strong>避免共享</strong>，在使用中注意内存泄露问题和hash碰撞问题即可。使用还是很广泛的像spring中事务就用到<code>threadlocal</code>。</p>\n<hr>\n<p>如有错误欢迎指正！</p>\n<p>个人公众号:yes的练级攻略</p>\n<p>有相关面试进阶(分布式、性能调优、经典书籍pdf)资料等待领取</p>\n","text":"本文转载自 https://juejin.im/post/5cd2dcf4f265da03804386d0 一般有多个孩子的家庭，买玩具都得买多个。如果就买一个，嘿嘿就比较刺激了。这就是避免共享，给孩子每人一个玩具对应到我们Java中也就是每个线程都有自己的本地变量，咱们自己玩自","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]},{"title":"解读 JUC —— AQS 独占模式","slug":"解读JUC——AQS独占模式","date":"2019-05-10T07:21:06.000Z","updated":"2019-05-30T00:52:25.434Z","comments":true,"pin":null,"path":"api/articles/解读JUC——AQS独占模式.json","excerpt":"","keywords":null,"cover":"https://user-gold-cdn.xitu.io/2019/5/8/16a939a72c2cb3ce?imageView2/0/w/1280/h/960/ignore-error/1","content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5cd1d1876fb9a031eb58ae4d\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5cd1d1876fb9a031eb58ae4d</a> </p>\n</blockquote>\n<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>说起 JUC，我们常常会想起其中的线程池（ExecutorService）。然而，我们今天来看看另一个核心模块 AQS。</p>\n<p>AQS 是 AbstractQueuedSynchronizer 的简称，在 JUC 中作为各种同步器的基石。举个例子，常见的 ReentrantLock 就是由它实现的。</p>\n<h1 id=\"2-如何实现一个锁？\"><a href=\"#2-如何实现一个锁？\" class=\"headerlink\" title=\"2. 如何实现一个锁？\"></a>2. 如何实现一个锁？</h1><p>我们知道，java 有一个关键字 synchronized 来给一段代码加锁，可是这是 JVM 层面的事情。那么问题来了，如何在 java 代码层面来实现模拟一个锁？</p>\n<p>即实现这样一个接口：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package java.util.concurrent.locks;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface Lock &#123;</span><br><span class=\"line\">    void lock();</span><br><span class=\"line\"></span><br><span class=\"line\">    void unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h2><p>一个简单的想法是：让所有线程去竞争一个变量owner，确保只有一个线程成功，并设置自己为owner，其他线程陷入死循环等待。这便是所谓的<strong>自旋锁</strong>。</p>\n<p>一个简单的代码实现：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.concurrent.atomic.AtomicReference;</span><br><span class=\"line\"></span><br><span class=\"line\">public class SpinLock &#123;</span><br><span class=\"line\">   private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;Thread&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">   public void lock() &#123;</span><br><span class=\"line\">       Thread currentThread = Thread.currentThread();</span><br><span class=\"line\"></span><br><span class=\"line\">       // 如果锁未被占用，则设置当前线程为锁的拥有者</span><br><span class=\"line\">       while (!owner.compareAndSet(null, currentThread)) &#123;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   public void unlock() &#123;</span><br><span class=\"line\">       Thread currentThread = Thread.currentThread();</span><br><span class=\"line\"></span><br><span class=\"line\">       // 只有锁的拥有者才能释放锁</span><br><span class=\"line\">       owner.compareAndSet(currentThread, null);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>扯这个自旋锁，主要是为了引出 AQS 背后的算法 <code>CLH锁</code>。</p>\n<p>关于<code>CLH锁</code>更多细节可以参考篇文章：</p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fcoderbee.net%2Findex.php%2Fconcurrent%2F20131115%2F577\" target=\"_blank\" rel=\"noopener\">自旋锁、排队自旋锁、MCS锁、CLH锁</a></p>\n<h1 id=\"3-AQS-的实现\"><a href=\"#3-AQS-的实现\" class=\"headerlink\" title=\"3. AQS 的实现\"></a>3. AQS 的实现</h1><p>CLH锁的思想，简单的说就是：一群人去ATM取钱，头一个人拿到锁，在里面用银行卡取钱，其余的人在后面<strong>排队等待</strong>；前一个人取完钱出来，<strong>唤醒</strong>下一个人进去取钱。</p>\n<p>关键部分翻译成代码就是：</p>\n<ul>\n<li>排队 -&gt; 队列</li>\n<li>等待/唤醒 -&gt; wait()/notify() 或者别的什么 api </li>\n</ul>\n<h2 id=\"3-1-同步队列\"><a href=\"#3-1-同步队列\" class=\"headerlink\" title=\"3.1 同步队列\"></a>3.1 同步队列</h2><p>AQS 使用节点为 Node 的双向链表作为<strong>同步队列</strong>。拿到锁的线程可以继续执行代码，没拿到的线程就进入这个队列排队。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class AbstractQueuedSynchronizer ... &#123;</span><br><span class=\"line\">    // 队列头</span><br><span class=\"line\">    private transient volatile Node head;</span><br><span class=\"line\">    // 队列尾</span><br><span class=\"line\">    private transient volatile Node tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    static final class Node &#123;</span><br><span class=\"line\">        /** 共享模式，可用于实现 CountDownLatch */</span><br><span class=\"line\">        static final Node SHARED = new Node();</span><br><span class=\"line\">        /** 独占模式，可用于实现 ReentrantLock */</span><br><span class=\"line\">        static final Node EXCLUSIVE = null;</span><br><span class=\"line\">\t</span><br><span class=\"line\">        /** 取消 */</span><br><span class=\"line\">        static final int CANCELLED =  1;</span><br><span class=\"line\">        /** 意味着它的后继节点的线程在排队，等待被唤醒 */</span><br><span class=\"line\">        static final int SIGNAL    = -1;</span><br><span class=\"line\">        /** 等待在条件上（与Condition相关，暂不解释） */</span><br><span class=\"line\">        static final int CONDITION = -2;</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 与共享模式相关，暂不解释</span><br><span class=\"line\">         */</span><br><span class=\"line\">        static final int PROPAGATE = -3;</span><br><span class=\"line\">\t</span><br><span class=\"line\">        // 可取值：CANCELLED, 0, SIGNAL, CONDITION, PROPAGATE</span><br><span class=\"line\">        volatile int waitStatus;</span><br><span class=\"line\">\t</span><br><span class=\"line\">        volatile Node prev;</span><br><span class=\"line\">\t</span><br><span class=\"line\">        volatile Node next;</span><br><span class=\"line\">\t</span><br><span class=\"line\">        volatile Thread thread;</span><br><span class=\"line\">\t    </span><br><span class=\"line\">        Node nextWaiter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>这个队列大体上长这样：<a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fa8d27ba5db49\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/8/16a939a72c2cb3ce?imageView2/0/w/1280/h/960/ignore-error/1\" alt=\"sync queue\"></p>\n<p>条件队列是为了支持 Lock.newCondition() 这个功能，暂时不care，先跳过。</p>\n<h2 id=\"3-2-独占模式的-api\"><a href=\"#3-2-独占模式的-api\" class=\"headerlink\" title=\"3.2 独占模式的 api\"></a>3.2 独占模式的 api</h2><p>AQS 支持独占锁（Exclusive）和共享锁（Share）两种模式：</p>\n<ul>\n<li>独占锁：只能被一个线程获取到 (ReentrantLock)；</li>\n<li>共享锁：可以被多个线程同时获取 (CountDownLatch、ReadWriteLock 的读锁)。</li>\n</ul>\n<p>这边我们只看独占模式，它对外提供一套 api：</p>\n<ul>\n<li>acquire(int n)：获取n个资源（锁）</li>\n<li>release(int n)：释放n个资源（锁）</li>\n</ul>\n<p>简单看一眼怎么用的 (ReentrantLock 的例子):</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ReentrantLock implements Lock, java.io.Serializable &#123;</span><br><span class=\"line\">    private final Sync sync;</span><br><span class=\"line\">    </span><br><span class=\"line\">    abstract static class Sync extends AbstractQueuedSynchronizer &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void lock() &#123;</span><br><span class=\"line\">        sync.acquire(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void unlock() &#123;</span><br><span class=\"line\">        sync.release(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>可以看到，AQS 封装了排队、阻塞、唤醒之类的操作，使得实现一个锁变的如此简洁。</p>\n<h2 id=\"3-2-1-acquire-int\"><a href=\"#3-2-1-acquire-int\" class=\"headerlink\" title=\"3.2.1 acquire(int)\"></a>3.2.1 acquire(int)</h2><p>获取资源</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final void acquire(int arg) &#123;</span><br><span class=\"line\">    if (!tryAcquire(arg) &amp;amp;&amp;amp;</span><br><span class=\"line\">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">protected boolean tryAcquire(int arg) &#123;</span><br><span class=\"line\">    throw new UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>这个函数很短，其中 tryAcquire(int) 为模板方法，留给子类实现。类似 Activity.onCreate()。</p>\n<p>根据 tryAcquire(arg) 的结果，分两种情况：</p>\n<pre><code>* 返回 true: 该线程拿到锁，由于短路，直接跳出 if，该线程可以往下执行自己的业务代码。\n* 返回 false: 该线程没有拿到锁，会继续走 acquireQueued()，执行排队等待逻辑。</code></pre><h3 id=\"3-2-1-1-addWaiter-Node\"><a href=\"#3-2-1-1-addWaiter-Node\" class=\"headerlink\" title=\"3.2.1.1 addWaiter(Node)\"></a>3.2.1.1 addWaiter(Node)</h3><p>这一步把当前线程（Thread.currentThread()）作为一个Node节点，加入同步队列的尾部，并标记为独占模式。</p>\n<p>当然，加入队列这个动作，要保证<strong>线程安全</strong>。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Node addWaiter(Node mode) &#123;</span><br><span class=\"line\">    Node node = new Node(Thread.currentThread(), mode);</span><br><span class=\"line\">    // 1处尝试更快地 enq(), 成功的话直接 return。失败的话, 在2处退化为完整版的 enq()，相对更慢些</span><br><span class=\"line\">    Node pred = tail;</span><br><span class=\"line\">    if (pred != null) &#123;</span><br><span class=\"line\">        node.prev = pred;</span><br><span class=\"line\">        if (compareAndSetTail(pred, node)) &#123; // 1</span><br><span class=\"line\">            pred.next = node;</span><br><span class=\"line\">            return node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    enq(node); // 2</span><br><span class=\"line\">    return node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private Node enq(final Node node) &#123;</span><br><span class=\"line\">    // 神奇的死循环 + CAS</span><br><span class=\"line\">    for (;;) &#123;</span><br><span class=\"line\">        Node t = tail;</span><br><span class=\"line\">        if (t == null) &#123; // Must initialize</span><br><span class=\"line\">            if (compareAndSetHead(new Node()))</span><br><span class=\"line\">                tail = head;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            node.prev = t;</span><br><span class=\"line\">            if (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">                t.next = node;</span><br><span class=\"line\">                return t;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>可以看到，这边有一个<strong>死循环 + CAS</strong>的神奇操作，这是非阻塞算法的经典操作，可自行查阅相关资料。简单的说，非阻塞算法就是在多线程的情况下，不加锁同时保证某个变量（本例中为双向链表）的线程安全，而且通常比 synchronized 的效率要高。</p>\n<h3 id=\"3-2-1-2-acquireQueued-Node，int\"><a href=\"#3-2-1-2-acquireQueued-Node，int\" class=\"headerlink\" title=\"3.2.1.2 acquireQueued(Node，int)\"></a>3.2.1.2 acquireQueued(Node，int)</h3><p>这个函数主要做两件事：</p>\n<pre><code>* 查看prev的waitStatus，看是不是需要阻塞，需要的话阻塞该线程\n* 排在队首的家伙调用了release()，会唤醒老二。老二尝试去获得锁，成功的话自己变成队首，跳出循环。</code></pre><p>结合这张图来看，每次出队完需要确保 head 始终指向占用资源的线程：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/8/16a939a72c3d316d?imageView2/0/w/1280/h/960/ignore-error/1\" alt=\"sync queue\"></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class=\"line\">    boolean failed = true;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        boolean interrupted = false;</span><br><span class=\"line\">        // 这又是一个死循环 + CAS，这次CAS比较隐蔽，在 shouldParkAfterFailedAcquire()里边</span><br><span class=\"line\">        for (;;) &#123;</span><br><span class=\"line\">            final Node p = node.predecessor();</span><br><span class=\"line\">            if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) &#123; // 排在队首的后面，看看能不能获得锁，成功的话自己变成队首</span><br><span class=\"line\">                setHead(node);</span><br><span class=\"line\">                p.next = null; // help GC</span><br><span class=\"line\">                failed = false;</span><br><span class=\"line\">                return interrupted;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                interrupted = true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        // 这里失败会做一些回滚操作，不分析</span><br><span class=\"line\">        if (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>这边的 interrupted 主要是保证这样一个功能。线程在排队的时候不响应中断，直到出来以后，如果等待的过程中被中断过，作为弥补，立即相应中断（即调用selfInterrupt()）。</p>\n<h3 id=\"shouldParkAfterFailedAcquire\"><a href=\"#shouldParkAfterFailedAcquire\" class=\"headerlink\" title=\"shouldParkAfterFailedAcquire()\"></a>shouldParkAfterFailedAcquire()</h3><p>查看prev的waitStatus，看是不是需要阻塞。可以预见的是，经过几次死循环，全部都会变成SIGNAL状态。之后全部陷入阻塞。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class=\"line\">    int ws = pred.waitStatus; // 查看前驱节点的状态</span><br><span class=\"line\">    if (ws == Node.SIGNAL) // SIGNAL: 可以安全的阻塞</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    if (ws &gt; 0) &#123; // CANCEL: 取消排队的节点，直接从队列中清除。</span><br><span class=\"line\">        do &#123;</span><br><span class=\"line\">            node.prev = pred = pred.prev;</span><br><span class=\"line\">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class=\"line\">        pred.next = node;</span><br><span class=\"line\">    &#125; else &#123; // 0 or PROPAGATE: 需要变成 SIGNAL，但不能立即阻塞，需要重走外层的死循环二次确认。</span><br><span class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class=\"line\">    LockSupport.park(this);</span><br><span class=\"line\">    return Thread.interrupted();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>值得一提的是，阻塞和唤醒没有使用常说的 wait()/notify()，而是使用了 LockSupport.park()/unpark()。只有使用 synchronized 获取锁的对象才能使用 wait，ReentrantLock.newCondition 提供的 await/signal 也是 LockSupport.park()/unpark() 实现的。<br>参考 <a href=\"https://pqpo.me/2019/01/30/learn-java-lock-block/\" target=\"_blank\" rel=\"noopener\">https://pqpo.me/2019/01/30/learn-java-lock-block/</a></p>\n<h2 id=\"3-2-2-release-int\"><a href=\"#3-2-2-release-int\" class=\"headerlink\" title=\"3.2.2 release(int)\"></a>3.2.2 release(int)</h2><p>释放资源</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final boolean release(int arg) &#123;</span><br><span class=\"line\">    if (tryRelease(arg)) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        if (h != null &amp;amp;&amp;amp; h.waitStatus != 0)</span><br><span class=\"line\">            unparkSuccessor(h);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private void unparkSuccessor(Node node) &#123;</span><br><span class=\"line\">    int ws = node.waitStatus;</span><br><span class=\"line\">    if (ws &lt; 0)</span><br><span class=\"line\">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * 唤醒next节点对应的线程，通常就是老二（直接后继）。</span><br><span class=\"line\">     * 如果是null，或者是cancel状态（出现异常如线程遇到空指针挂掉了），</span><br><span class=\"line\">     * 那么跳过cancel节点，找到后继节点。</span><br><span class=\"line\">     */</span><br><span class=\"line\">    Node s = node.next;</span><br><span class=\"line\">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class=\"line\">        s = null;</span><br><span class=\"line\">        for (Node t = tail; t != null &amp;amp;&amp;amp; t != node; t = t.prev)</span><br><span class=\"line\">            if (t.waitStatus &lt;= 0)</span><br><span class=\"line\">                s = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 唤醒 node.next</span><br><span class=\"line\">    if (s != null)</span><br><span class=\"line\">        LockSupport.unpark(s.thread);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>释放的逻辑比较简单。注意一点，对于 next 节点 unpark()，相当于在把 next 节点从 acquireQueued() 中的死循环中解放出来。</p>\n<p>回到 ATM 的例子，相当于，他取完钱，轮到后一个人取钱了。这样逻辑全部都串起来了。</p>\n<h1 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h1><p>这样，顺着独占锁这条线，AQS 的独占模式就分析完了。其他还有用于实现闭锁的共享模式，用于实现 Condition 的条件队列就不展开了。</p>\n<h1 id=\"5-参考\"><a href=\"#5-参考\" class=\"headerlink\" title=\"5. 参考\"></a>5. 参考</h1><p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fmy.oschina.net%2FUBW%2Fblog%2F2995774\" target=\"_blank\" rel=\"noopener\">Java并发编程实战（chapter_4）（AQS源码分析）</a></p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fa8d27ba5db49\" target=\"_blank\" rel=\"noopener\">JUC源码分析—AQS</a></p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fcoderbee.net%2Findex.php%2Fconcurrent%2F20131115%2F577\" target=\"_blank\" rel=\"noopener\">自旋锁、排队自旋锁、MCS锁、CLH锁</a></p>\n<p>《JAVA并发编程实践》</p>\n","text":"本文转载自 https://juejin.im/post/5cd1d1876fb9a031eb58ae4d 1. 前言说起 JUC，我们常常会想起其中的线程池（ExecutorService）。然而，我们今天来看看另一个核心模块 AQS。AQS 是 AbstractQueuedS","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"},{"name":"源码","slug":"源码","count":1,"path":"api/tags/源码.json"}]},{"title":"死磕Java内部类（一篇就够）","slug":"死磕Java内部类（一篇就够）","date":"2019-06-18T07:18:46.046Z","updated":"2019-06-18T07:18:47.860Z","comments":true,"pin":null,"path":"api/articles/死磕Java内部类（一篇就够）.json","excerpt":"","keywords":null,"cover":"https://user-gold-cdn.xitu.io/2019/6/18/16b67c1a51958f99?imageView2/0/w/1280/h/960/ignore-error/1","content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5d0821315188254c434686c8\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5d0821315188254c434686c8</a><br>Java内部类，相信大家都用过，但是多数同学可能对它了解的并不深入，只是靠记忆来完成日常工作，却不能融会贯通，遇到奇葩问题更是难以有思路去解决。这篇文章带大家一起死磕Java内部类的方方面面。 友情提示：这篇文章的讨论基于JDK版本 1.8.0_191</p>\n</blockquote>\n<h3 id=\"开篇问题\"><a href=\"#开篇问题\" class=\"headerlink\" title=\"开篇问题\"></a>开篇问题</h3><p>我一直觉得技术是工具，是一定要落地的，要切实解决某些问题的，所以我们通过先抛出问题，然后解决这些问题，在这个过程中来加深理解，最容易有收获。 so，先抛出几个问题。（如果这些问题你早已思考过，答案也了然于胸，那恭喜你，这篇文章可以关掉了）。</p>\n<pre><code>* **为什么需要内部类？**\n* **为什么内部类（包括匿名内部类、局部内部类），会持有外部类的引用？**\n* **为什么匿名内部类使用到外部类方法中的局部变量时需要是final类型的？**\n* **如何创建内部类实例，如何继承内部类？**\n* **Lambda表达式是如何实现的？**</code></pre><h3 id=\"为什么需要内部类\"><a href=\"#为什么需要内部类\" class=\"headerlink\" title=\"为什么需要内部类?\"></a>为什么需要内部类?</h3><p>要回答这个问题，先要弄明白什么是内部类？我们知道Java有三种类型的内部类</p>\n<h3 id=\"普通的内部类\"><a href=\"#普通的内部类\" class=\"headerlink\" title=\"普通的内部类\"></a>普通的内部类</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 普通内部类</span><br><span class=\"line\">    public class DemoRunnable implements Runnable &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 匿名内部类</span><br><span class=\"line\">    private Runnable runnable = new Runnable() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"方法内局部内部类\"><a href=\"#方法内局部内部类\" class=\"headerlink\" title=\"方法内局部内部类\"></a>方法内局部内部类</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 局部内部类</span><br><span class=\"line\">    public void work() &#123;</span><br><span class=\"line\">        class InnerRunnable implements Runnable &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        InnerRunnable runnable = new InnerRunnable();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>这三种形式的内部类，大家肯定都用过，但是技术在设计之初肯定也是要用来解决某个问题或者某个痛点，那可以想想内部类相对比外部定义类有什么优势呢？ 我们通过一个小例子来做说明</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Worker &#123;</span><br><span class=\"line\">    private List&lt;Job&gt; mJobList = new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    public void addJob(Runnable task) &#123;</span><br><span class=\"line\">        mJobList.add(new Job(task));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private class Job implements Runnable &#123;</span><br><span class=\"line\">        Runnable task;</span><br><span class=\"line\">        public  Job(Runnable task) &#123;</span><br><span class=\"line\">            this.task = task;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            runnable.run();</span><br><span class=\"line\">            System.out.println(&quot;left job size : &quot; + mJobList.size());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>定义了一个Worker类，暴露了一个addJob方法，一个参数task，类型是Runnable，然后定义 了一个内部类Job类对task进行了一层封装，这里Job是私有的，所以外界是感知不到Job的存在的，所以有了内部类第一个优势。</p>\n<pre><code>* **内部类能够更好的封装，内聚，屏蔽细节**</code></pre><p>我们在Job的run方法中，打印了外部Worker的mJobList列表中剩余Job数量，代码这样写没问题，但是细想，内部类是如何拿到外部类的成员变量的呢？这里先卖个关子，但是已经可以先得出内部类的第二个优势了。</p>\n<pre><code>* **内部类天然有访问外部类成员变量的能力**</code></pre><p>内部类主要就是上面的二个优势。当然还有一些其他的小优点，比如可以用来实现多重继承，可以将逻辑内聚在一个类方便维护等，这些见仁见智，先不去说它们。</p>\n<p>我们接着看第二个问题！！！</p>\n<h3 id=\"为什么内部类（包括匿名内部类、局部内部类），会持有外部类的引用？\"><a href=\"#为什么内部类（包括匿名内部类、局部内部类），会持有外部类的引用？\" class=\"headerlink\" title=\"为什么内部类（包括匿名内部类、局部内部类），会持有外部类的引用？\"></a>为什么内部类（包括匿名内部类、局部内部类），会持有外部类的引用？</h3><p>问这个问题，显得我是个杠精，您先别着急，其实我想问的是，内部类Java是怎么实现的。 我们还是举例说明，先以普通的内部类为例</p>\n<h3 id=\"普通内部类的实现\"><a href=\"#普通内部类的实现\" class=\"headerlink\" title=\"普通内部类的实现\"></a>普通内部类的实现</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo &#123;</span><br><span class=\"line\">    // 普通内部类</span><br><span class=\"line\">    public class DemoRunnable implements Runnable &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>切到Demo.java所在文件夹，命令行执行 javac Demo.java，在Demo类同目录下可以看到生成了二个class文件</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/6/18/16b67c1a51958f99?imageView2/0/w/1280/h/960/ignore-error/1\" alt=\"普通内部类生成class.png\"></p>\n<p>Demo.class很好理解，另一个 类</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Demo$DemoRunnable.class</span><br></pre></td></tr></table></figure></div>\n\n<p>就是我们的内部类编译出来的，它的命名也是有规律的，外部类名Demo+$+内部类名DemoRunnable。 查看反编译后的代码（IntelliJ IDEA本身就支持，直接查看class文件即可）</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package inner;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Demo$DemoRunnable implements Runnable &#123;</span><br><span class=\"line\">    public Demo$DemoRunnable(Demo var1) &#123;</span><br><span class=\"line\">        this.this$0 = var1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>生成的类只有一个构造器，参数就是Demo类型，而且保存到内部类本身的this$0字段中。到这里我们其实已经可以想到，内部类持有的外部类引用就是通过这个构造器传递进来的，它是一个强引用。</p>\n<h3 id=\"验证我们的想法\"><a href=\"#验证我们的想法\" class=\"headerlink\" title=\"验证我们的想法\"></a>验证我们的想法</h3><p>怎么验证呢？我们需要在Demo.class类中加一个方法，来实例化这个DemoRunnable内部类对象</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Demo.java</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        DemoRunnable demoRunnable = new DemoRunnable();</span><br><span class=\"line\">        demoRunnable.run();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>再次执行 javac Demo.java，再执行javap -verbose Demo.class，查看Demo类的字节码，前方高能，需要一些字节码知识，这里我们重点关注run方法（插一句题外话，字节码简单的要能看懂，-。-）</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void run();</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: ACC_PUBLIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=3, locals=2, args_size=1</span><br><span class=\"line\">         0: new           #2                  // class inner/Demo$DemoRunnable</span><br><span class=\"line\">         3: dup</span><br><span class=\"line\">         4: aload_0</span><br><span class=\"line\">         5: invokespecial #3                  // Method inner/Demo$DemoRunnable.&quot;&lt;init&gt;&quot;:(Linner/Demo;)V</span><br><span class=\"line\">         8: astore_1</span><br><span class=\"line\">         9: aload_1</span><br><span class=\"line\">        10: invokevirtual #4                  // Method inner/Demo$DemoRunnable.run:()V</span><br><span class=\"line\">        13: return</span><br></pre></td></tr></table></figure></div>\n\n<pre><code>* **先通过new指令，新建了一个Demo$DemoRunnable对象**\n* **aload_0指令将外部类Demo对象自身加载到栈帧中**\n* **调用Demo$DemoRunnable类的init方法，注意这里将Demo对象作为了参数传递进来了**</code></pre><p>到这一步其实已经很清楚了，就是将外部类对象自身作为参数传递给了内部类构造器，与我们上面的猜想一致。</p>\n<h3 id=\"匿名内部类的实现\"><a href=\"#匿名内部类的实现\" class=\"headerlink\" title=\"匿名内部类的实现\"></a>匿名内部类的实现</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo &#123;</span><br><span class=\"line\">    // 匿名内部类</span><br><span class=\"line\">    private Runnable runnable = new Runnable() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>同样执行javac Demo.java，这次多生成了一个Demo$1.class，反编译查看代码</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package inner;</span><br><span class=\"line\"></span><br><span class=\"line\">class Demo$1 implements Runnable &#123;</span><br><span class=\"line\">    Demo$1(Demo var1) &#123;</span><br><span class=\"line\">        this.this$0 = var1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>可以看到匿名内部类和普通内部类实现基本一致，只是编译器自动给它拼了个名字，所以匿名内部类不能自定义构造器，因为名字编译完成后才能确定。 方法局部内部类，我这里就不赘述了，原理都是一样的，大家可以自行试验。 这样我们算是解答了第二个问题，来看第三个问题。</p>\n<h3 id=\"为什么匿名内部类使用到外部类方法中的局部变量时需要是final类型的？\"><a href=\"#为什么匿名内部类使用到外部类方法中的局部变量时需要是final类型的？\" class=\"headerlink\" title=\"为什么匿名内部类使用到外部类方法中的局部变量时需要是final类型的？\"></a>为什么匿名内部类使用到外部类方法中的局部变量时需要是final类型的？</h3><p>这里先申明一下，这个问题本身是有问题的，问题在哪呢？因为java8中并不一定需要声明为final。我们来看个例子</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Demo.java</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        int age = 10;</span><br><span class=\"line\">        Runnable runnable = new Runnable() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                int myAge = age + 1;</span><br><span class=\"line\">                System.out.println(myAge);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>匿名内部类对象runnable，使用了外部类方法中的age局部变量。编译运行完全没问题，而age并没有final修饰啊！ 那我们再在run方法中，尝试修改age试试</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void run() &#123;</span><br><span class=\"line\">        int age = 10;</span><br><span class=\"line\">        Runnable runnable = new Runnable() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                int myAge = age + 1;</span><br><span class=\"line\">                System.out.println(myAge);</span><br><span class=\"line\">                age = 20;   // error</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>编译器报错了，提示信息是”age is access from inner class, need to be final or effectively final“。很显然编译器很智能，由于我们第一个例子并没有修改age的值，所以编译器认为这是effectively final，是安全的，可以编译通过，而第二个例子尝试修改age的值，编译器立马就报错了。</strong></p>\n<h3 id=\"外部类变量是怎么传递给内部类的？\"><a href=\"#外部类变量是怎么传递给内部类的？\" class=\"headerlink\" title=\"外部类变量是怎么传递给内部类的？\"></a>外部类变量是怎么传递给内部类的？</h3><p>这里对于变量的类型分三种情况分别来说明</p>\n<h3 id=\"非final局部变量\"><a href=\"#非final局部变量\" class=\"headerlink\" title=\"非final局部变量\"></a>非final局部变量</h3><p>我们去掉尝试修改age的代码，然后执行javac Demo.java，查看Demo$1.class的实现代码</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package inner;</span><br><span class=\"line\"></span><br><span class=\"line\">class Demo$1 implements Runnable &#123;</span><br><span class=\"line\">    Demo$1(Demo var1, int var2) &#123;</span><br><span class=\"line\">        this.this$0 = var1;</span><br><span class=\"line\">        this.val$age = var2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        int var1 = this.val$age + 1;</span><br><span class=\"line\">        System.out.println(var1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>可以看到对于非final局部变量，是通过构造器的方式传递进来的。</p>\n<h3 id=\"final局部变量\"><a href=\"#final局部变量\" class=\"headerlink\" title=\"final局部变量\"></a>final局部变量</h3><p>age修改为final</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void run() &#123;</span><br><span class=\"line\">        final int age = 10;</span><br><span class=\"line\">        Runnable runnable = new Runnable() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                int myAge = age + 1;</span><br><span class=\"line\">                System.out.println(myAge);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>同样执行javac Demo.java，查看Demo$1.class的实现代码</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Demo$1 implements Runnable &#123;</span><br><span class=\"line\">    Demo$1(Demo var1) &#123;</span><br><span class=\"line\">        this.this$0 = var1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        byte var1 = 11;</span><br><span class=\"line\">        System.out.println(var1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>可以看到编译器很聪明的做了优化，age是final的，所以在编译期间是确定的，直接将+1优化为11。 为了测试编译器的智商，我们把age的赋值修改一下，改为运行时才能确定的，看编译器如何应对</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void run() &#123;</span><br><span class=\"line\">        final int age = (int) System.currentTimeMillis();</span><br><span class=\"line\">        Runnable runnable = new Runnable() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                int myAge = age + 1;</span><br><span class=\"line\">                System.out.println(myAge);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>再看Demo$1 字节码实现</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Demo$1 implements Runnable &#123;</span><br><span class=\"line\">    Demo$1(Demo var1, int var2) &#123;</span><br><span class=\"line\">        this.this$0 = var1;</span><br><span class=\"line\">        this.val$age = var2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        int var1 = this.val$age + 1;</span><br><span class=\"line\">        System.out.println(var1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>编译器意识到编译期age的值不能确定，所以还是采用构造器传参的形式实现。现代编译器还是很机智的。</strong></p>\n<h3 id=\"外部类成员变量\"><a href=\"#外部类成员变量\" class=\"headerlink\" title=\"外部类成员变量\"></a>外部类成员变量</h3><p>将age改为Demo的成员变量，注意没有加任何修饰符，是包级访问级别。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo &#123;</span><br><span class=\"line\">    int age = 10;</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        Runnable runnable = new Runnable() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                int myAge = age + 1;</span><br><span class=\"line\">                System.out.println(myAge);</span><br><span class=\"line\">                age = 20;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>javac Demo.java，查看匿名内部内的实现</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Demo$1 implements Runnable &#123;</span><br><span class=\"line\">    Demo$1(Demo var1) &#123;</span><br><span class=\"line\">        this.this$0 = var1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        int var1 = this.this$0.age + 1;</span><br><span class=\"line\">        System.out.println(var1);</span><br><span class=\"line\">        this.this$0.age = 20;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>这一次编译器直接通过外部类的引用操作age，没毛病，由于age是包访问级别，所以这样是最高效的。 如果将age改为private，编译器会在Demo类中生成二个方法，分别用于读取age和设置age，篇幅关系，这种情况留给大家自行测试。</p>\n<h3 id=\"解答为何局部变量传递给匿名内部类需要是final\"><a href=\"#解答为何局部变量传递给匿名内部类需要是final\" class=\"headerlink\" title=\"解答为何局部变量传递给匿名内部类需要是final?\"></a>解答为何局部变量传递给匿名内部类需要是final?</h3><p><strong>通过上面的例子可以看到，不是一定需要局部变量是final的，但是你不能在匿名内部类中修改外部局部变量，因为Java对于匿名内部类传递变量的实现是基于构造器传参的，也就是说如果允许你在匿名内部类中修改值，你修改的是匿名内部类中的外部局部变量副本，最终并不会对外部类产生效果，因为已经是二个变量了。</strong> <strong>这样就会让程序员产生困扰，原以为修改会生效，事实上却并不会，所以Java就禁止在匿名内部类中修改外部局部变量。</strong></p>\n<h3 id=\"如何创建内部类实例，如何继承内部类？\"><a href=\"#如何创建内部类实例，如何继承内部类？\" class=\"headerlink\" title=\"如何创建内部类实例，如何继承内部类？\"></a>如何创建内部类实例，如何继承内部类？</h3><p>由于内部类对象需要持有外部类对象的引用，所以必须得先有外部类对象</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Demo.DemoRunnable demoRunnable = new Demo().new DemoRunnable();</span><br></pre></td></tr></table></figure></div>\n\n<p>那如何继承一个内部类呢，先给出示例</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo2 extends Demo.DemoRunnable &#123;</span><br><span class=\"line\">        public Demo2(Demo demo) &#123;</span><br><span class=\"line\">            demo.super();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            super.run();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>必须在构造器中传入一个Demo对象，并且还需要调用demo.super(); 看个例子</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DemoKata &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Demo2 demo2 = new DemoKata().new Demo2(new Demo());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public class Demo2 extends Demo.DemoRunnable &#123;</span><br><span class=\"line\">        public Demo2(Demo demo) &#123;</span><br><span class=\"line\">            demo.super();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            super.run();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>由于Demo2也是一个内部类，所以需要先new一个DemoKata对象。 这一个问题描述的场景可能用的并不多，一般也不这么去用，这里提一下，大家知道有这么回事就行。</p>\n<h3 id=\"Lambda表达式是如何实现的？\"><a href=\"#Lambda表达式是如何实现的？\" class=\"headerlink\" title=\"Lambda表达式是如何实现的？\"></a>Lambda表达式是如何实现的？</h3><p>Java8引入了Lambda表达式，一定程度上可以简化我们的代码，使代码结构看起来更优雅。做技术的还是要有刨根问底的那股劲，问问自己有没有想过Java中Lambda到底是如何实现的呢？</p>\n<p>来看一个最简单的例子</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Animal &#123;</span><br><span class=\"line\">    public void run(Runnable runnable) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>Animal类中定义了一个run方法，参数是一个Runnable对象，Java8以前，我们可以传入一个匿名内部类对象</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">run(new Runnable() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></div>\n\n<p>Java 8 之后编译器已经很智能的提示我们可以用Lambda表达式来替换。既然可以替换，那匿名内部类和Lambda表达式是不是底层实现是一样的呢，或者说Lambda表达式只是匿名内部类的语法糖呢？ 要解答这个问题，我们还是要去字节码中找线索。通过前面的知识，我们知道javac Animal.java命令将类编译成class，匿名内部类的方式会产生一个额外的类。那用Lambda表达式会不会也会编译新类呢？我们试一下便知。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void run(Runnable runnable) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void test() &#123;</span><br><span class=\"line\">        run(() -&gt; &#123;&#125;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>javac Animal.java，发现并没有生成额外的类！！！ 我们继续使用javap -verbose Animal.class来查看Animal.class的字节码实现，重点关注test方法</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void test();</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: ACC_PUBLIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=2, locals=1, args_size=1</span><br><span class=\"line\">         0: aload_0</span><br><span class=\"line\">         1: invokedynamic #2,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable;</span><br><span class=\"line\">         6: invokevirtual #3                  // Method run:(Ljava/lang/Runnable;)V</span><br><span class=\"line\">         9: return</span><br><span class=\"line\"></span><br><span class=\"line\">SourceFile: &quot;Demo.java&quot;</span><br><span class=\"line\">InnerClasses:</span><br><span class=\"line\">     public static final #34= #33 of #37; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</span><br><span class=\"line\">BootstrapMethods:</span><br><span class=\"line\">  0: #18 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class=\"line\">    Method arguments:</span><br><span class=\"line\">      #19 ()V</span><br><span class=\"line\">      #20 invokestatic com/company/inner/Demo.lambda$test$0:()V</span><br><span class=\"line\">      #19 ()V</span><br></pre></td></tr></table></figure></div>\n\n<p>发现test方法字节码中多了一个invokedynamic /#2 0指令，这是java7引入的新指令，其中/#2 指向</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#2 = InvokeDynamic      #0:#21         // #0:run:()Ljava/lang/Runnable;</span><br></pre></td></tr></table></figure></div>\n\n<p>而0代表BootstrapMethods方法表中的第一个，java/lang/invoke/LambdaMetafactory.metafactory方法被调用。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BootstrapMethods:</span><br><span class=\"line\">  0: #18 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class=\"line\">    Method arguments:</span><br><span class=\"line\">      #19 ()V</span><br><span class=\"line\">      #20 invokestatic com/company/inner/Demo.lambda$test$0:()V</span><br><span class=\"line\">      #19 ()V</span><br></pre></td></tr></table></figure></div>\n\n<p>这里面我们看到了com/company/inner/Demo.lambda$test$0这么个东西，看起来跟我们的匿名内部类的名称有些类似，而且中间还有lambda，有可能就是我们要找的生成的类。 我们不妨验证下我们的想法，可以通过下面的代码打印出Lambda对象的真实类名。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void run(Runnable runnable) &#123;</span><br><span class=\"line\">        System.out.println(runnable.getClass().getCanonicalName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void test() &#123;</span><br><span class=\"line\">        run(() -&gt; &#123;&#125;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>打印出runnable的类名，结果如下</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.company.inner.Demo$$Lambda$1/764977973</span><br></pre></td></tr></table></figure></div>\n\n<p>跟我们上面的猜测并不完全一致，我们继续找别的线索，既然我们有看到LambdaMetafactory.metafactory这个类被调用，不妨继续跟进看下它的实现</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static CallSite metafactory(MethodHandles.Lookup caller,</span><br><span class=\"line\">                                       String invokedName,</span><br><span class=\"line\">                                       MethodType invokedType,</span><br><span class=\"line\">                                       MethodType samMethodType,</span><br><span class=\"line\">                                       MethodHandle implMethod,</span><br><span class=\"line\">                                       MethodType instantiatedMethodType)</span><br><span class=\"line\">            throws LambdaConversionException &#123;</span><br><span class=\"line\">        AbstractValidatingLambdaMetafactory mf;</span><br><span class=\"line\">        mf = new InnerClassLambdaMetafactory(caller, invokedType,</span><br><span class=\"line\">                                             invokedName, samMethodType,</span><br><span class=\"line\">                                             implMethod, instantiatedMethodType,</span><br><span class=\"line\">                                             false, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);</span><br><span class=\"line\">        mf.validateMetafactoryArgs();</span><br><span class=\"line\">        return mf.buildCallSite();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>内部new了一个InnerClassLambdaMetafactory对象。看名字很可疑，继续跟进</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public InnerClassLambdaMetafactory(...)</span><br><span class=\"line\">            throws LambdaConversionException &#123;</span><br><span class=\"line\">        //....</span><br><span class=\"line\">        lambdaClassName = targetClass.getName().replace(&apos;.&apos;, &apos;/&apos;) + &quot;$$Lambda$&quot; + counter.incrementAndGet();</span><br><span class=\"line\">        cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);</span><br><span class=\"line\">       //....</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>省略了很多代码，我们重点看lambdaClassName这个字符串（通过名字就知道是干啥的），可以看到它的拼接结果跟我们上面打印的Lambda类名基本一致。而下面的ClassWriter也暴露了，其实Lambda运用的是Asm字节码技术，在运行时生成类文件。我感觉到这里就差不多了，再往下可能就有点太过细节了。-。-</p>\n<h3 id=\"Lambda实现总结\"><a href=\"#Lambda实现总结\" class=\"headerlink\" title=\"Lambda实现总结\"></a>Lambda实现总结</h3><p>所以Lambda表达式并不是匿名内部类的语法糖，它是基于invokedynamic指令，在运行时使用ASM生成类文件来实现的。</p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>这可能是我迄今写的最长的一篇技术文章了，写的过程中也在不断的加深自己对知识点的理解，颠覆了很多以往的错误认知。写技术文章这条路我会一直坚持下去。 非常喜欢得到里面的一句slogan，胡适先生说的话。 <strong>怕什么真理无穷，进一寸有一寸的欢喜</strong> 共勉!</p>\n","text":"本文转载自 https://juejin.im/post/5d0821315188254c434686c8<br>Java内部类，相信大家都用过，但是多数同学可能对它了解的并不深入，只是靠记忆来完成日常工作，却不能融会贯通，遇到奇葩问题更是难以有思路去解决。这篇文章带大家一起死磕","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]},{"title":"面试那点小事，你从未见过的spring boot面试集锦（附详细答案）","slug":"面试那点小事，你从未见过的springboot面试集锦（附详细答案）","date":"2019-06-06T07:39:01.001Z","updated":"2019-06-06T07:39:02.384Z","comments":true,"pin":null,"path":"api/articles/面试那点小事，你从未见过的springboot面试集锦（附详细答案）.json","excerpt":"","keywords":null,"cover":"https://user-gold-cdn.xitu.io/2019/6/5/16b26d5b5d3af6a1?imageView2/0/w/1280/h/960/ignore-error/1","content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5cf7827d6fb9a07efc4977c9\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5cf7827d6fb9a07efc4977c9</a> </p>\n</blockquote>\n<h3 id=\"一，-什么是spring-boot？\"><a href=\"#一，-什么是spring-boot？\" class=\"headerlink\" title=\"一， 什么是spring boot？\"></a>一， 什么是spring boot？</h3><p>多年来，随着新功能的增加，spring变得越来越复杂。只需访问页面<a href=\"https://spring.io/projects，我们将看到所有在应用程序中使用的不同功能的spring项目。如果必须启动一个新的spring项目，我们必须添加构建路径或maven依赖项，配置application\" target=\"_blank\" rel=\"noopener\">https://spring.io/projects，我们将看到所有在应用程序中使用的不同功能的spring项目。如果必须启动一个新的spring项目，我们必须添加构建路径或maven依赖项，配置application</a> server，添加spring配置。因此，启动一个新的spring项目需要大量的工作，因为我们目前必须从头开始做所有事情。Spring Boot是这个问题的解决方案。Spring boot构建在现有Spring框架之上。使用spring boot，我们可以避免以前必须执行的所有样板代码和配置。因此，Spring boot帮助我们更健壮地使用现有的Spring功能，并且只需最少的工作量。</p>\n<h3 id=\"二，Spring-Boot的优点是什么\"><a href=\"#二，Spring-Boot的优点是什么\" class=\"headerlink\" title=\"二，Spring Boot的优点是什么?\"></a>二，Spring Boot的优点是什么?</h3><pre><code>* 减少开发、测试的时间和工作量。\n* 使用JavaConfig有助于避免使用XML。\n* 避免大量maven导入和各种版本冲突。\n* 提供可选的开发方法。\n* 通过提供默认开发方式进行快速开发。\n* 不需要单独的Web服务器。这意味着您不再需要启动Tomcat、Glassfish或其他任何东西。</code></pre><p>由于没有web.xml文件，所以需要更少的配置。只需添加带@ configuration注释的类，然后可以添加带@ bean注释的方法，Spring将自动加载对象并像往常一样管理它。您甚至可以将@Autowired添加到bean方法中，使Spring autowire成为bean所需的依赖项。</p>\n<p>基于环境的配置——使用这些属性，您可以将其传递到您正在使用的应用程序环境中:- dspring .profile .active={enviorement}。在加载主应用程序属性文件之后，Spring将在(application-{environment}.properties)处加载后续的应用程序属性文件。</p>\n<h3 id=\"三，您使用过哪些构建工具来开发Spring引导应用程序\"><a href=\"#三，您使用过哪些构建工具来开发Spring引导应用程序\" class=\"headerlink\" title=\"三，您使用过哪些构建工具来开发Spring引导应用程序?\"></a>三，您使用过哪些构建工具来开发Spring引导应用程序?</h3><p>Spring Boot应用程序可以使用Maven和Gradle开发。</p>\n<h3 id=\"四，什么是JavaConfig\"><a href=\"#四，什么是JavaConfig\" class=\"headerlink\" title=\"四，什么是JavaConfig?\"></a>四，什么是JavaConfig?</h3><p>Spring JavaConfig是Spring社区的一个产品，它提供了一种纯java方法来配置Spring IoC容器。因此，它有助于避免使用XML配置。使用JavaConfig的优点是：<br>    * 面向对象的配置。因为配置在JavaConfig中定义为类，所以用户可以充分利用Java中的面向对象特性。一个配置类可以子类化另一个配置类，覆盖它的@Bean方法，等等。<br>    * 减少或消除XML配置。已经证明了基于依赖注入原则的外部化配置的好处。然而，许多开发人员不愿意在XML和Java之间来回切换。JavaConfig为开发人员提供了一种纯java方法来配置Spring容器，这种方法在概念上类似于XML配置。从技术上讲，仅使用   JavaConfig配置类来配置容器是可行的，但是在实践中，许多人发现将JavaConfig与XML混合并匹配是理想的。<br>    * 类型安全的重构能力。JavaConfig提供了一种类型安全的配置Spring容器的方法。由于Java 5.0对泛型的支持，现在可以通过类型而不是名称检索bean，不需要进行任何基于类型转换或字符串的查找。</p>\n<h3 id=\"五，如何在不重启服务器的情况下在Spring引导时重新加载我的更改\"><a href=\"#五，如何在不重启服务器的情况下在Spring引导时重新加载我的更改\" class=\"headerlink\" title=\"五，如何在不重启服务器的情况下在Spring引导时重新加载我的更改?\"></a>五，如何在不重启服务器的情况下在Spring引导时重新加载我的更改?</h3><p>这可以通过开发工具来实现。有了这个依赖项，您保存的任何更改都将重新启动嵌入的tomcat。Spring Boot有一个开发人员工具(DevTools)模块，它有助于提高开发人员的工作效率。Java开发人员面临的关键挑战之一是将文件更改自动部署到服务器并自动重启服务器。开发人员可以在Spring引导时重新加载更改，而不必重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot在发布第一个版本时没有这个特性。这是开发人员最需要的特性。DevTools模块完全满足开发人员的需求。此模块将在生产环境中禁用。它还提供了H2-database控制台，以便更好地测试应用程序。使用以下依赖项</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div>\n\n<p>下面的<a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2FSpringBootUsingPagination\" target=\"_blank\" rel=\"noopener\">示例</a>演示了自动启动和H2 DB控制台的DevTool依赖项用法</p>\n<h3 id=\"六，什么是Spring-boot-actuator\"><a href=\"#六，什么是Spring-boot-actuator\" class=\"headerlink\" title=\"六，什么是Spring boot actuator?\"></a>六，什么是Spring boot actuator?</h3><p>Spring boot actuator是Spring boot framework的重要特性之一。Spring boot actuator帮助您访问生产环境中正在运行的应用程序的当前状态，在生产环境中必须检查和监视几个指标。甚至一些外部应用程序也可能使用这些服务来触发对相关人员的警报消息。actuator模块公开一组REST端点，这些端点可以作为HTTP URL直接访问，以检查状态。</p>\n<h3 id=\"七，如何将Spring-Boot应用程序作为war包部署\"><a href=\"#七，如何将Spring-Boot应用程序作为war包部署\" class=\"headerlink\" title=\"七，如何将Spring Boot应用程序作为war包部署?\"></a>七，如何将Spring Boot应用程序作为war包部署?</h3><p>Spring Boot WAR部署</p>\n<h3 id=\"八，什么是Docker吗-如何将Spring引导应用程序部署到Docker\"><a href=\"#八，什么是Docker吗-如何将Spring引导应用程序部署到Docker\" class=\"headerlink\" title=\"八，什么是Docker吗?如何将Spring引导应用程序部署到Docker?\"></a>八，什么是Docker吗?如何将Spring引导应用程序部署到Docker?</h3><p>Docker是什么 将基于Spring的WAR应用程序部署到Docker 将基于Spring的JAR应用程序部署到Docker</p>\n<h3 id=\"九，如何禁用执行器端点安全在Spring启动\"><a href=\"#九，如何禁用执行器端点安全在Spring启动\" class=\"headerlink\" title=\"九，如何禁用执行器端点安全在Spring启动?\"></a>九，如何禁用执行器端点安全在Spring启动?</h3><p>默认情况下，所有敏感的HTTP端点都是安全的，只有具有ACTUATOR角色的用户才能访问它们。安全性是使用标准HttpServletRequest.isUserInRole方法实现的。 我们可以使用-禁用安全性 management.security.enabled = false 建议仅当在防火墙后访问ACTUATOR端点时禁用安全性。</p>\n<h3 id=\"十，如何将Spring引导应用程序运行到自定义端口\"><a href=\"#十，如何将Spring引导应用程序运行到自定义端口\" class=\"headerlink\" title=\"十，如何将Spring引导应用程序运行到自定义端口?\"></a>十，如何将Spring引导应用程序运行到自定义端口?</h3><p>要在自定义端口上运行spring引导应用程序，可以在application.properties中指定端口。 server.port = 8090</p>\n<h3 id=\"十一，什么是ELK堆栈-如何与Spring-Boot一起使用\"><a href=\"#十一，什么是ELK堆栈-如何与Spring-Boot一起使用\" class=\"headerlink\" title=\"十一，什么是ELK堆栈?如何与Spring Boot一起使用?\"></a>十一，什么是ELK堆栈?如何与Spring Boot一起使用?</h3><p>ELK堆栈由三个开源产品组成——Elasticsearch、Logstash和Kibana from Elastic。<br><img src=\"https://user-gold-cdn.xitu.io/2019/6/5/16b26d5b5d3af6a1?imageView2/0/w/1280/h/960/ignore-error/1\" alt> Elasticsearch是一个基于Lucene搜索引擎的NoSQL数据库。     Logstash是一个日志管道工具，它接受来自不同来源的输入，执行不同的转换，并将数据导出到不同的目标。它是一个动态的数据收集管道，具有可扩展的插件生态系统和强大的弹性搜索协同作用     Kibana是一个可视化UI层，工作在Elasticsearch之上。 这三个项目一起用于各种环境中的日志分析。因此Logstash收集和解析日志、弹性搜索索引并存储这些信息，而Kibana提供了一个UI层，提供可操作的可见性。</p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspringboot-microservice-elk\" target=\"_blank\" rel=\"noopener\">Spring Boot + ELK stack</a></p>\n<h3 id=\"十二，您有使用Spring-Boot编写测试用例吗\"><a href=\"#十二，您有使用Spring-Boot编写测试用例吗\" class=\"headerlink\" title=\"十二，您有使用Spring Boot编写测试用例吗?\"></a>十二，您有使用Spring Boot编写测试用例吗?</h3><p>SpringBoot为编写单元测试用例提供了@SpringBootTest</p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspringboot_testcases\" target=\"_blank\" rel=\"noopener\">Spring引导单元测试的简单示例</a></p>\n<h3 id=\"十三，YAML是什么\"><a href=\"#十三，YAML是什么\" class=\"headerlink\" title=\"十三，YAML是什么?\"></a>十三，YAML是什么?</h3><p>YAML是一种人类可读的数据序列化语言。它通常用于配置文件。 与属性文件相比，YAML文件的结构更加结构化，如果我们希望在配置文件中添加复杂的属性，那么它不会造成太大的混乱。可以看到，YAML具有分层的配置数据。</p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fbootyaml\" target=\"_blank\" rel=\"noopener\">在Spring引导中使用YAML属性</a></p>\n<h3 id=\"十四，如何为Spring引导应用程序实现安全性\"><a href=\"#十四，如何为Spring引导应用程序实现安全性\" class=\"headerlink\" title=\"十四，如何为Spring引导应用程序实现安全性?\"></a>十四，如何为Spring引导应用程序实现安全性?</h3><p>为了实现Spring Boot的安全性，我们使用Spring - Boot -starter-security依赖项，必须添加安全配置。它只需要很少的代码。Config类必须扩展WebSecurityConfigurerAdapter并覆盖它的方法。</p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fsprboot_sec\" target=\"_blank\" rel=\"noopener\">Spring引导安全性示例和说明</a></p>\n<h3 id=\"十五，您是否集成了Spring-Boot和ActiveMQ\"><a href=\"#十五，您是否集成了Spring-Boot和ActiveMQ\" class=\"headerlink\" title=\"十五，您是否集成了Spring Boot和ActiveMQ ?\"></a>十五，您是否集成了Spring Boot和ActiveMQ ?</h3><p>为了集成Spring Boot和ActiveMQ，我们使用Spring - Boot -starter- ActiveMQ依赖项，它只需要很少的配置，没有样板代码。</p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fsprboot_activemq\" target=\"_blank\" rel=\"noopener\">Spring引导ActiveMQ说明</a></p>\n<h3 id=\"十六，您是否集成了Spring-Boot和Apache-Kafka\"><a href=\"#十六，您是否集成了Spring-Boot和Apache-Kafka\" class=\"headerlink\" title=\"十六，您是否集成了Spring Boot和Apache Kafka ?\"></a>十六，您是否集成了Spring Boot和Apache Kafka ?</h3><p>为了集成Spring Boot和Apache Kafka，我们使用Spring - Kafka依赖项。</p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspring-boot-apache-kafka-hello-world\" target=\"_blank\" rel=\"noopener\">Spring Boot + Apache Kafka示例</a></p>\n<h3 id=\"十七，如何使用Spring引导实现分页和排序\"><a href=\"#十七，如何使用Spring引导实现分页和排序\" class=\"headerlink\" title=\"十七，如何使用Spring引导实现分页和排序?\"></a>十七，如何使用Spring引导实现分页和排序?</h3><p>使用Spring Boot实现分页非常简单。使用Spring Data-JPA，这是通过传递可分页的org.springframe .data.domain来实现的。可分页到存储库方法。</p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2FSpringBootInterviewQuestions\" target=\"_blank\" rel=\"noopener\">Spring引导分页说明</a></p>\n<h3 id=\"十八，什么是Swagger-您是否使用Spring-Boot实现了它\"><a href=\"#十八，什么是Swagger-您是否使用Spring-Boot实现了它\" class=\"headerlink\" title=\"十八，什么是Swagger?您是否使用Spring Boot实现了它?\"></a>十八，什么是Swagger?您是否使用Spring Boot实现了它?</h3><p>Swagger被广泛用于可视化api，Swagger UI为前端开发人员提供在线沙箱环境。在本教程中，我们将使用Swagger 2规范的Springfox实现。Swagger是一种工具、规范和完整的框架实现，用于生成RESTful Web服务的可视化表示。它允许文档以与服务器相同的速度更新。当通过Swagger正确定义时，使用者可以用最少的实现逻辑理解远程服务并与之交互。因此Swagger消除了调用服务时的猜测。</p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fboot_swagger\" target=\"_blank\" rel=\"noopener\">Spring Boot + Swagger2</a></p>\n<h3 id=\"十九，什么是Spring-Profiles-如何使用Spring-Boot实现它\"><a href=\"#十九，什么是Spring-Profiles-如何使用Spring-Boot实现它\" class=\"headerlink\" title=\"十九，什么是Spring Profiles?如何使用Spring Boot实现它?\"></a>十九，什么是Spring Profiles?如何使用Spring Boot实现它?</h3><p>Spring Profiles允许用户根据配置文件(dev, test, prod等)注册bean。因此，当应用程序在开发中运行时，只能加载某些bean，当应用程序在生产中运行时，只能加载某些其他bean。假设我们的需求是Swagger文档只对QA环境启用，对所有其他环境禁用。这可以使用配置文件来完成。Spring Boot使得使用配置文件非常容易。</p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fboot_swagger_profile\" target=\"_blank\" rel=\"noopener\">Spring引导+配置文件</a></p>\n<h3 id=\"二十，什么是Spring-Boot-Batch-如何使用Spring-Boot实现它\"><a href=\"#二十，什么是Spring-Boot-Batch-如何使用Spring-Boot实现它\" class=\"headerlink\" title=\"二十，什么是Spring Boot Batch?如何使用Spring Boot实现它?\"></a>二十，什么是Spring Boot Batch?如何使用Spring Boot实现它?</h3><p>Spring Boot Batch提供了处理大量记录所必需的可重用功能，包括日志/跟踪、事务管理、作业处理统计信息、作业重启、作业跳过和资源管理。它还提供了更高级的技术服务和特性，通过优化和分区技术，这些特性将支持极高容量和高性能的批处理作业。无论是简单的还是复杂的，大容量批处理作业都可以以高度可伸缩的方式利用该框架来处理大量信息。</p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fbootbatch\" target=\"_blank\" rel=\"noopener\">Spring Boot Batch</a></p>\n<h3 id=\"二十一，什么是FreeMarker模板-如何使用Spring-Boot实现它\"><a href=\"#二十一，什么是FreeMarker模板-如何使用Spring-Boot实现它\" class=\"headerlink\" title=\"二十一，什么是FreeMarker模板?如何使用Spring Boot实现它?\"></a>二十一，什么是FreeMarker模板?如何使用Spring Boot实现它?</h3><p>答:FreeMarker是一个基于java的模板引擎，最初专注于使用MVC软件架构生成动态web页面。使用Freemarker的主要优势是完全分离了表示层和业务层。程序员可以处理应用程序代码，而设计人员可以处理html页面设计。最后，使用freemarker，这些可以组合在一起，给出最终的输出页面。</p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspring-boot-freemarker-hello-world\" target=\"_blank\" rel=\"noopener\">Spring Boot + FreeMarker的例子</a></p>\n<h3 id=\"二十二，如何使用Spring-Boot实现异常处理\"><a href=\"#二十二，如何使用Spring-Boot实现异常处理\" class=\"headerlink\" title=\"二十二，如何使用Spring Boot实现异常处理?\"></a>二十二，如何使用Spring Boot实现异常处理?</h3><p>Spring提供了一种非常有用的方法，可以使用ControllerAdvice处理异常。我们将实现一个ControlerAdvice类，它将处理控制器类抛出的所有异常。</p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fboot-exception-handling\" target=\"_blank\" rel=\"noopener\">Spring引导异常处理</a></p>\n<h3 id=\"二十三，什么是缓存-您在Spring引导中使用过缓存框架吗\"><a href=\"#二十三，什么是缓存-您在Spring引导中使用过缓存框架吗\" class=\"headerlink\" title=\"二十三，什么是缓存?您在Spring引导中使用过缓存框架吗?\"></a>二十三，什么是缓存?您在Spring引导中使用过缓存框架吗?</h3><p>缓存是本地内存的一个区域，它保存了频繁访问的数据的副本，否则获取或计算这些数据将非常昂贵。使用Hazelcast进行缓存。</p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspring-boot-hazelcast\" target=\"_blank\" rel=\"noopener\">Spring Boot + Hazelcast示例</a></p>\n<h3 id=\"二十四您是否使用Spring-Boot公开了SOAP-web服务端点\"><a href=\"#二十四您是否使用Spring-Boot公开了SOAP-web服务端点\" class=\"headerlink\" title=\"二十四您是否使用Spring Boot公开了SOAP web服务端点?\"></a>二十四您是否使用Spring Boot公开了SOAP web服务端点?</h3><p>是的。使用Spring Boot公开了要使用的web服务。使用契约优先的方法从wsdl生成类。</p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspringbootsoapwebservice\" target=\"_blank\" rel=\"noopener\">Spring引导+ SOAP Web服务示例</a></p>\n<h3 id=\"二十五，您如何使用Spring-Boot执行数据库操作\"><a href=\"#二十五，您如何使用Spring-Boot执行数据库操作\" class=\"headerlink\" title=\"二十五，您如何使用Spring Boot执行数据库操作?\"></a>二十五，您如何使用Spring Boot执行数据库操作?</h3><p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2FSpringBoot_DataJPA\" target=\"_blank\" rel=\"noopener\">Spring引导教程-Spring Data JPA</a></p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fbootjdbc\" target=\"_blank\" rel=\"noopener\">Spring引导JDBC示例</a></p>\n<h3 id=\"二十六，如何使用Spring上传文件\"><a href=\"#二十六，如何使用Spring上传文件\" class=\"headerlink\" title=\"二十六，如何使用Spring上传文件?\"></a>二十六，如何使用Spring上传文件?</h3><p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fbootupload\" target=\"_blank\" rel=\"noopener\">Spring Boot +文件上传的例子</a></p>\n<h3 id=\"二十七，如何用Spring-Boot实现拦截器\"><a href=\"#二十七，如何用Spring-Boot实现拦截器\" class=\"headerlink\" title=\"二十七，如何用Spring Boot实现拦截器?\"></a>二十七，如何用Spring Boot实现拦截器?</h3><p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2FbootInterceptor\" target=\"_blank\" rel=\"noopener\">使用Spring MVC HandlerInterceptor与Spring引导</a></p>\n<h3 id=\"二十八，如何在Spring-Boot下使用schedulers\"><a href=\"#二十八，如何在Spring-Boot下使用schedulers\" class=\"headerlink\" title=\"二十八，如何在Spring Boot下使用schedulers ?\"></a>二十八，如何在Spring Boot下使用schedulers ?</h3><p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2FbootTask\" target=\"_blank\" rel=\"noopener\">Spring引导任务调度程序示例</a></p>\n<h3 id=\"二十九，您使用过哪些启动器maven依赖项\"><a href=\"#二十九，您使用过哪些启动器maven依赖项\" class=\"headerlink\" title=\"二十九，您使用过哪些启动器maven依赖项?\"></a>二十九，您使用过哪些启动器maven依赖项?</h3><p>使用过不同的starter依赖项，如spring-boot-starter-activemq依赖项、spring-boot-starter-security依赖项、spring-boot-starter-web依赖项。 这有助于减少依赖项的数量，并减少版本组合。</p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fsprboot_sec\" target=\"_blank\" rel=\"noopener\">Spring引导安全性示例和说明</a></p>\n<h3 id=\"三十，什么是CSRF攻击-如何启用CSRF对其进行保护\"><a href=\"#三十，什么是CSRF攻击-如何启用CSRF对其进行保护\" class=\"headerlink\" title=\"三十，什么是CSRF攻击?如何启用CSRF对其进行保护?\"></a>三十，什么是CSRF攻击?如何启用CSRF对其进行保护?</h3><p>CSRF代表跨站请求伪造。它是一种攻击，迫使最终用户在其当前已经过身份验证的web应用程序上执行不需要的操作。CSRF攻击专门针对状态更改请求，而不是数据窃取，因为攻击者无法看到对伪造请求的响应。</p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fboot_security_csrf\" target=\"_blank\" rel=\"noopener\">Spring引导安全性—启用CSRF保护</a></p>\n<h3 id=\"三十一，如何使用Spring引导使用表单登录身份验证\"><a href=\"#三十一，如何使用Spring引导使用表单登录身份验证\" class=\"headerlink\" title=\"三十一，如何使用Spring引导使用表单登录身份验证?\"></a>三十一，如何使用Spring引导使用表单登录身份验证?</h3><p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fboot_form_security\" target=\"_blank\" rel=\"noopener\">Spring引导表单安全登录Hello World示例</a></p>\n<h3 id=\"三十二，什么是OAuth2-如何使用Spring-Boot实现它\"><a href=\"#三十二，什么是OAuth2-如何使用Spring-Boot实现它\" class=\"headerlink\" title=\"三十二，什么是OAuth2?如何使用Spring Boot实现它?\"></a>三十二，什么是OAuth2?如何使用Spring Boot实现它?</h3><p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspring-boot-oauth-introduction\" target=\"_blank\" rel=\"noopener\">Spring Boot + OAuth2实现</a></p>\n<h3 id=\"三十三，GZIP是什么-如何使用Spring-Boot实现它\"><a href=\"#三十三，GZIP是什么-如何使用Spring-Boot实现它\" class=\"headerlink\" title=\"三十三，GZIP是什么?如何使用Spring Boot实现它?\"></a>三十三，GZIP是什么?如何使用Spring Boot实现它?</h3><p>gzip是一种文件格式，是一种用于文件压缩和解压缩的软件应用程序。</p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fboot-zip\" target=\"_blank\" rel=\"noopener\">Spring引导+ GZIP压缩</a></p>\n<h3 id=\"三十四，您在Spring引导中使用过集成框架吗\"><a href=\"#三十四，您在Spring引导中使用过集成框架吗\" class=\"headerlink\" title=\"三十四，您在Spring引导中使用过集成框架吗?\"></a>三十四，您在Spring引导中使用过集成框架吗?</h3><p>已将Apache Camel与Spring引导集成。使用Apache Camel Spring启动启动依赖项。</p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fbootcamel\" target=\"_blank\" rel=\"noopener\">Spring Boot +Apache Camel</a></p>\n<h3 id=\"三十五，什么是Apache-Freemarker-什么时候使用它而不是JSP-如何与Spring-Boot集成\"><a href=\"#三十五，什么是Apache-Freemarker-什么时候使用它而不是JSP-如何与Spring-Boot集成\" class=\"headerlink\" title=\"三十五，什么是Apache Freemarker?什么时候使用它而不是JSP?如何与Spring Boot集成?\"></a>三十五，什么是Apache Freemarker?什么时候使用它而不是JSP?如何与Spring Boot集成?</h3><p>JSP是为网页量身定做的，Freemarker模板是一种更通用的模板语言——它可以用来生成html、纯文本、电子邮件等。</p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspring-boot-freemarker-hello-world\" target=\"_blank\" rel=\"noopener\">Spring Boot + FreeMarker的例子</a></p>\n<h3 id=\"三十六，你什么时候使用WebSockets-如何使用Spring-Boot实现它\"><a href=\"#三十六，你什么时候使用WebSockets-如何使用Spring-Boot实现它\" class=\"headerlink\" title=\"三十六，你什么时候使用WebSockets?如何使用Spring Boot实现它?\"></a>三十六，你什么时候使用WebSockets?如何使用Spring Boot实现它?</h3><p>WebSocket是一种计算机通信协议，通过单个TCP连接提供全双工通信通道。<br><img src=\"https://user-gold-cdn.xitu.io/2019/6/5/16b26d5b5d292438?imageView2/0/w/1280/h/960/ignore-error/1\" alt> WebSocket是双向的——使用WebSocket客户端或服务器都可以发起发送消息。 WebSocket是全双工的——客户端和服务器之间的通信是相互独立的。 单个TCP连接——初始连接使用HTTP，然后将此连接升级为基于套接字的连接。然后，这个单一连接将用于未来的所有通信 轻- WebSocket消息数据交换比http轻得多。 <a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fboot-websocket\" target=\"_blank\" rel=\"noopener\">Spring Boot + WebSockets的例子</a></p>\n<h3 id=\"三十七，什么是AOP-如何与Spring-Boot一起使用\"><a href=\"#三十七，什么是AOP-如何与Spring-Boot一起使用\" class=\"headerlink\" title=\"三十七，什么是AOP?如何与Spring Boot一起使用?\"></a>三十七，什么是AOP?如何与Spring Boot一起使用?</h3><p>在软件开发过程中，跨越应用程序多个点的功能称为横切关注点。这些横切关注点不同于应用程序的主要业务逻辑。因此，将这些横切关注点从业务逻辑中分离出来是面向方面编程(AOP)的切入点。</p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspring-boot-aop\" target=\"_blank\" rel=\"noopener\">Spring Boot + AOP示例</a></p>\n<h3 id=\"三十八，什么是Apache-Kafka-如何与Spring-Boot集成\"><a href=\"#三十八，什么是Apache-Kafka-如何与Spring-Boot集成\" class=\"headerlink\" title=\"三十八，什么是Apache Kafka?如何与Spring Boot集成?\"></a>三十八，什么是Apache Kafka?如何与Spring Boot集成?</h3><p>apache Kafka是一个分布式发布-订阅消息传递系统。它是一个可伸缩的、容错的、发布-订阅消息传递系统，使我们能够构建分布式应用程序。这是一个Apache顶级项目。Kafka适用于离线和在线的消息消费。</p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspring-boot-apache-kafka-hello-world\" target=\"_blank\" rel=\"noopener\">Spring Boot + Apache Kafka示例</a></p>\n<h3 id=\"三十九，我们如何监视所有Spring-Boot微服务\"><a href=\"#三十九，我们如何监视所有Spring-Boot微服务\" class=\"headerlink\" title=\"三十九，我们如何监视所有Spring Boot微服务?\"></a>三十九，我们如何监视所有Spring Boot微服务?</h3><p>Spring Boot提供了actuator 端点来监控单个微服务的指标。这些端点对于获取关于应用程序的信息非常有帮助，比如应用程序是否启动，它们的组件(如数据库等)是否正常工作。但是，使用actuator 接口的一个主要缺点或困难是，我们必须逐个命中这些接口，以了解应用程序的状态或健康状况。假设微服务涉及50个应用程序，管理员将不得不命中所有50个应用程序的actuator 端点。为了帮助我们处理这种情况，我们将使用位于<a href=\"https://github.com/codecentric/springing-boot-admin的开源项目。\" target=\"_blank\" rel=\"noopener\">https://github.com/codecentric/springing-boot-admin的开源项目。</a> 它构建在Spring Boot Actuator之上，提供了一个web UI，使我们能够可视化多个应用程序的指标。</p>\n<p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fboot-admin\" target=\"_blank\" rel=\"noopener\">Spring Boot Admin</a></p>\n<h3 id=\"四十，您在Spring引导中使用过Spring-Cloud组件吗\"><a href=\"#四十，您在Spring引导中使用过Spring-Cloud组件吗\" class=\"headerlink\" title=\"四十，您在Spring引导中使用过Spring Cloud组件吗?\"></a>四十，您在Spring引导中使用过Spring Cloud组件吗?</h3><p>使用过Netflix Eureka等Spring Cloud组件进行服务注册，Ribbon用于负载平衡。 <a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspringcloud\" target=\"_blank\" rel=\"noopener\">Spring Boot + Cloud Components</a> <a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspring-cloud-interview-questions\" target=\"_blank\" rel=\"noopener\">Spring Cloud interview Questions</a></p>\n<h3 id=\"四十一，如何将Spring-Boot应用程序部署到Pivotal-Cloud-Foundry-PCF\"><a href=\"#四十一，如何将Spring-Boot应用程序部署到Pivotal-Cloud-Foundry-PCF\" class=\"headerlink\" title=\"四十一，如何将Spring Boot应用程序部署到Pivotal Cloud Foundry(PCF)?\"></a>四十一，如何将Spring Boot应用程序部署到Pivotal Cloud Foundry(PCF)?</h3><p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fpcf%2Fpcf-hello\" target=\"_blank\" rel=\"noopener\">Deploying Spring Boot Application to PCF</a></p>\n<h3 id=\"四十二，如何将Spring-Boot-MySQL应用部署到Pivotal-Cloud-Foundry-PCF\"><a href=\"#四十二，如何将Spring-Boot-MySQL应用部署到Pivotal-Cloud-Foundry-PCF\" class=\"headerlink\" title=\"四十二，如何将Spring Boot + MySQL应用部署到Pivotal Cloud Foundry(PCF)?\"></a>四十二，如何将Spring Boot + MySQL应用部署到Pivotal Cloud Foundry(PCF)?</h3><p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fpcf%2Fpcf-sql\" target=\"_blank\" rel=\"noopener\">Pivotal Cloud Foundry Tutorial - Deploying Spring Boot + MySQL Application to PCF</a></p>\n<h3 id=\"四十三，如何将Spring-Boot-RabbitMQ应用部署到Pivotal-Cloud-Foundry-PCF\"><a href=\"#四十三，如何将Spring-Boot-RabbitMQ应用部署到Pivotal-Cloud-Foundry-PCF\" class=\"headerlink\" title=\"四十三，如何将Spring Boot + RabbitMQ应用部署到Pivotal Cloud Foundry(PCF)?\"></a>四十三，如何将Spring Boot + RabbitMQ应用部署到Pivotal Cloud Foundry(PCF)?</h3><p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fpcf%2Fpcf-rabbitmq\" target=\"_blank\" rel=\"noopener\">Pivotal Cloud Foundry Tutorial - Deploying Spring Boot + RabbitMQ Application to PCF</a></p>\n","text":"本文转载自 https://juejin.im/post/5cf7827d6fb9a07efc4977c9 一， 什么是spring boot？多年来，随着新功能的增加，spring变得越来越复杂。只需访问页面https://spring.io/projects，我们将看到所有在","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]}]}