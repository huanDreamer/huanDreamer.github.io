{"name":"Spring","slug":"Spring","count":2,"posts":[{"title":"【Spring】Autowired原理及与Resource注解区别","slug":"【Spring】Autowired原理及与Resource注解区别","date":"2019-05-17T07:03:08.008Z","updated":"2019-05-30T00:52:25.416Z","comments":true,"pin":null,"path":"api/articles/【Spring】Autowired原理及与Resource注解区别.json","excerpt":"","keywords":null,"cover":"https://user-gold-cdn.xitu.io/2018/9/9/165bc4a503dfcc18?imageView2/0/w/1280/h/960/ignore-error/1","content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5cde05fae51d454759351d8c\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5cde05fae51d454759351d8c</a> </p>\n</blockquote>\n<h2 id=\"Autowired注解\"><a href=\"#Autowired注解\" class=\"headerlink\" title=\"Autowired注解\"></a>Autowired注解</h2><p>Autowired顾名思义，表示自动注入，如下是Autowired注解的源代码：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Documented</span><br><span class=\"line\">public @interface Autowired &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Declares whether the annotated dependency is required.</span><br><span class=\"line\">     * &lt;p&gt;Defaults to &#123;@code true&#125;.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    boolean required() default true;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>从Autowired的实现可以看到，Autowired可以用于类的构造方法，类的字段，类的方法以及注解类型上，但是Autowired不能用于类上面。</p>\n<p>关于Autowired注解，有如下问题需要解决：</p>\n<ol>\n<li><p>Autowired作用在不同的范围上(构造方法，字段、方法)上，它的装配策略如何，按名称还是类型？</p>\n</li>\n<li><p>为构造方法，字段和方法添加Autowired注解之后，谁来解析这个Autowired注解，完成装配</p>\n</li>\n<li><p>装配的bean从何处而来，是在Spring的xml文件中定义的bean吗？</p>\n</li>\n</ol>\n<h2 id=\"从Autowired的javadoc开始\"><a href=\"#从Autowired的javadoc开始\" class=\"headerlink\" title=\"从Autowired的javadoc开始\"></a>从Autowired的javadoc开始</h2><p>从Autowired的javadoc中得到如下信息</p>\n<ol>\n<li><p>AutowiredAnnotationBeanPostProcessor负责扫描Autowired注解，然后完成自动注入</p>\n</li>\n<li><p>可以对私有的字段使用Autowired进行自动装配，而无需为私有字段定义getter/setter来read/write这个字段</p>\n</li>\n<li><p>使用Autowired注解的类方法，可以是任意的方法名，任意的参数，Spring会从容器中找到合适的bean进行装配，setter自动注入跟对字段自动注入效果一样</p>\n</li>\n</ol>\n<h2 id=\"Autowired注解的解析\"><a href=\"#Autowired注解的解析\" class=\"headerlink\" title=\"Autowired注解的解析\"></a>Autowired注解的解析</h2><p>当项目中使用了Autowired注解时，需要明确的告诉Spring,配置中引用了自动注入的功能，在Spring的配置文件，做法有两种</p>\n<ol>\n<li><p>配置AutowiredAnnotationBeanPostProcessor</p>\n</li>\n<li><p>使用<a href>context:annotation-config/</a>。<a href>context:annotationconfig/</a> 将隐式地向 Spring 容器注册<code>AutowiredAnnotationBeanPostProcessor</code>、<code>CommonAnnotationBeanPostProcessor</code>、<code>PersistenceAnnotationBeanPostProcessor</code>以及<code>RequiredAnnotationBeanPostProcessor</code> 这 4 个 BeanPostProcessor。</p>\n</li>\n</ol>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><h3 id=\"1-实例一：\"><a href=\"#1-实例一：\" class=\"headerlink\" title=\"1. 实例一：\"></a>1. 实例一：</h3><pre><code>* UserSerice依赖的UserDao使用Autowired注解，\n* UserDao没有在Spring配置文件中定义</code></pre><p><strong>结果：UserDao为null</strong></p>\n<h3 id=\"2-实例二：\"><a href=\"#2-实例二：\" class=\"headerlink\" title=\"2. 实例二：\"></a>2. 实例二：</h3><pre><code>* UserSerice依赖的UserDao使用Autowired注解\n* UserDao在Spring配置文件中有定义</code></pre><p><strong>结果：UserDao为null</strong></p>\n<h3 id=\"3-实例三：\"><a href=\"#3-实例三：\" class=\"headerlink\" title=\"3. 实例三：\"></a>3. 实例三：</h3><pre><code>* UserSerice依赖的UserDao使用Autowired注解\n* UserDao在Spring配置文件中有定义\n* Spring中使用[context:annotation-config/]()</code></pre><p>/<em>/</em> 结果：UserDao正确注入，在Spring中配置的UserDao的实现，而在UserService中的是UserDao的接口，也就是说，虽然它们类型没有完全匹配，但是由于是实现/<em>/</em></p>\n<p><strong>关系，Spring仍然能够完成自动注入</strong></p>\n<h3 id=\"4-实例四：\"><a href=\"#4-实例四：\" class=\"headerlink\" title=\"4. 实例四：\"></a>4. 实例四：</h3><pre><code>* UserSerice依赖的UserDao使用Autowired注解\n* UserDao在Spring配置文件中有定义\n* Spring中配置AutowiredAnnotationBeanPostProcessor</code></pre><p><strong>结果：UserDao正确注入，同实例三</strong></p>\n<h3 id=\"5-实例五：\"><a href=\"#5-实例五：\" class=\"headerlink\" title=\"5. 实例五：\"></a>5. 实例五：</h3><pre><code>* UserSerice依赖的UserDao使用Autowired注解\n* UserDao在Spring配置文件中有两份定义(id不同)\n* Spring中使用[context:annotation-config/]()</code></pre><p><strong>结果：</strong></p>\n<p><strong>1. 如果UserDao的属性名与某个bean的id相同，那么按照属性名和id名称匹配原则，自动装配</strong></p>\n<p><strong>2. 如果UserService中定义的UserDao的属性名，与Spring配置文件中的两个id都不同，那么注入失败，异常抛出，提示，无法完整自动装配</strong></p>\n<h2 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a><strong>结论：</strong></h2><ol>\n<li><p>使用Autowired自动装配，必须在Spring的配置文件中使用<a href>context:annotation-config/</a>来告诉Spring需要进行自动装配扫描（AutowiredAnnotationBeanPostProcessor不推荐使用）</p>\n</li>\n<li><p>Autowired默认按类型进行匹配，当匹配到多个满足条件的bean时，再按照属性名和bean的id进行匹配，如果仍然有多个匹配上或者没有一个匹配上，则抛出异常，提示自动装配失败</p>\n</li>\n<li><p>在使用Autowired时，可以使用Qualifier注解，显式的指定，当冲突发生时，使用那个id对应的bean</p>\n</li>\n<li><p>Autowired注解自动装配功能完成的是依赖的自动注入，因此，在一个bean中，它依赖的bean可以通过自动注入的方式完成而不需要显式的为它的属性进行注入。但是这些依赖的bean仍然不能省略，还是要在Spring中进行配置，省略的仅仅是bean属性的注入配置代码</p>\n</li>\n</ol>\n<h2 id=\"Resource注解\"><a href=\"#Resource注解\" class=\"headerlink\" title=\"Resource注解\"></a>Resource注解</h2><p>Resource注解在功能和目的上，等效于Autowried+Qualifier注解，Resource注解是JSR-250规范的一部分，它定义在JDK的javax.annoation包中，如下是它的定义：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package javax.annotation;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.lang.annotation.*;</span><br><span class=\"line\">import static java.lang.annotation.ElementType.*;</span><br><span class=\"line\">import static java.lang.annotation.RetentionPolicy.*;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * The Resource annotation marks a resource that is needed</span><br><span class=\"line\"> * by the application.  This annotation may be applied to an</span><br><span class=\"line\"> * application component class, or to fields or methods of the</span><br><span class=\"line\"> * component class.  When the annotation is applied to a</span><br><span class=\"line\"> * field or method, the container will inject an instance</span><br><span class=\"line\"> * of the requested resource into the application component</span><br><span class=\"line\"> * when the component is initialized.  If the annotation is</span><br><span class=\"line\"> * applied to the component class, the annotation declares a</span><br><span class=\"line\"> * resource that the application will look up at runtime. &lt;p&gt;</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Even though this annotation is not marked Inherited, deployment</span><br><span class=\"line\"> * tools are required to examine all superclasses of any component</span><br><span class=\"line\"> * class to discover all uses of this annotation in all superclasses.</span><br><span class=\"line\"> * All such annotation instances specify resources that are needed</span><br><span class=\"line\"> * by the application component.  Note that this annotation may</span><br><span class=\"line\"> * appear on private fields and methods of superclasses; the container</span><br><span class=\"line\"> * is required to perform injection in these cases as well.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @since Common Annotations 1.0</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Target(&#123;TYPE, FIELD, METHOD&#125;)</span><br><span class=\"line\">@Retention(RUNTIME)</span><br><span class=\"line\">public @interface Resource &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * The JNDI name of the resource.  For field annotations,</span><br><span class=\"line\">     * the default is the field name.  For method annotations,</span><br><span class=\"line\">     * the default is the JavaBeans property name corresponding</span><br><span class=\"line\">     * to the method.  For class annotations, there is no default</span><br><span class=\"line\">     * and this must be specified.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    String name() default &quot;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * The name of the resource that the reference points to. It can</span><br><span class=\"line\">     * link to any compatible resource using the global JNDI names.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @since Common Annotations 1.1</span><br><span class=\"line\">     */</span><br><span class=\"line\"></span><br><span class=\"line\">    String lookup() default &quot;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * The Java type of the resource.  For field annotations,</span><br><span class=\"line\">     * the default is the type of the field.  For method annotations,</span><br><span class=\"line\">     * the default is the type of the JavaBeans property.</span><br><span class=\"line\">     * For class annotations, there is no default and this must be</span><br><span class=\"line\">     * specified.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    Class&lt;?&gt; type() default java.lang.Object.class;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * The two possible authentication types for a resource.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    enum AuthenticationType &#123;</span><br><span class=\"line\">            CONTAINER,</span><br><span class=\"line\">            APPLICATION</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * The authentication type to use for this resource.</span><br><span class=\"line\">     * This may be specified for resources representing a</span><br><span class=\"line\">     * connection factory of any supported type, and must</span><br><span class=\"line\">     * not be specified for resources of other types.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    AuthenticationType authenticationType() default AuthenticationType.CONTAINER;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Indicates whether this resource can be shared between</span><br><span class=\"line\">     * this component and other components.</span><br><span class=\"line\">     * This may be specified for resources representing a</span><br><span class=\"line\">     * connection factory of any supported type, and must</span><br><span class=\"line\">     * not be specified for resources of other types.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    boolean shareable() default true;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * A product specific name that this resource should be mapped to.</span><br><span class=\"line\">     * The name of this resource, as defined by the &lt;code&gt;name&lt;/code&gt;</span><br><span class=\"line\">     * element or defaulted, is a name that is local to the application</span><br><span class=\"line\">     * component using the resource.  (It&apos;s a name in the JNDI</span><br><span class=\"line\">     * &lt;code&gt;java:comp/env&lt;/code&gt; namespace.)  Many application servers</span><br><span class=\"line\">     * provide a way to map these local names to names of resources</span><br><span class=\"line\">     * known to the application server.  This mapped name is often a</span><br><span class=\"line\">     * &lt;i&gt;global&lt;/i&gt; JNDI name, but may be a name of any form. &lt;p&gt;</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * Application servers are not required to support any particular</span><br><span class=\"line\">     * form or type of mapped name, nor the ability to use mapped names.</span><br><span class=\"line\">     * The mapped name is product-dependent and often installation-dependent.</span><br><span class=\"line\">     * No use of a mapped name is portable.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    String mappedName() default &quot;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Description of this resource.  The description is expected</span><br><span class=\"line\">     * to be in the default language of the system on which the</span><br><span class=\"line\">     * application is deployed.  The description can be presented</span><br><span class=\"line\">     * to the Deployer to help in choosing the correct resource.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    String description() default &quot;&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>Autowried注解，首先根据类型匹配，如果类型匹配到多个，那么在根据属性名和bean的id进行匹配(可以由Qualifier注解强制匹配指定的bean id)。Resource注解则顺序不同，它有如下几种可能的情况：</p>\n<pre><code>* Resource注解指定了name属性和type属性</code></pre><p>策略：首先进行按名称匹配策略： 匹配name属性和bean的id，如果匹配，则判断查找到的bean是否是type属性指定的类型，如果是type属性指定的类型，则匹配成功。如果不是<strong><strong>type属性指定的类型</strong></strong>，则抛出异常，提示匹配失败；如果name属性跟bean的id不匹配，则抛出异常提示没有bean的id匹配name属性</p>\n<pre><code>* Resource注解指定了name属性，未指定type属性</code></pre><p>策略：查找bean的id为name属性的bean，查找到，不关心类型为什么，都是匹配成功；如果找不到name属性指定的bean id，则匹配失败，抛出异常</p>\n<pre><code>* Resource注解指定了type属性，未指定name属性</code></pre><p>策略：首先进行按名称匹配策略： 匹配属性名和bean的id，如果匹配，则判断查找到的bean是否是type属性指定的类型，如果是type属性指定的类型，则匹配成功。如果不是<strong><strong>type属性指定的类型</strong></strong>，则抛出异常，提示匹配失败；其次进行按类型匹配策略： 如果属性名跟bean的id不匹配，则查找类型为type的bean，如果仅仅找到一个，自动装配成功，其它情况失败。</p>\n<pre><code>* Resource注解未指定type属性和name属性</code></pre><p>策略：首先进行按属性名匹配策略，匹配则注入成功；如果属性名不匹配，则进行类型匹配策略，只有为一个类型匹配才成功，其他情况都失败</p>\n<h3 id=\"作者注：欢迎关注笔者公号，定期分享IT互联网、金融等工作经验心得、人生感悟，欢迎交流，目前就职阿里-移动事业部，需要大厂内推的也可到公众号砸简历，或查看我个人资料获取。（公号ID：weknow619）。\"><a href=\"#作者注：欢迎关注笔者公号，定期分享IT互联网、金融等工作经验心得、人生感悟，欢迎交流，目前就职阿里-移动事业部，需要大厂内推的也可到公众号砸简历，或查看我个人资料获取。（公号ID：weknow619）。\" class=\"headerlink\" title=\"作者注：欢迎关注笔者公号，定期分享IT互联网、金融等工作经验心得、人生感悟，欢迎交流，目前就职阿里-移动事业部，需要大厂内推的也可到公众号砸简历，或查看我个人资料获取。（公号ID：weknow619）。\"></a>作者注：欢迎关注笔者公号，定期分享IT互联网、金融等工作经验心得、人生感悟，欢迎交流，目前就职阿里-移动事业部，需要大厂内推的也可到公众号砸简历，或查看我个人资料获取。（公号ID：weknow619）。</h3><p><img src=\"https://user-gold-cdn.xitu.io/2018/9/9/165bc4a503dfcc18?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n","text":"本文转载自 https://juejin.im/post/5cde05fae51d454759351d8c Autowired注解Autowired顾名思义，表示自动注入，如下是Autowired注解的源代码：1<br>2<br>3<br>4<br>5<br>6<br>7<br>","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":2,"path":"api/tags/Spring.json"}]},{"title":"拜托！面试请不要再问我Spring Cloud底层原理","slug":"拜托！面试请不要再问我SpringCloud底层原理","date":"2019-05-21T02:50:09.009Z","updated":"2019-05-30T00:52:25.422Z","comments":true,"pin":null,"path":"api/articles/拜托！面试请不要再问我SpringCloud底层原理.json","excerpt":"","keywords":null,"cover":"https://user-gold-cdn.xitu.io/2018/11/7/166ebffb48c481a3?imageView2/0/w/1280/h/960/ignore-error/1","content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5be13b83f265da6116393fc7\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5be13b83f265da6116393fc7</a><br>欢迎关注微信公众号：<strong>石杉的架构笔记（id：shishan100）</strong></p>\n</blockquote>\n<p>每周一至五早8点半，精品技术文章准时送上！</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><p><strong>一、业务场景介绍</strong></p>\n<p><strong>二、Spring Cloud核心组件：Eureka</strong></p>\n<p><strong>三、Spring Cloud核心组件：Feign</strong></p>\n<p><strong>四、Spring Cloud核心组件：Ribbon</strong></p>\n<p><strong>五、Spring Cloud核心组件：Hystrix</strong></p>\n<p><strong>六、Spring Cloud核心组件：Zuul</strong></p>\n<p><strong>七、总结</strong></p>\n<hr>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>毫无疑问，Spring Cloud是目前微服务架构领域的翘楚，无数的书籍博客都在讲解这个技术。不过大多数讲解还停留在对Spring Cloud功能使用的层面，其底层的很多原理，很多人可能并不知晓。<strong>因此本文将通过大量的手绘图</strong>，给大家谈谈Spring Cloud微服务架构的底层原理。</p>\n<p>实际上，Spring Cloud是一个全家桶式的技术栈，包含了很多组件。本文先从其最核心的几个组件入手，来剖析一下其底层的工作原理。<strong>也就是Eureka、Ribbon、Feign、Hystrix、Zuul这几个组件。</strong></p>\n<hr>\n<h2 id=\"一、业务场景介绍\"><a href=\"#一、业务场景介绍\" class=\"headerlink\" title=\"一、业务场景介绍\"></a>一、业务场景介绍</h2><p>先来给大家说一个业务场景，假设咱们现在开发一个电商网站，要实现支付订单的功能，流程如下：</p>\n<pre><code>* 创建一个订单后，如果用户立刻支付了这个订单，我们需要将订单状态更新为“已支付”\n* 扣减相应的商品库存\n* 通知仓储中心，进行发货\n* 给用户的这次购物增加相应的积分</code></pre><p>针对上述流程，<strong>我们需要有订单服务、库存服务、仓储服务、积分服务</strong>。整个流程的大体思路如下：</p>\n<pre><code>* 用户针对一个订单完成支付之后，就会去找订单服务，更新订单状态\n* 订单服务调用库存服务，完成相应功能\n* 订单服务调用仓储服务，完成相应功能\n* 订单服务调用积分服务，完成相应功能</code></pre><p><strong>至此，整个支付订单的业务流程结束</strong></p>\n<hr>\n<p>下图这张图，清晰表明了各服务间的调用过程：<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/7/166ebffb48c481a3?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p>好！有了业务场景之后，咱们就一起来看看Spring Cloud微服务架构中，这几个组件如何相互协作，各自发挥的作用以及其背后的原理。</p>\n<h2 id=\"二、Spring-Cloud核心组件：Eureka\"><a href=\"#二、Spring-Cloud核心组件：Eureka\" class=\"headerlink\" title=\"二、Spring Cloud核心组件：Eureka\"></a>二、Spring Cloud核心组件：Eureka</h2><p><strong>咱们来考虑第一个问题</strong>：订单服务想要调用库存服务、仓储服务，或者积分服务，怎么调用？</p>\n<pre><code>* 订单服务压根儿就不知道人家库存服务在哪台机器上啊！他就算想要发起一个请求，都不知道发送给谁，有心无力！\n* 这时候，就轮到Spring Cloud Eureka出场了。Eureka是微服务架构中的注册中心，专门负责服务的注册与发现。</code></pre><p>咱们来看看下面的这张图，结合图来仔细剖析一下整个流程：<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/7/166ebffcb7ce31b8?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p>如上图所示，库存服务、仓储服务、积分服务中都有一个<strong>Eureka Client组件，这个组件专门负责将这个服务的信息注册到Eureka Server中</strong>。说白了，就是告诉Eureka Server，自己在哪台机器上，监听着哪个端口。而<strong>Eureka Server是一个注册中心，里面有一个注册表，保存了各服务所在的机器和端口号</strong></p>\n<p>订单服务里也有一个Eureka Client组件，这个Eureka Client组件会找Eureka Server问一下：库存服务在哪台机器啊？监听着哪个端口啊？仓储服务呢？积分服务呢？然后就可以把这些相关信息从Eureka Server的注册表中拉取到自己本地缓存起来。</p>\n<p>这时如果订单服务想要调用库存服务，不就可以找自己本地的Eureka Client问一下库存服务在哪台机器？监听哪个端口吗？收到响应后，紧接着就可以发送一个请求过去，调用库存服务扣减库存的那个接口！同理，如果订单服务要调用仓储服务、积分服务，也是如法炮制。</p>\n<p>总结一下：</p>\n<pre><code>* **Eureka Client：**负责将这个服务的信息注册到Eureka Server中\n* **Eureka Server：**注册中心，里面有一个注册表，保存了各个服务所在的机器和端口号</code></pre><h2 id=\"三、Spring-Cloud核心组件：Feign\"><a href=\"#三、Spring-Cloud核心组件：Feign\" class=\"headerlink\" title=\"三、Spring Cloud核心组件：Feign\"></a>三、Spring Cloud核心组件：Feign</h2><p>现在订单服务确实知道库存服务、积分服务、仓库服务在哪里了，同时也监听着哪些端口号了。<strong>但是新问题又来了：难道订单服务要自己写一大堆代码，跟其他服务建立网络连接，然后构造一个复杂的请求，接着发送请求过去，最后对返回的响应结果再写一大堆代码来处理吗？</strong></p>\n<hr>\n<p>这是上述流程翻译的代码片段，咱们一起来看看，体会一下这种绝望而无助的感受！！！</p>\n<p><strong>友情提示，前方高能：</strong><br><img src=\"https://user-gold-cdn.xitu.io/2018/11/7/166ebced960f2024?imageView2/0/w/1280/h/960/ignore-error/1\" alt><br><a href></a></p>\n<p><a href></a></p>\n<p>看完上面那一大段代码，有没有感到后背发凉、一身冷汗？实际上你进行服务间调用时，如果每次都手写代码，代码量比上面那段要多至少几倍，所以这个事压根儿就不是地球人能干的。</p>\n<p>既然如此，那怎么办呢？别急，Feign早已为我们提供好了优雅的解决方案。来看看如果用Feign的话，你的订单服务调用库存服务的代码会变成啥样？<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/7/166ebcf01b773dd4?imageView2/0/w/1280/h/960/ignore-error/1\" alt><br><a href></a></p>\n<p><a href></a></p>\n<p>看完上面的代码什么感觉？是不是感觉整个世界都干净了，又找到了活下去的勇气！没有底层的建立连接、构造请求、解析响应的代码，直接就是用注解定义一个 FeignClient接口，然后调用那个接口就可以了。人家Feign Client会在底层根据你的注解，跟你指定的服务建立连接、构造请求、发起靕求、获取响应、解析响应，等等。这一系列脏活累活，人家Feign全给你干了。</p>\n<p>那么问题来了，Feign是如何做到这么神奇的呢？很简单，<strong>Feign的一个关键机制就是使用了动态代理</strong>。咱们一起来看看下面的图，结合图来分析：</p>\n<pre><code>* 首先，如果你对某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理\n* 接着你要是调用那个接口，本质就是会调用 Feign创建的动态代理，这是核心中的核心\n* Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务的地址\n* 最后针对这个地址，发起请求、解析响应</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2018/11/7/166ebfff505b2a20?imageView2/0/w/1280/h/960/ignore-error/1\" alt><br><a href></a></p>\n<p><a href></a></p>\n<h2 id=\"四、Spring-Cloud核心组件：Ribbon\"><a href=\"#四、Spring-Cloud核心组件：Ribbon\" class=\"headerlink\" title=\"四、Spring Cloud核心组件：Ribbon\"></a>四、Spring Cloud核心组件：Ribbon</h2><p>说完了Feign，还没完。现在新的问题又来了，如果人家库存服务部署在了5台机器上，如下所示：</p>\n<pre><code>* 192.168.169:9000\n* 192.168.170:9000\n* 192.168.171:9000\n* 192.168.172:9000\n* 192.168.173:9000</code></pre><p><strong>这下麻烦了！人家Feign怎么知道该请求哪台机器呢？</strong></p>\n<pre><code>* 这时Spring Cloud Ribbon就派上用场了。Ribbon就是专门解决这个问题的。它的作用是**负载均衡**，会帮你在每次请求时选择一台机器，均匀的把请求分发到各个机器上\n* Ribbon的负载均衡默认使用的最经典的**Round Robin轮询算法**。这是啥？简单来说，就是如果订单服务对库存服务发起10次请求，那就先让你请求第1台机器、然后是第2台机器、第3台机器、第4台机器、第5台机器，接着再来—个循环，第1台机器、第2台机器。。。以此类推。</code></pre><p><strong>此外，Ribbon是和Feign以及Eureka紧密协作，完成工作的，具体如下：</strong></p>\n<pre><code>* 首先Ribbon会从 Eureka Client里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口号。\n* 然后Ribbon就可以使用默认的Round Robin算法，从中选择一台机器\n* Feign就会针对这台机器，构造并发起请求。</code></pre><p>对上述整个过程，再来一张图，帮助大家更深刻的理解：<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/7/166ec001dc155e98?imageView2/0/w/1280/h/960/ignore-error/1\" alt><br><a href></a></p>\n<p><a href></a></p>\n<hr>\n<h2 id=\"五、Spring-Cloud核心组件：Hystrix\"><a href=\"#五、Spring-Cloud核心组件：Hystrix\" class=\"headerlink\" title=\"五、Spring Cloud核心组件：Hystrix\"></a>五、Spring Cloud核心组件：Hystrix</h2><p>在微服务架构里，一个系统会有很多的服务。<strong>以本文的业务场景为例</strong>：订单服务在一个业务流程里需要调用三个服务。现在假设订单服务自己最多只有100个线程可以处理请求，然后呢，积分服务不幸的挂了，每次订单服务调用积分服务的时候，都会卡住几秒钟，然后抛出—个超时异常。</p>\n<p><strong>咱们一起来分析一下，这样会导致什么问题？</strong></p>\n<pre><code>1. 如果系统处于高并发的场景下，大量请求涌过来的时候，订单服务的100个线程都会卡在请求积分服务这块。导致订单服务没有一个线程可以处理请求\n1. 然后就会导致别人请求订单服务的时候，发现订单服务也挂了，不响应任何请求了</code></pre><p>上面这个，就是<strong>微服务架构中恐怖的服务雪崩问题</strong>，如下图所示：<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/7/166ec0033f64a0a7?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p>如上图，这么多服务互相调用，要是不做任何保护的话，某一个服务挂了，就会引起连锁反应，导致别的服务也挂。比如积分服务挂了，会导致订单服务的线程全部卡在请求积分服务这里，没有一个线程可以工作，瞬间导致订单服务也挂了，别人请求订单服务全部会卡住，无法响应。</p>\n<p><strong>但是我们思考一下，就算积分服务挂了，订单服务也可以不用挂啊！为什么？</strong></p>\n<pre><code>* 我们结合业务来看：支付订单的时候，只要把库存扣减了，然后通知仓库发货就OK了\n* 如果积分服务挂了，大不了等他恢复之后，慢慢人肉手工恢复数据！为啥一定要因为一个积分服务挂了，就直接导致订单服务也挂了呢？不可以接受！</code></pre><p><strong>现在问题分析完了，如何解决？</strong></p>\n<p>这时就轮到Hystrix闪亮登场了。Hystrix是隔离、熔断以及降级的一个框架。啥意思呢？说白了，<strong>Hystrix会搞很多个小小的线程池</strong>，比如订单服务请求库存服务是一个线程池，请求仓储服务是一个线程池，请求积分服务是一个线程池。每个线程池里的线程就仅仅用于请求那个服务。</p>\n<p><strong>打个比方：现在很不幸，积分服务挂了，会咋样？</strong></p>\n<p>当然会导致订单服务里那个用来调用积分服务的线程都卡死不能工作了啊！但由于订单服务调用库存服务、仓储服务的这两个线程池都是正常工作的，所以这两个服务不会受到任何影响。</p>\n<p>这个时候如果别人请求订单服务，订单服务还是可以正常调用库存服务扣减库存，调用仓储服务通知发货。只不过调用积分服务的时候，每次都会报错。<strong>但是如果积分服务都挂了，每次调用都要去卡住几秒钟干啥呢？有意义吗？当然没有！</strong>所以我们直接对积分服务熔断不就得了，比如在5分钟内请求积分服务直接就返回了，不要去走网络请求卡住几秒钟，<strong>这个过程，就是所谓的熔断！</strong></p>\n<hr>\n<p><strong>那人家又说，兄弟，积分服务挂了你就熔断，好歹你干点儿什么啊！别啥都不干就直接返回啊？</strong>没问题，咱们就来个降级：每次调用积分服务，你就在数据库里记录一条消息，说给某某用户增加了多少积分，因为积分服务挂了，导致没增加成功！这样等积分服务恢复了，你可以根据这些记录手工加一下积分。<strong>这个过程，就是所谓的降级。</strong></p>\n<hr>\n<p>为帮助大家更直观的理解，接下来用一张图，梳理一下Hystrix隔离、熔断和降级的全流程：<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/7/166ec004edf94426?imageView2/0/w/1280/h/960/ignore-error/1\" alt><br><a href></a></p>\n<p><a href></a></p>\n<h2 id=\"六、Spring-Cloud核心组件：Zuul\"><a href=\"#六、Spring-Cloud核心组件：Zuul\" class=\"headerlink\" title=\"六、Spring Cloud核心组件：Zuul\"></a>六、Spring Cloud核心组件：Zuul</h2><p>说完了Hystrix，接着给大家说说最后一个组件：Zuul，也就是微服务网关。<strong>这个组件是负责网络路由的。</strong>不懂网络路由？行，那我给你说说，如果没有Zuul的日常工作会怎样？</p>\n<p>假设你后台部署了几百个服务，现在有个前端兄弟，人家请求是直接从浏览器那儿发过来的。<strong>打个比方</strong>：人家要请求一下库存服务，你难道还让人家记着这服务的名字叫做inventory-service？部署在5台机器上？就算人家肯记住这一个，你后台可有几百个服务的名称和地址呢？难不成人家请求一个，就得记住一个？你要这样玩儿，那真是友谊的小船，说翻就翻！</p>\n<p>上面这种情况，压根儿是不现实的。所以一般微服务架构中都必然会设计一个网关在里面，像android、ios、pc前端、微信小程序、H5等等，不用去关心后端有几百个服务，就知道有一个网关，所有请求都往网关走，网关会根据请求中的一些特征，将请求转发给后端的各个服务。</p>\n<p>而且有一个网关之后，还有很多好处，比如可以做<strong>统一的降级、限流、认证授权、安全</strong>，等等。</p>\n<h2 id=\"七、总结：\"><a href=\"#七、总结：\" class=\"headerlink\" title=\"七、总结：\"></a>七、总结：</h2><p>最后再来总结一下，上述几个Spring Cloud核心组件，在微服务架构中，分别扮演的角色：</p>\n<pre><code>* **Eureka**：各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里\n* **Ribbon**：服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台\n* **Feign**：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求\n* **Hystrix**：发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题\n* **Zuul**：如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务</code></pre><p>以上就是我们通过一个电商业务场景，阐述了Spring Cloud微服务架构几个核心组件的底层原理。</p>\n<p><strong>文字总结还不够直观？没问题！</strong>我们将Spring Cloud的5个核心组件通过一张图串联起来，再来直观的感受一下其底层的架构原理：<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/7/166ec006b1536f43?imageView2/0/w/1280/h/960/ignore-error/1\" alt><br><a href></a></p>\n<p><a href></a></p>\n<p>如有收获，请帮忙转发，您的鼓励是作者最大的动力，谢谢！</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/6/166e9511e7162c8b?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<p>Spring Cloud原创系列文章，将会持续更新</p>\n<p>欢迎关注微信公众号：<strong>石杉的架构笔记（id:shishan100）</strong></p>\n<p>十余年<strong>BAT架构经验</strong>倾囊相授</p>\n","text":"本文转载自 https://juejin.im/post/5be13b83f265da6116393fc7<br>欢迎关注微信公众号：石杉的架构笔记（id：shishan100）每周一至五早8点半，精品技术文章准时送上！目录一、业务场景介绍二、Spring Cloud核心组件：E","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Spring","slug":"Spring","count":2,"path":"api/tags/Spring.json"},{"name":"架构","slug":"架构","count":4,"path":"api/tags/架构.json"},{"name":"微服务","slug":"微服务","count":1,"path":"api/tags/微服务.json"},{"name":"服务器","slug":"服务器","count":1,"path":"api/tags/服务器.json"}]}]}