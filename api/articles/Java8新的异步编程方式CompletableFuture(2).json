{"title":"Java8新的异步编程方式 CompletableFuture(二)","slug":"Java8新的异步编程方式CompletableFuture(2)","date":"2019-05-14T03:46:06.006Z","updated":"2019-05-30T00:52:25.403Z","comments":true,"path":"api/articles/Java8新的异步编程方式CompletableFuture(2).json","photos":[],"link":"","excerpt":"","covers":null,"content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/59eae6e4f265da430e4e4cb5\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/59eae6e4f265da430e4e4cb5</a> </p>\n</blockquote>\n<p><a href=\"https://juejin.im/post/59eae61b51882549fc512b34\" target=\"_blank\" rel=\"noopener\">上一篇文章</a>，讲述了Future模式的机制、缺点，CompletableFuture产生的由来、静态工厂方法、complete()方法等等。</p>\n<p>本文将继续整理CompletableFuture的特性。</p>\n<h2 id=\"3-3-转换\"><a href=\"#3-3-转换\" class=\"headerlink\" title=\"3.3 转换\"></a>3.3 转换</h2><p>我们可以通过CompletableFuture来异步获取一组数据，并对数据进行一些转换，类似RxJava、Scala的map、flatMap操作。</p>\n<h3 id=\"3-3-1-map\"><a href=\"#3-3-1-map\" class=\"headerlink\" title=\"3.3.1 map\"></a>3.3.1 map</h3><table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">thenApply(Function&lt;? super T,? extends U&gt; fn)</td>\n<td align=\"center\">接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture</td>\n</tr>\n<tr>\n<td align=\"center\">thenApplyAsync(Function&lt;? super T,? extends U&gt; fn)</td>\n<td align=\"center\">接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture，使用ForkJoinPool</td>\n</tr>\n<tr>\n<td align=\"center\">thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor)</td>\n<td align=\"center\">接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture，使用指定的线程池</td>\n</tr>\n</tbody></table>\n<p>thenApply的功能相当于将CompletableFuture<t>转换成CompletableFuture<u>。\n`CompletableFuture<string> future = CompletableFuture.supplyAsync(() -&gt; );</string></u></t></p>\n<pre><code>future = future.thenApply( Function&lt;String, String&gt;() {\n\n\n    {\n\n         s + ;\n    }\n}).thenApply( Function&lt;String, String&gt;() {\n\n    {\n\n         s.toUpperCase();\n    }\n});\n\n {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>再用lambda表达式简化一下</p>\n<p>`CompletableFuture<string> future = CompletableFuture.supplyAsync(() -&gt; )<br>                .thenApply(s -&gt; s + ).thenApply(String::toUpperCase);</string></p>\n<pre><code> {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果：</p>\n<p><code>HELLO WORLD</code></p>\n<p>下面的例子，展示了数据流的类型经历了如下的转换：String -&gt; Integer -&gt; Double。</p>\n<p>`CompletableFuture<double> future = CompletableFuture.supplyAsync(() -&gt; )<br>                .thenApply(Integer::parseInt)<br>                .thenApply(i-&gt;i*);</double></p>\n<pre><code> {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果：</p>\n<p>``</p>\n<h3 id=\"3-3-2-flatMap\"><a href=\"#3-3-2-flatMap\" class=\"headerlink\" title=\"3.3.2 flatMap\"></a>3.3.2 flatMap</h3><table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">thenCompose(Function&lt;? super T, ? extends CompletionStage<u>&gt; fn)</u></td>\n<td align=\"center\">在异步操作完成的时候对异步操作的结果进行一些操作，并且仍然返回CompletableFuture类型。</td>\n</tr>\n<tr>\n<td align=\"center\">thenComposeAsync(Function&lt;? super T, ? extends CompletionStage<u>&gt; fn)</u></td>\n<td align=\"center\">在异步操作完成的时候对异步操作的结果进行一些操作，并且仍然返回CompletableFuture类型。使用ForkJoinPool。</td>\n</tr>\n<tr>\n<td align=\"center\">thenComposeAsync(Function&lt;? super T, ? extends CompletionStage<u>&gt; fn,Executor executor)</u></td>\n<td align=\"center\">在异步操作完成的时候对异步操作的结果进行一些操作，并且仍然返回CompletableFuture类型。使用指定的线程池。</td>\n</tr>\n</tbody></table>\n<p>thenCompose可以用于组合多个CompletableFuture，将前一个结果作为下一个计算的参数，它们之间存在着先后顺序。<br>`CompletableFuture<string> future = CompletableFuture.supplyAsync(() -&gt; )<br>                .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + ));</string></p>\n<pre><code> {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果：</p>\n<p><code>Hello World</code></p>\n<p>下面的例子展示了多次调用thenCompose()</p>\n<p>`CompletableFuture<double> future = CompletableFuture.supplyAsync(() -&gt; )<br>                .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + ))<br>                .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; Double.parseDouble(s)));</double></p>\n<pre><code> {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果：</p>\n<p>``</p>\n<h2 id=\"3-4-组合\"><a href=\"#3-4-组合\" class=\"headerlink\" title=\"3.4 组合\"></a>3.4 组合</h2><table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">thenCombine(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn)</td>\n<td align=\"center\">当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。</td>\n</tr>\n<tr>\n<td align=\"center\">thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn)</td>\n<td align=\"center\">当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。使用ForkJoinPool。</td>\n</tr>\n<tr>\n<td align=\"center\">thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn, Executor executor)</td>\n<td align=\"center\">当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。使用指定的线程池。</td>\n</tr>\n</tbody></table>\n<p>现在有CompletableFuture<t>、CompletableFuture<u>和一个函数(T,U)-&gt;V，thenCompose就是将CompletableFuture<t>和CompletableFuture<u>变为CompletableFuture<v>。\n`CompletableFuture<string> future1 = CompletableFuture.supplyAsync(() -&gt; );<br>        CompletableFuture<integer> future2 = CompletableFuture.supplyAsync(() -&gt; );</integer></string></v></u></t></u></t></p>\n<pre><code>CompletableFuture&lt;Double&gt; future = future1.thenCombine(future2, (s, i) -&gt; Double.parseDouble(s + i));\n\n {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果：</p>\n<p>``\n使用thenCombine()之后future1、future2之间是并行执行的，最后再将结果汇总。这一点跟thenCompose()不同。</p>\n<p>thenAcceptBoth跟thenCombine类似，但是返回CompletableFuture类型。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">thenAcceptBoth(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action)</td>\n<td align=\"center\">当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。</td>\n</tr>\n<tr>\n<td align=\"center\">thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action)</td>\n<td align=\"center\">当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。使用ForkJoinPool。</td>\n</tr>\n<tr>\n<td align=\"center\">thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action, Executor executor)</td>\n<td align=\"center\">当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。使用指定的线程池。</td>\n</tr>\n<tr>\n<td align=\"center\">`CompletableFuture<string> future1 = CompletableFuture.supplyAsync(() -&gt; );</string></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">CompletableFuture<integer> future2 = CompletableFuture.supplyAsync(() -&gt; );</integer></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<pre><code>CompletableFuture&lt;Void&gt; future = future1.thenAcceptBoth(future2, (s, i) -&gt; System.out.println(Double.parseDouble(s + i)));\n\n {\n    future.get();\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果：</p>\n<p>``</p>\n<h2 id=\"3-5-计算结果完成时的处理\"><a href=\"#3-5-计算结果完成时的处理\" class=\"headerlink\" title=\"3.5 计算结果完成时的处理\"></a>3.5 计算结果完成时的处理</h2><p>当CompletableFuture完成计算结果后，我们可能需要对结果进行一些处理。</p>\n<p>/#/#/#3.5.1 执行特定的Action</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">whenComplete(BiConsumer&lt;? super T,? super Throwable&gt; action)</td>\n<td align=\"center\">当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。</td>\n</tr>\n<tr>\n<td align=\"center\">whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action)</td>\n<td align=\"center\">当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。使用ForkJoinPool。</td>\n</tr>\n<tr>\n<td align=\"center\">whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action, Executor executor)</td>\n<td align=\"center\">当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。使用指定的线程池。</td>\n</tr>\n<tr>\n<td align=\"center\">`CompletableFuture.supplyAsync(() -&gt; )</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">.thenApply(s-&gt;s+)</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">.thenApply(s-&gt;s+ )</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">.thenApply(String::toLowerCase)</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">.whenComplete((result, throwable) -&gt; System.out.println(result));`</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>执行结果：</p>\n<p><code>hello world\n is completablefuture demo</code></p>\n<p>/#/#/#3.5.2 执行完Action可以做转换</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)</td>\n<td align=\"center\">当CompletableFuture完成计算结果或者抛出异常的时候，执行提供的fn</td>\n</tr>\n<tr>\n<td align=\"center\">handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)</td>\n<td align=\"center\">当CompletableFuture完成计算结果或者抛出异常的时候，执行提供的fn，使用ForkJoinPool。</td>\n</tr>\n<tr>\n<td align=\"center\">handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn, Executor executor)</td>\n<td align=\"center\">当CompletableFuture完成计算结果或者抛出异常的时候，执行提供的fn，使用指定的线程池。</td>\n</tr>\n<tr>\n<td align=\"center\">`CompletableFuture<double> future = CompletableFuture.supplyAsync(() -&gt; )</double></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">.thenApply(s-&gt;s+)</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">.handle((s, t) -&gt; s !=  ? Double.parseDouble(s) : );</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<pre><code> {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果：</p>\n<p>``</p>\n<p>在这里，handle()的参数是BiFunction，apply()方法返回R，相当于转换的操作。</p>\n<p>`{</p>\n<pre><code>;\n\n\n &lt;V&gt; {\n    Objects.requireNonNull(after);\n     (T t, U u) -&gt; after.apply(apply(t, u));\n}</code></pre><p>}`</p>\n<p>而whenComplete()的参数是BiConsumer，accept()方法返回void。</p>\n<p>`{</p>\n<pre><code>;\n\n\n{\n    Objects.requireNonNull(after);\n\n     (l, r) -&gt; {\n        accept(l, r);\n        after.accept(l, r);\n    };\n}</code></pre><p>}`\n所以，handle()相当于whenComplete()+转换。</p>\n<p>/#/#/#3.5.3 纯消费(执行Action)</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">thenAccept(Consumer&lt;? super T&gt; action)</td>\n<td align=\"center\">当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值</td>\n</tr>\n<tr>\n<td align=\"center\">thenAcceptAsync(Consumer&lt;? super T&gt; action)</td>\n<td align=\"center\">当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值，使用ForkJoinPool。</td>\n</tr>\n<tr>\n<td align=\"center\">thenAcceptAsync(Consumer&lt;? super T&gt; action, Executor executor)</td>\n<td align=\"center\">当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值</td>\n</tr>\n</tbody></table>\n<p>thenAccept()是只会对计算结果进行消费而不会返回任何结果的方法。<br><code>CompletableFuture.supplyAsync(() -&gt; )\n                .thenApply(s-&gt;s+)\n                .thenApply(s-&gt;s+ )\n                .thenApply(String::toLowerCase)\n                .thenAccept(System.out::print);</code></p>\n<p>执行结果：</p>\n<p><code>hello world\n is completablefuture demo</code></p>\n","categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]}