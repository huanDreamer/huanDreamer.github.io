{"title":"面试官：说说你对ThreadLocal的了解","slug":"面试官：说说你对ThreadLocal的了解","date":"2019-05-10T02:49:48.048Z","updated":"2019-05-30T00:52:25.435Z","comments":true,"path":"api/articles/面试官：说说你对ThreadLocal的了解.json","photos":[],"link":"","excerpt":"","covers":["https://user-gold-cdn.xitu.io/2019/5/8/16a97cde94bb4de0?imageView2/0/w/1280/h/960/ignore-error/1"],"content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5cd2dcf4f265da03804386d0\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5cd2dcf4f265da03804386d0</a> </p>\n</blockquote>\n<p>一般有多个孩子的家庭，买玩具都得买多个。如果就买一个，嘿嘿就比较刺激了。这就是<strong>避免共享</strong>，给孩子每人一个玩具对应到我们Java中也就是每个线程都有自己的本地变量，咱们自己玩自己的，避免争抢，和谐相处使得线程安全。</p>\n<p>Java就是通过<code>ThreadLocal</code>来实现线程本地存储的。</p>\n<p>这思路也很清晰，就是每个线程要有自己的本地变量呗，那就Thread里面搞一个私有属性呗<code>ThreadLocal.ThreadLocalMap threadLocals = null;</code> 就是如下图所示的这个关系</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/8/16a97cde94bb4de0?imageView2/0/w/1280/h/960/ignore-error/1\" alt></p>\n<h2 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h2><p>简单的应用如下</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo &#123;</span><br><span class=\"line\">\t\tprivate static final ThreadLocal&lt;Foo&gt; fooLocal = new ThreadLocal&lt;Foo&gt;();</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tpublic static Foo getFoo() &#123;</span><br><span class=\"line\">\t\t\treturn fooLocal.get();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tpublic static void setFoo(Foo foo) &#123;</span><br><span class=\"line\">\t\t\tfooLocal.set(foo);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>再深入了解一下内部情况，<code>ThreadLocalMap</code>是<code>ThreadLocal</code>的内部静态类，它虽然叫<code>Map</code>但是和<code>java.util.Map</code>没有啥亲戚关系，只是它实现的功能像<code>Map</code></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static class ThreadLocalMap &#123;</span><br><span class=\"line\">        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class=\"line\">            Object value;</span><br><span class=\"line\">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">                super(k);</span><br><span class=\"line\">                value = v;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        private static final int INITIAL_CAPACITY = 16;</span><br><span class=\"line\">        private Entry[] table;</span><br></pre></td></tr></table></figure></div>\n\n<p>可以看到<code>ThreadLocalMap</code>里面有个<code>Entry</code>数组，只有数组没有像<code>HashMap</code>那样有链表，因此当hash冲突的之后，<code>ThreadLocalMap</code>是<strong>采用线性探测的方式解决hash冲突。</strong></p>\n<p>线性探测，就是先根据初始<code>key</code>的<code>hashcode</code>值确定元素在<code>table</code>数组中的位置，如果这个位置上已经有其他<code>key</code>值的元素被占用，则利用固定的算法寻找一定步长的下个位置，依次直至找到能够存放的位置。在<code>ThreadLocalMap</code>步长是1。</p>\n<p><strong>用这种方式解决hash冲突的效率很低，因此要注意ThreadLocal的数量</strong>。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">         * Increment i modulo len. </span><br><span class=\"line\">         */</span><br><span class=\"line\">        private static int nextIndex(int i, int len) &#123;</span><br><span class=\"line\">            return ((i + 1 &lt; len) ? i + 1 : 0);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * Decrement i modulo len.</span><br><span class=\"line\">         */</span><br><span class=\"line\">        private static int prevIndex(int i, int len) &#123;</span><br><span class=\"line\">            return ((i - 1 &gt;= 0) ? i - 1 : len - 1);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>而且可以看到这个<code>Entry</code>把<code>ThreadLocal</code>的弱引用作为key。那为什么要搞成弱引用(只要发生了GC弱引用对象就会被回收)呢？</p>\n<p>首先<code>ThreadLocal</code>内部没有存储任何的值，它的作用只是当我们的<code>ThreadLocalMap的key</code>，让线程可以拿到对应的<code>value</code>。当我们不需要用这个key的时候我们，我们把<code>fooLocal=null</code>这样强引用就没了。假设Entry里面也是强引用的话，那等于这个<code>ThreadLocal</code>实例还有个强引用在，那么我们想让GC回收<code>fooLocal</code>就回收不了了。那可能有人想，你弄成弱引用不是很危险啊，万一GC一下不是没了？别怕只要<code>fooLocal</code>这个强引用在这个<code>ThreadLocal</code>实例就不会回收的。(关于强软弱虚引用可以看我之前的文章<a href=\"https://juejin.im/post/5cd386be51882511282b8746\" target=\"_blank\" rel=\"noopener\">四种引用方式的区别</a>)</p>\n<p>因此弄成弱引用，主要是让没用的<code>ThreadLocal</code>得以GC清除。</p>\n<p>这里可能还有人问那key清除掉了，value咋办，这个Entry还在的呀。是的，当在使用线程池的情况下，由于线程的生命周期很长，某些大对象的key被移除了之后，value一直存在的就可能会导致内存泄漏。</p>\n<p>不过java考虑到这点了。当调用<code>get()、set()</code>方法时会去找到那个key被干掉的entry然后干掉它。并且提供了<code>remove()</code>方法。虽然<code>get()、set()</code>会清理<code>key</code>为<code>null的Entry</code>,但是不是每次调用就会清理的，只有当<code>get</code>时候直接hash没中，或者<code>set</code>时候也是直接hash没中，开始线性探测时候，碰到key为null的才会清理。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//get 方法</span><br><span class=\"line\">        private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class=\"line\">            int i = key.threadLocalHashCode &amp;amp; (table.length - 1);</span><br><span class=\"line\">            Entry e = table[i];</span><br><span class=\"line\">            if (e != null &amp;amp;&amp;amp; e.get() == key)</span><br><span class=\"line\">                return e;                           //命中就直接返回</span><br><span class=\"line\">            else</span><br><span class=\"line\">                return getEntryAfterMiss(key, i, e); //直接没命中</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class=\"line\">            Entry[] tab = table;</span><br><span class=\"line\">            int len = tab.length;</span><br><span class=\"line\">            while (e != null) &#123; //开始探测了</span><br><span class=\"line\">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">                if (k == key)  //命中了就返回</span><br><span class=\"line\">                    return e;</span><br><span class=\"line\">                if (k == null)  //探测到key是null的就清理</span><br><span class=\"line\">                    expungeStaleEntry(i);</span><br><span class=\"line\">                else</span><br><span class=\"line\">                    i = nextIndex(i, len); //否则继续</span><br><span class=\"line\">                e = tab[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //set 方法</span><br><span class=\"line\">        private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class=\"line\">            Entry[] tab = table;</span><br><span class=\"line\">            int len = tab.length;</span><br><span class=\"line\">            int i = key.threadLocalHashCode &amp;amp; (len-1);</span><br><span class=\"line\">            for (Entry e = tab[i];</span><br><span class=\"line\">                 e != null;</span><br><span class=\"line\">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">                if (k == key) &#123;</span><br><span class=\"line\">                    e.value = value;    //如果已经有就替换原有的value</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (k == null) &#123;</span><br><span class=\"line\">                    replaceStaleEntry(key, value, i);</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tab[i] = new Entry(key, value);</span><br><span class=\"line\">            int sz = ++size;</span><br><span class=\"line\">            if (!cleanSomeSlots(i, sz) &amp;amp;&amp;amp; sz &gt;= threshold)</span><br><span class=\"line\">                rehash();</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>因此，当不需要<code>threadlocal</code>的时候还是显示调用<code>remove()</code>方法较好。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>线程本地存储本质就是<strong>避免共享</strong>，在使用中注意内存泄露问题和hash碰撞问题即可。使用还是很广泛的像spring中事务就用到<code>threadlocal</code>。</p>\n<hr>\n<p>如有错误欢迎指正！</p>\n<p>个人公众号:yes的练级攻略</p>\n<p>有相关面试进阶(分布式、性能调优、经典书籍pdf)资料等待领取</p>\n","categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]}