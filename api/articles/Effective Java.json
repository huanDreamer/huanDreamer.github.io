{"title":"","slug":"Effective Java","date":"2019-05-30T00:52:25.400Z","updated":"2019-05-30T00:52:25.400Z","comments":true,"path":"api/articles/Effective Java.json","photos":[],"link":"","excerpt":"","covers":null,"content":"<h1 id=\"对象的创建和销毁\"><a href=\"#对象的创建和销毁\" class=\"headerlink\" title=\"对象的创建和销毁\"></a>对象的创建和销毁</h1><h3 id=\"一、使用静态工厂方法代替构造器\"><a href=\"#一、使用静态工厂方法代替构造器\" class=\"headerlink\" title=\"一、使用静态工厂方法代替构造器\"></a>一、使用静态工厂方法代替构造器</h3><ol>\n<li>静态工厂优势一：有名称。当一个类需要多个带有相同签名的构造器时，可以通过名称突出它们之间的区别</li>\n<li>静态工程优势二：不必每次都创建新的对象。可以将创建的实例缓存，或者是返回预先构建好的实例(工厂模式)。例如 <code>Boolean.valueOf(boolean)</code>。如果确保了每次返回的都是同一对象的话，可以使用<code>==</code>进行判断，提升效率</li>\n<li>静态工厂优势三：可以返回原返回类型的任何子类的对象，可以返回受保护的类的对象。例如<code>Collections.singletonList(T)</code>、<code>EnumSet</code>。</li>\n</ol>\n<h3 id=\"二、遇到多个构造器参数时要考虑用构造器\"><a href=\"#二、遇到多个构造器参数时要考虑用构造器\" class=\"headerlink\" title=\"二、遇到多个构造器参数时要考虑用构造器\"></a>二、遇到多个构造器参数时要考虑用构造器</h3><p>​    Builder 模式。这个就不必多少了，当构造器参数很多，并且都是可选时，推荐使用builder。也可以提供一个<code>DefaultInstance</code>，返回具有默认参数的对象。推荐一个工具 <a href=\"https://www.projectlombok.org/\" target=\"_blank\" rel=\"noopener\">lombok</a> ,使用注解生成样板代码。</p>\n<h3 id=\"三、使用私有构造器或者枚举类型强化-Singleton-属性\"><a href=\"#三、使用私有构造器或者枚举类型强化-Singleton-属性\" class=\"headerlink\" title=\"三、使用私有构造器或者枚举类型强化 Singleton 属性\"></a>三、使用私有构造器或者枚举类型强化 Singleton 属性</h3><p>​    使构造器私有，通过创建<code>getInstance</code>方法，返回该类的唯一<code>private static final</code>的实例。好处在于，在不改变API的前提下，可以改变方法实现，从而对类是否为<code>Singleton</code>。但是客户端可以使用<code>AccessibleObject.setAccessible</code>方法，通过反射调用私有构造器。</p>\n<p>​    实现<code>Singleton</code>还可以使用<code>Enum</code>。</p>\n<h3 id=\"四、通过私有构造器强化不可变实例化的能力\"><a href=\"#四、通过私有构造器强化不可变实例化的能力\" class=\"headerlink\" title=\"四、通过私有构造器强化不可变实例化的能力\"></a>四、通过私有构造器强化不可变实例化的能力</h3><p>​    例如工具类，不希望客户端对它进行实例化（实例化没有任何意义），可以创建私有的无参构造函数进行屏蔽对象的创建。NERVER：企图通过做成抽象类来强制该类不能被实例化，这样会引起误解。</p>\n<h3 id=\"五、避免创建不必要的对象\"><a href=\"#五、避免创建不必要的对象\" class=\"headerlink\" title=\"五、避免创建不必要的对象\"></a>五、避免创建不必要的对象</h3><ol>\n<li><p>避免 <code>String s = new String(&quot;***&quot;)</code>的操作</p>\n</li>\n<li><p>需要重复使用的对象，应该将实例进行缓存，而不是每次都创建。例如判断一个人是否为2000年后出生，应该将<code>2000-1-1</code>进行缓存，再和他的出生日期进行比较</p>\n</li>\n<li><p><code>适配器模式</code>中，没有必要创建多个适配器对象。例如<code>Map.keySet()</code>方法，就会将<code>ks</code>对象进行缓存。每次都返回同一个对象</p>\n</li>\n<li><p>避免大量的<code>自动装箱</code>操作。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Long sum = <span class=\"number\">0L</span>; \t<span class=\"comment\">// 使用 long sum = 0L 可以避免自动装箱，节省大量资源</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">long</span>  i = <span class=\"number\">0</span>; i &lt; Integer.MAX_VALUE; i ++) &#123;</span><br><span class=\"line\">    sum += i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n\n\n</li>\n</ol>\n","categories":[],"tags":[]}