{"title":"Java8新的异步编程方式 CompletableFuture(一)","slug":"Java8新的异步编程方式CompletableFuture(1)","date":"2019-05-14T03:45:42.042Z","updated":"2019-05-30T00:52:25.403Z","comments":true,"path":"api/articles/Java8新的异步编程方式CompletableFuture(1).json","photos":[],"link":"","excerpt":"","covers":null,"content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/59eae61b51882549fc512b34\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/59eae61b51882549fc512b34</a> </p>\n</blockquote>\n<h1 id=\"一-Future\"><a href=\"#一-Future\" class=\"headerlink\" title=\"一. Future\"></a>一. Future</h1><p>JDK 5引入了Future模式。Future接口是Java多线程Future模式的实现，在java.util.concurrent包中，可以来进行异步计算。</p>\n<p>Future模式是多线程设计常用的一种设计模式。Future模式可以理解成：我有一个任务，提交给了Future，Future替我完成这个任务。期间我自己可以去做任何想做的事情。一段时间之后，我就便可以从Future那儿取出结果。</p>\n<p>Future的接口很简单，只有五个方法。<br>`{</p>\n<pre><code>;\n\n;\n\n;\n\n;\n\n;</code></pre><p>}`</p>\n<p>Future接口的方法介绍如下：</p>\n<pre><code>* boolean cancel (boolean mayInterruptIfRunning) 取消任务的执行。参数指定是否立即中断任务执行，或者等等任务结束\n* boolean isCancelled () 任务是否已经取消，任务正常完成前将其取消，则返回 true\n* boolean isDone () 任务是否已经完成。需要注意的是如果任务正常终止、异常或取消，都将返回true\n* V get () throws InterruptedException, ExecutionException 等待任务执行结束，然后获得V类型的结果。InterruptedException 线程被中断异常， ExecutionException任务执行异常，如果任务被取消，还会抛出CancellationException\n* V get (long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException 同上面的get功能一样，多了设置超时时间。参数timeout指定超时时间，uint指定时间的单位，在枚举类TimeUnit中有相关的定义。如果计 算超时，将抛出TimeoutException</code></pre><p>一般情况下，我们会结合Callable和Future一起使用，通过ExecutorService的submit方法执行Callable，并返回Future。<br>`ExecutorService executor = Executors.newCachedThreadPool();</p>\n<pre><code>Future&lt;String&gt; future = executor.submit(() -&gt; { \n    System.out.println();\n    Thread.sleep();\n     ;\n});\n\n {\n    Thread.sleep();\n}  (InterruptedException e) {\n}\n\nSystem.out.println();  \n\n {\n    System.out.println(future.get());  \n}  (InterruptedException e) {\n}  (ExecutionException e) {\n\n}  {\n    executor.shutdown();\n}`</code></pre><p>比起future.get()，其实更推荐使用get (long timeout, TimeUnit unit) 方法，设置了超时时间可以防止程序无限制的等待future的结果。</p>\n<h1 id=\"二-CompletableFuture介绍\"><a href=\"#二-CompletableFuture介绍\" class=\"headerlink\" title=\"二. CompletableFuture介绍\"></a>二. CompletableFuture介绍</h1><h2 id=\"2-1-Future模式的缺点\"><a href=\"#2-1-Future模式的缺点\" class=\"headerlink\" title=\"2.1 Future模式的缺点\"></a>2.1 Future模式的缺点</h2><pre><code>* Future虽然可以实现获取异步执行结果的需求，但是它没有提供通知的机制，我们无法得知Future什么时候完成。\n* 要么使用阻塞，在future.get()的地方等待future返回的结果，这时又变成同步操作。要么使用isDone()轮询地判断Future是否完成，这样会耗费CPU的资源。</code></pre><h2 id=\"2-2-CompletableFuture介绍\"><a href=\"#2-2-CompletableFuture介绍\" class=\"headerlink\" title=\"2.2 CompletableFuture介绍\"></a>2.2 CompletableFuture介绍</h2><p>Netty、Guava分别扩展了Java 的 Future 接口，方便异步编程。</p>\n<p>Java 8新增的CompletableFuture类正是吸收了所有Google Guava中ListenableFuture和SettableFuture的特征，还提供了其它强大的功能，让Java拥有了完整的非阻塞编程模型：Future、Promise 和 Callback(在Java8之前，只有无Callback 的Future)。</p>\n<p>CompletableFuture能够将回调放到与任务不同的线程中执行，也能将回调作为继续执行的同步函数，在与任务相同的线程中执行。它避免了传统回调最大的问题，那就是能够将控制流分离到不同的事件处理器中。</p>\n<p>CompletableFuture弥补了Future模式的缺点。在异步的任务完成后，需要用其结果继续操作时，无需等待。可以直接通过thenAccept、thenApply、thenCompose等方式将前面异步处理的结果交给另外一个异步事件处理线程来处理。</p>\n<h1 id=\"三-CompletableFuture特性\"><a href=\"#三-CompletableFuture特性\" class=\"headerlink\" title=\"三. CompletableFuture特性\"></a>三. CompletableFuture特性</h1><h2 id=\"3-1-CompletableFuture的静态工厂方法\"><a href=\"#3-1-CompletableFuture的静态工厂方法\" class=\"headerlink\" title=\"3.1 CompletableFuture的静态工厂方法\"></a>3.1 CompletableFuture的静态工厂方法</h2><table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">runAsync(Runnable runnable)</td>\n<td align=\"center\">使用ForkJoinPool.commonPool()作为它的线程池执行异步代码。</td>\n</tr>\n<tr>\n<td align=\"center\">runAsync(Runnable runnable, Executor executor)</td>\n<td align=\"center\">使用指定的thread pool执行异步代码。</td>\n</tr>\n<tr>\n<td align=\"center\">supplyAsync(Supplier<u> supplier)</u></td>\n<td align=\"center\">使用ForkJoinPool.commonPool()作为它的线程池执行异步代码，异步操作有返回值</td>\n</tr>\n<tr>\n<td align=\"center\">supplyAsync(Supplier<u> supplier, Executor executor)</u></td>\n<td align=\"center\">使用指定的thread pool执行异步代码，异步操作有返回值</td>\n</tr>\n</tbody></table>\n<p>runAsync 和 supplyAsync 方法的区别是runAsync返回的CompletableFuture是没有返回值的。<br>`CompletableFuture<void> future = CompletableFuture.runAsync(() -&gt; {<br>            System.out.println();<br>        });</void></p>\n<pre><code> {\n    future.get();\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}\n\nSystem.out.println();`</code></pre><p>而supplyAsync返回的CompletableFuture是由返回值的，下面的代码打印了future的返回值。</p>\n<p>`CompletableFuture<string> future = CompletableFuture.supplyAsync(() -&gt; );</string></p>\n<pre><code> {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}\n\nSystem.out.println();`</code></pre><h2 id=\"3-2-Completable\"><a href=\"#3-2-Completable\" class=\"headerlink\" title=\"3.2 Completable\"></a>3.2 Completable</h2><table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">complete(T t)</td>\n<td align=\"center\">完成异步执行，并返回future的结果</td>\n</tr>\n<tr>\n<td align=\"center\">completeExceptionally(Throwable ex)</td>\n<td align=\"center\">异步执行不正常的结束</td>\n</tr>\n</tbody></table>\n<p>future.get()在等待执行结果时，程序会一直block，如果此时调用complete(T t)会立即执行。<br>`CompletableFuture<string> future  = CompletableFuture.supplyAsync(() -&gt; );</string></p>\n<pre><code>future.complete();\n\n {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果：</p>\n<p><code>World</code></p>\n<p>可以看到future调用complete(T t)会立即执行。但是complete(T t)只能调用一次，后续的重复调用会失效。</p>\n<p>如果future已经执行完毕能够返回结果，此时再调用complete(T t)则会无效。<br>`CompletableFuture<string> future = CompletableFuture.supplyAsync(() -&gt; );</string></p>\n<pre><code> {\n    Thread.sleep();\n}  (InterruptedException e) {\n    e.printStackTrace();\n}\n\nfuture.complete();\n\n {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果：</p>\n<p><code>Hello</code></p>\n<p>如果使用completeExceptionally(Throwable ex)则抛出一个异常，而不是一个成功的结果。</p>\n<p>`CompletableFuture<string> future = CompletableFuture.supplyAsync(() -&gt; );</string></p>\n<pre><code>future.completeExceptionally( Exception());\n\n {\n    System.out.println(future.get());\n}  (InterruptedException e) {\n    e.printStackTrace();\n}  (ExecutionException e) {\n    e.printStackTrace();\n}`</code></pre><p>执行结果：</p>\n<p><code>java.util.concurrent.ExecutionException: java.lang.Exception\n...</code></p>\n","categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]}