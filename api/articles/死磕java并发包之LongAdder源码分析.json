{"title":"死磕 java并发包之LongAdder源码分析","slug":"死磕java并发包之LongAdder源码分析","date":"2019-05-13T03:14:06.006Z","updated":"2019-05-30T00:52:25.430Z","comments":true,"path":"api/articles/死磕java并发包之LongAdder源码分析.json","photos":[],"link":"","excerpt":"","covers":["https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/LongAdder1.png","https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/LongAdder2.png","https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode_ss.jpg"],"content":"<blockquote>\n<p>本文转载自 <a href=\"https://juejin.im/post/5cd842aa6fb9a032332b4bb8\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5cd842aa6fb9a032332b4bb8</a> </p>\n</blockquote>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>（1）java8中为什么要新增LongAdder？</p>\n<p>（2）LongAdder的实现方式？</p>\n<p>（3）LongAdder与AtomicLong的对比？</p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>LongAdder是java8中新增的原子类，在多线程环境中，它比AtomicLong性能要高出不少，特别是写多的场景。</p>\n<p>它是怎么实现的呢？让我们一起来学习吧。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>LongAdder的原理是，在最初无竞争时，只更新base的值，当有多线程竞争时通过分段的思想，让不同的线程更新不同的段，最后把这些段相加就得到了完整的LongAdder存储的值。</p>\n<p><img src=\"https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/LongAdder1.png\" alt=\"LongAdder\"></p>\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><p>LongAdder继承自Striped64抽象类，Striped64中定义了Cell内部类和各重要属性。</p>\n<h3 id=\"主要内部类\"><a href=\"#主要内部类\" class=\"headerlink\" title=\"主要内部类\"></a>主要内部类</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Striped64中的内部类，使用@sun.misc.Contended注解，说明里面的值消除伪共享</span><br><span class=\"line\">@sun.misc.Contended static final class Cell &#123;</span><br><span class=\"line\">    // 存储元素的值，使用volatile修饰保证可见性</span><br><span class=\"line\">    volatile long value;</span><br><span class=\"line\">    Cell(long x) &#123; value = x; &#125;</span><br><span class=\"line\">    // CAS更新value的值</span><br><span class=\"line\">    final boolean cas(long cmp, long val) &#123;</span><br><span class=\"line\">        return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Unsafe实例</span><br><span class=\"line\">    private static final sun.misc.Unsafe UNSAFE;</span><br><span class=\"line\">    // value字段的偏移量</span><br><span class=\"line\">    private static final long valueOffset;</span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class=\"line\">            Class&lt;?&gt; ak = Cell.class;</span><br><span class=\"line\">            valueOffset = UNSAFE.objectFieldOffset</span><br><span class=\"line\">                (ak.getDeclaredField(&quot;value&quot;));</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            throw new Error(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>Cell类使用@sun.misc.Contended注解，说明是要避免伪共享的。</p>\n<p>使用Unsafe的CAS更新value的值，其中value的值使用volatile修饰，保证可见性。</p>\n<p>关于Unsafe的介绍请查看【<a href=\"https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F0s-u-MysppIaIHVrshp9fA\" target=\"_blank\" rel=\"noopener\">死磕 java魔法类之Unsafe解析</a>】。</p>\n<p>关于伪共享的介绍请查看【<a href=\"https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Frd13SOSxhLA6TT13N9ni8Q\" target=\"_blank\" rel=\"noopener\">杂谈 什么是伪共享（false sharing）？</a>】。</p>\n<h3 id=\"主要属性\"><a href=\"#主要属性\" class=\"headerlink\" title=\"主要属性\"></a>主要属性</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这三个属性都在Striped64中</span><br><span class=\"line\">// cells数组，存储各个段的值</span><br><span class=\"line\">transient volatile Cell[] cells;</span><br><span class=\"line\">// 最初无竞争时使用的，也算一个特殊的段</span><br><span class=\"line\">transient volatile long base;</span><br><span class=\"line\">// 标记当前是否有线程在创建或扩容cells，或者在创建Cell</span><br><span class=\"line\">// 通过CAS更新该值，相当于是一个锁</span><br><span class=\"line\">transient volatile int cellsBusy;</span><br></pre></td></tr></table></figure></div>\n\n<p>最初无竞争或有其它线程在创建cells数组时使用base更新值，有过竞争时使用cells更新值。</p>\n<p>最初无竞争是指一开始没有线程之间的竞争，但也有可能是多线程在操作，只是这些线程没有同时去更新base的值。</p>\n<p>有过竞争是指只要出现过竞争不管后面有没有竞争都使用cells更新值，规则是不同的线程hash到不同的cell上去更新，减少竞争。</p>\n<h3 id=\"add-x-方法\"><a href=\"#add-x-方法\" class=\"headerlink\" title=\"add(x)方法\"></a>add(x)方法</h3><p>add(x)方法是LongAdder的主要方法，使用它可以使LongAdder中存储的值增加x，x可为正可为负。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void add(long x) &#123;</span><br><span class=\"line\">    // as是Striped64中的cells属性</span><br><span class=\"line\">    // b是Striped64中的base属性</span><br><span class=\"line\">    // v是当前线程hash到的Cell中存储的值</span><br><span class=\"line\">    // m是cells的长度减1，hash时作为掩码使用</span><br><span class=\"line\">    // a是当前线程hash到的Cell</span><br><span class=\"line\">    Cell[] as; long b, v; int m; Cell a;</span><br><span class=\"line\">    // 条件1：cells不为空，说明出现过竞争，cells已经创建</span><br><span class=\"line\">    // 条件2：cas操作base失败，说明其它线程先一步修改了base，正在出现竞争</span><br><span class=\"line\">    if ((as = cells) != null || !casBase(b = base, b + x)) &#123;</span><br><span class=\"line\">        // true表示当前竞争还不激烈</span><br><span class=\"line\">        // false表示竞争激烈，多个线程hash到同一个Cell，可能要扩容</span><br><span class=\"line\">        boolean uncontended = true;</span><br><span class=\"line\">        // 条件1：cells为空，说明正在出现竞争，上面是从条件2过来的</span><br><span class=\"line\">        // 条件2：应该不会出现</span><br><span class=\"line\">        // 条件3：当前线程所在的Cell为空，说明当前线程还没有更新过Cell，应初始化一个Cell</span><br><span class=\"line\">        // 条件4：更新当前线程所在的Cell失败，说明现在竞争很激烈，多个线程hash到了同一个Cell，应扩容</span><br><span class=\"line\">        if (as == null || (m = as.length - 1) &lt; 0 ||</span><br><span class=\"line\">            // getProbe()方法返回的是线程中的threadLocalRandomProbe字段</span><br><span class=\"line\">            // 它是通过随机数生成的一个值，对于一个确定的线程这个值是固定的</span><br><span class=\"line\">            // 除非刻意修改它</span><br><span class=\"line\">            (a = as[getProbe() &amp;amp; m]) == null ||</span><br><span class=\"line\">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class=\"line\">            // 调用Striped64中的方法处理</span><br><span class=\"line\">            longAccumulate(x, null, uncontended);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>（1）最初无竞争时只更新base；</p>\n<p>（2）直到更新base失败时，创建cells数组；</p>\n<p>（3）当多个线程竞争同一个Cell比较激烈时，可能要扩容；</p>\n<h2 id=\"longAccumulate-方法\"><a href=\"#longAccumulate-方法\" class=\"headerlink\" title=\"longAccumulate()方法\"></a>longAccumulate()方法</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final void longAccumulate(long x, LongBinaryOperator fn,</span><br><span class=\"line\">                              boolean wasUncontended) &#123;</span><br><span class=\"line\">    // 存储线程的probe值</span><br><span class=\"line\">    int h;</span><br><span class=\"line\">    // 如果getProbe()方法返回0，说明随机数未初始化</span><br><span class=\"line\">    if ((h = getProbe()) == 0) &#123;</span><br><span class=\"line\">        // 强制初始化</span><br><span class=\"line\">        ThreadLocalRandom.current(); // force initialization</span><br><span class=\"line\">        // 重新获取probe值</span><br><span class=\"line\">        h = getProbe();</span><br><span class=\"line\">        // 都未初始化，肯定还不存在竞争激烈</span><br><span class=\"line\">        wasUncontended = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 是否发生碰撞</span><br><span class=\"line\">    boolean collide = false;                // True if last slot nonempty</span><br><span class=\"line\">    for (;;) &#123;</span><br><span class=\"line\">        Cell[] as; Cell a; int n; long v;</span><br><span class=\"line\">        // cells已经初始化过</span><br><span class=\"line\">        if ((as = cells) != null &amp;amp;&amp;amp; (n = as.length) &gt; 0) &#123;</span><br><span class=\"line\">            // 当前线程所在的Cell未初始化</span><br><span class=\"line\">            if ((a = as[(n - 1) &amp;amp; h]) == null) &#123;</span><br><span class=\"line\">                // 当前无其它线程在创建或扩容cells，也没有线程在创建Cell</span><br><span class=\"line\">                if (cellsBusy == 0) &#123;       // Try to attach new Cell</span><br><span class=\"line\">                    // 新建一个Cell，值为当前需要增加的值</span><br><span class=\"line\">                    Cell r = new Cell(x);   // Optimistically create</span><br><span class=\"line\">                    // 再次检测cellsBusy，并尝试更新它为1</span><br><span class=\"line\">                    // 相当于当前线程加锁</span><br><span class=\"line\">                    if (cellsBusy == 0 &amp;amp;&amp;amp; casCellsBusy()) &#123;</span><br><span class=\"line\">                        // 是否创建成功</span><br><span class=\"line\">                        boolean created = false;</span><br><span class=\"line\">                        try &#123;               // Recheck under lock</span><br><span class=\"line\">                            Cell[] rs; int m, j;</span><br><span class=\"line\">                            // 重新获取cells，并找到当前线程hash到cells数组中的位置</span><br><span class=\"line\">                            // 这里一定要重新获取cells，因为as并不在锁定范围内</span><br><span class=\"line\">                            // 有可能已经扩容了，这里要重新获取</span><br><span class=\"line\">                            if ((rs = cells) != null &amp;amp;&amp;amp;</span><br><span class=\"line\">                                (m = rs.length) &gt; 0 &amp;amp;&amp;amp;</span><br><span class=\"line\">                                rs[j = (m - 1) &amp;amp; h] == null) &#123;</span><br><span class=\"line\">                                // 把上面新建的Cell放在cells的j位置处</span><br><span class=\"line\">                                rs[j] = r;</span><br><span class=\"line\">                                // 创建成功</span><br><span class=\"line\">                                created = true;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125; finally &#123;</span><br><span class=\"line\">                            // 相当于释放锁</span><br><span class=\"line\">                            cellsBusy = 0;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        // 创建成功了就返回</span><br><span class=\"line\">                        // 值已经放在新建的Cell里面了</span><br><span class=\"line\">                        if (created)</span><br><span class=\"line\">                            break;</span><br><span class=\"line\">                        continue;           // Slot is now non-empty</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                // 标记当前未出现冲突</span><br><span class=\"line\">                collide = false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 当前线程所在的Cell不为空，且更新失败了</span><br><span class=\"line\">            // 这里简单地设为true，相当于简单地自旋一次</span><br><span class=\"line\">            // 通过下面的语句修改线程的probe再重新尝试</span><br><span class=\"line\">            else if (!wasUncontended)       // CAS already known to fail</span><br><span class=\"line\">                wasUncontended = true;      // Continue after rehash</span><br><span class=\"line\">            // 再次尝试CAS更新当前线程所在Cell的值，如果成功了就返回</span><br><span class=\"line\">            else if (a.cas(v = a.value, ((fn == null) ? v + x :</span><br><span class=\"line\">                                         fn.applyAsLong(v, x))))</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            // 如果cells数组的长度达到了CPU核心数，或者cells扩容了</span><br><span class=\"line\">            // 设置collide为false并通过下面的语句修改线程的probe再重新尝试</span><br><span class=\"line\">            else if (n &gt;= NCPU || cells != as)</span><br><span class=\"line\">                collide = false;            // At max size or stale</span><br><span class=\"line\">            // 上上个elseif都更新失败了，且上个条件不成立，说明出现冲突了</span><br><span class=\"line\">            else if (!collide)</span><br><span class=\"line\">                collide = true;</span><br><span class=\"line\">            // 明确出现冲突了，尝试占有锁，并扩容</span><br><span class=\"line\">            else if (cellsBusy == 0 &amp;amp;&amp;amp; casCellsBusy()) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    // 检查是否有其它线程已经扩容过了</span><br><span class=\"line\">                    if (cells == as) &#123;      // Expand table unless stale</span><br><span class=\"line\">                        // 新数组为原数组的两倍</span><br><span class=\"line\">                        Cell[] rs = new Cell[n &lt;&lt; 1];</span><br><span class=\"line\">                        // 把旧数组元素拷贝到新数组中</span><br><span class=\"line\">                        for (int i = 0; i &lt; n; ++i)</span><br><span class=\"line\">                            rs[i] = as[i];</span><br><span class=\"line\">                        // 重新赋值cells为新数组</span><br><span class=\"line\">                        cells = rs;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; finally &#123;</span><br><span class=\"line\">                    // 释放锁</span><br><span class=\"line\">                    cellsBusy = 0;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                // 已解决冲突</span><br><span class=\"line\">                collide = false;</span><br><span class=\"line\">                // 使用扩容后的新数组重新尝试</span><br><span class=\"line\">                continue;                   // Retry with expanded table</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 更新失败或者达到了CPU核心数，重新生成probe，并重试</span><br><span class=\"line\">            h = advanceProbe(h);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 未初始化过cells数组，尝试占有锁并初始化cells数组</span><br><span class=\"line\">        else if (cellsBusy == 0 &amp;amp;&amp;amp; cells == as &amp;amp;&amp;amp; casCellsBusy()) &#123;</span><br><span class=\"line\">            // 是否初始化成功</span><br><span class=\"line\">            boolean init = false;</span><br><span class=\"line\">            try &#123;                           // Initialize table</span><br><span class=\"line\">                // 检测是否有其它线程初始化过</span><br><span class=\"line\">                if (cells == as) &#123;</span><br><span class=\"line\">                    // 新建一个大小为2的Cell数组</span><br><span class=\"line\">                    Cell[] rs = new Cell[2];</span><br><span class=\"line\">                    // 找到当前线程hash到数组中的位置并创建其对应的Cell</span><br><span class=\"line\">                    rs[h &amp;amp; 1] = new Cell(x);</span><br><span class=\"line\">                    // 赋值给cells数组</span><br><span class=\"line\">                    cells = rs;</span><br><span class=\"line\">                    // 初始化成功</span><br><span class=\"line\">                    init = true;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; finally &#123;</span><br><span class=\"line\">                // 释放锁</span><br><span class=\"line\">                cellsBusy = 0;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 初始化成功直接返回</span><br><span class=\"line\">            // 因为增加的值已经同时创建到Cell中了</span><br><span class=\"line\">            if (init)</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 如果有其它线程在初始化cells数组中，就尝试更新base</span><br><span class=\"line\">        // 如果成功了就返回</span><br><span class=\"line\">        else if (casBase(v = base, ((fn == null) ? v + x :</span><br><span class=\"line\">                                    fn.applyAsLong(v, x))))</span><br><span class=\"line\">            break;                          // Fall back on using base</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>（1）如果cells数组未初始化，当前线程会尝试占有cellsBusy锁并创建cells数组；</p>\n<p>（2）如果当前线程尝试创建cells数组时，发现有其它线程已经在创建了，就尝试更新base，如果成功就返回；</p>\n<p>（3）通过线程的probe值找到当前线程应该更新cells数组中的哪个Cell；</p>\n<p>（4）如果当前线程所在的Cell未初始化，就占有占有cellsBusy锁并在相应的位置创建一个Cell；</p>\n<p>（5）尝试CAS更新当前线程所在的Cell，如果成功就返回，如果失败说明出现冲突；</p>\n<p>（5）当前线程更新Cell失败后并不是立即扩容，而是尝试更新probe值后再重试一次；</p>\n<p>（6）如果在重试的时候还是更新失败，就扩容；</p>\n<p>（7）扩容时当前线程占有cellsBusy锁，并把数组容量扩大到两倍，再迁移原cells数组中元素到新数组中；</p>\n<p>（8）cellsBusy在创建cells数组、创建Cell、扩容cells数组三个地方用到；</p>\n<h2 id=\"sum-方法\"><a href=\"#sum-方法\" class=\"headerlink\" title=\"sum()方法\"></a>sum()方法</h2><p>sum()方法是获取LongAdder中真正存储的值的大小，通过把base和所有段相加得到。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public long sum() &#123;</span><br><span class=\"line\">    Cell[] as = cells; Cell a;</span><br><span class=\"line\">    // sum初始等于base</span><br><span class=\"line\">    long sum = base;</span><br><span class=\"line\">    // 如果cells不为空</span><br><span class=\"line\">    if (as != null) &#123;</span><br><span class=\"line\">        // 遍历所有的Cell</span><br><span class=\"line\">        for (int i = 0; i &lt; as.length; ++i) &#123;</span><br><span class=\"line\">            // 如果所在的Cell不为空，就把它的value累加到sum中</span><br><span class=\"line\">            if ((a = as[i]) != null)</span><br><span class=\"line\">                sum += a.value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 返回sum</span><br><span class=\"line\">    return sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>可以看到sum()方法是把base和所有段的值相加得到，那么，这里有一个问题，如果前面已经累加到sum上的Cell的value有修改，不是就没法计算到了么？</p>\n<p>答案确实如此，所以LongAdder可以说不是强一致性的，它是最终一致性的。</p>\n<h2 id=\"LongAdder-VS-AtomicLong\"><a href=\"#LongAdder-VS-AtomicLong\" class=\"headerlink\" title=\"LongAdder VS AtomicLong\"></a>LongAdder VS AtomicLong</h2><p>直接上代码：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class LongAdderVSAtomicLongTest &#123;</span><br><span class=\"line\">    public static void main(String[] args)&#123;</span><br><span class=\"line\">        testAtomicLongVSLongAdder(1, 10000000);</span><br><span class=\"line\">        testAtomicLongVSLongAdder(10, 10000000);</span><br><span class=\"line\">        testAtomicLongVSLongAdder(20, 10000000);</span><br><span class=\"line\">        testAtomicLongVSLongAdder(40, 10000000);</span><br><span class=\"line\">        testAtomicLongVSLongAdder(80, 10000000);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static void testAtomicLongVSLongAdder(final int threadCount, final int times)&#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            System.out.println(&quot;threadCount：&quot; + threadCount + &quot;, times：&quot; + times);</span><br><span class=\"line\">            long start = System.currentTimeMillis();</span><br><span class=\"line\">            testLongAdder(threadCount, times);</span><br><span class=\"line\">            System.out.println(&quot;LongAdder elapse：&quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">            long start2 = System.currentTimeMillis();</span><br><span class=\"line\">            testAtomicLong(threadCount, times);</span><br><span class=\"line\">            System.out.println(&quot;AtomicLong elapse：&quot; + (System.currentTimeMillis() - start2) + &quot;ms&quot;);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static void testAtomicLong(final int threadCount, final int times) throws InterruptedException &#123;</span><br><span class=\"line\">        AtomicLong atomicLong = new AtomicLong();</span><br><span class=\"line\">        List&lt;Thread&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (int i=0;i&lt;threadCount;i++)&#123;</span><br><span class=\"line\">            list.add(new Thread(() -&gt; &#123;</span><br><span class=\"line\">                for (int j = 0; j&lt;times; j++)&#123;</span><br><span class=\"line\">                    atomicLong.incrementAndGet();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (Thread thread : list)&#123;</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (Thread thread : list)&#123;</span><br><span class=\"line\">            thread.join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static void testLongAdder(final int threadCount, final int times) throws InterruptedException &#123;</span><br><span class=\"line\">        LongAdder longAdder = new LongAdder();</span><br><span class=\"line\">        List&lt;Thread&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (int i=0;i&lt;threadCount;i++)&#123;</span><br><span class=\"line\">            list.add(new Thread(() -&gt; &#123;</span><br><span class=\"line\">                for (int j = 0; j&lt;times; j++)&#123;</span><br><span class=\"line\">                    longAdder.add(1);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (Thread thread : list)&#123;</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (Thread thread : list)&#123;</span><br><span class=\"line\">            thread.join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>运行结果如下：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">threadCount：1, times：10000000</span><br><span class=\"line\">LongAdder elapse：158ms</span><br><span class=\"line\">AtomicLong elapse：64ms</span><br><span class=\"line\">threadCount：10, times：10000000</span><br><span class=\"line\">LongAdder elapse：206ms</span><br><span class=\"line\">AtomicLong elapse：2449ms</span><br><span class=\"line\">threadCount：20, times：10000000</span><br><span class=\"line\">LongAdder elapse：429ms</span><br><span class=\"line\">AtomicLong elapse：5142ms</span><br><span class=\"line\">threadCount：40, times：10000000</span><br><span class=\"line\">LongAdder elapse：840ms</span><br><span class=\"line\">AtomicLong elapse：10506ms</span><br><span class=\"line\">threadCount：80, times：10000000</span><br><span class=\"line\">LongAdder elapse：1369ms</span><br><span class=\"line\">AtomicLong elapse：20482ms</span><br></pre></td></tr></table></figure></div>\n\n<p>可以看到当只有一个线程的时候，AtomicLong反而性能更高，随着线程越来越多，AtomicLong的性能急剧下降，而LongAdder的性能影响很小。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>（1）LongAdder通过base和cells数组来存储值；</p>\n<p>（2）不同的线程会hash到不同的cell上去更新，减少了竞争；</p>\n<p>（3）LongAdder的性能非常高，最终会达到一种无竞争的状态；</p>\n<h2 id=\"彩蛋\"><a href=\"#彩蛋\" class=\"headerlink\" title=\"彩蛋\"></a>彩蛋</h2><p>在longAccumulate()方法中有个条件是<code>n &gt;= NCPU</code>就不会走到扩容逻辑了，而n是2的倍数，那是不是代表cells数组最大只能达到大于等于NCPU的最小2次方？</p>\n<p>答案是明确的。因为同一个CPU核心同时只会运行一个线程，而更新失败了说明有两个不同的核心更新了同一个Cell，这时会重新设置更新失败的那个线程的probe值，这样下一次它所在的Cell很大概率会发生改变，如果运行的时间足够长，最终会出现同一个核心的所有线程都会hash到同一个Cell（大概率，但不一定全在一个Cell上）上去更新，所以，这里cells数组中长度并不需要太长，达到CPU核心数足够了。</p>\n<p>比如，笔者的电脑是8核的，所以这里cells的数组最大只会到8，达到8就不会扩容了。</p>\n<p><img src=\"https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/LongAdder2.png\" alt=\"LongAdder\"></p>\n<hr>\n<p>欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。</p>\n<p><img src=\"https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode_ss.jpg\" alt=\"qrcode\"></p>\n","categories":[],"tags":[{"name":"Java","slug":"Java","count":26,"path":"api/tags/Java.json"}]}