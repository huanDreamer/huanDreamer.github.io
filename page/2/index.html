<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>HUAN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="HUAN">
<meta property="og:url" content="http://sillyfan.top/page/2/index.html">
<meta property="og:site_name" content="HUAN">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HUAN">
  
    <link rel="alternate" href="/atom.xml" title="HUAN" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HUAN</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://sillyfan.top"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/30/hello-world/" class="article-date">
  <time datetime="2019-05-30T00:45:32.658Z" itemprop="datePublished">2019-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/30/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/30/hello-world/" data-id="cjzj9196y000os22at1z1uwu6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-熟练掌握各种MQ？那面试官很可能用这道题目先摸摸你的老底！" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/28/熟练掌握各种MQ？那面试官很可能用这道题目先摸摸你的老底！/" class="article-date">
  <time datetime="2019-05-28T07:38:06.006Z" itemprop="datePublished">2019-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/28/熟练掌握各种MQ？那面试官很可能用这道题目先摸摸你的老底！/">熟练掌握各种MQ？那面试官很可能用这道题目先摸摸你的老底！</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5ceb79fef265da1bb47d4222" target="_blank" rel="noopener">https://juejin.im/post/5ceb79fef265da1bb47d4222</a><br><strong>公众号：狸猫技术窝</strong></p>
</blockquote>
<p><strong>作者：爱钓鱼的桌子哥，资深架构师</strong></p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h3><p>1.有Broker的暴力路由：<strong>Kafka</strong></p>
<p>2.有Broker的复杂路由：<strong>RabbitMQ</strong></p>
<p>3.无Broker的通信流派：<strong>ZeroMQ</strong></p>
<p>4.总结</p>
<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a><strong>写在前面</strong></h3><p>我们知道，目前市面上的MQ包括Kafka、RabbitMQ、ZeroMQ、RocketMQ等等。</p>
<p>那么他们之间究竟有什么本质区别，分别适用于什么场景呢？</p>
<p>上述抛出的问题，同样在不少公司的Java工程师面试中出现，特别是当你简历上的技术栈包含了这些技术，面试官往往喜欢用这个问题，对你进行摸底考察。</p>
<p>本文我们就一起来探讨一下。</p>
<h3 id="（1）有Broker的暴力路由"><a href="#（1）有Broker的暴力路由" class="headerlink" title="（1）有Broker的暴力路由"></a><strong>（1）有Broker的暴力路由</strong></h3><p>这个流派最典型的就是<strong>Kafka</strong>，Kafka实际上为了提升性能，简化了MQ功能模型，仅仅提供了一些最基础的MQ相关的功能，但是大幅度优化和提升了吞吐量。</p>
<p>首先，这个流派一定是有一个Broker角色的，也就是说，Kafka需要部署一套服务器集群，每台机器上都有一个Kafka Broker进程，这个进程就负责接收请求，存储数据，发送数据。</p>
<p>Kafka的生产消费模型做的相对是比较暴力简单的，就是简单的数据流模型。</p>
<p>简单来说，他有一个概念，叫做“<strong>Topic</strong>”，你可以往这个“Topic”里写数据，然后让别人从这里来消费。</p>
<p>这个Topic可以划分为多个Partition，每个Partition放一台机器上，存储一部分数据。</p>
<p>在写消息到Topic的时候，会自动把你这个消息给分发到某一个Partition上去。</p>
<p>然后消费消息的时候，有一个<strong>Consumer Group</strong>的概念，你部署在多台机器上的Consumer可以组成一个Group，一个Partition只能给一个Consumer消费，一个Cosumer可以消费多个Partition，这是最最核心的一点。</p>
<p>通过这个模型，保证一个Topic里的每条消息，只会交给Consumer Group里的一个Consumer来消费，形成了一个Queue（队列）的效果。</p>
<p>假如你想要有一个Queue的效果，也就是希望不停的往Queue里写数据，然后多个消费者消费，每条消息就只能给一个消费者，那么通过Kafka来实现，其实就是生产者写多个Partition，每个Partition只能给Consumer Group中的一个Consumer来消费。如下图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/27/16af7d5d9e1690c5?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>如果要实现Publish/Subscribe的模型呢？就是说生产者发送的每条消息，都要让所有消费都消费到，怎么实现？</p>
<p>那就让每个消费者都是一个独立的消费组，这样每条消息都会发送给所有的消费组，每个消费组里那唯一的一个消费者一定会消费到所有的消息。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/27/16af7d5d918ca40f?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>但是除此之外，Kafka就没有任何其他的消费功能了，就是如此简单，所以属于一种比较暴力直接的流派。</p>
<p>它就是简单的消费模型，实现最基础的Queue和Pub/Sub两种消费模型，但是内核中大幅度优化和提升了性能以及吞吐量。</p>
<p>所以Kafka天生适合的场景，就是大数据领域的实时数据计算的场景。</p>
<p>因为在大数据的场景下，通常是弱业务的场景，没有太多复杂的业务系统交互，而主要是大量的数据流入Kafka，然后进行实时计算。</p>
<p>所以就是需要简单的消费模型，但是必须在内核中对吞吐量和性能进行大幅度的优化。</p>
<p>因此Kafka技术通常是在大数据的实时数据计算领域中使用的，比如说每秒处理几十万条消息，甚至每秒处理上百万条消息。</p>
<h3 id="（2）有Broker的复杂路由"><a href="#（2）有Broker的复杂路由" class="headerlink" title="（2）有Broker的复杂路由"></a>（2）有Broker的复杂路由</h3><p>第二个流派，就是<strong>RabbitMQ</strong>为代表的流派，他强调的不是说如何提升性能和吞吐量，关注的是说要提供非常强大、复杂而且完善的消息路由功能。</p>
<p>所以对于RabbitMQ而言，他就不是那么简单的Topic-Partition的消费模型了。</p>
<p>在RabbitMQ中引入了一个非常核心的概念，叫做<strong>Exchange</strong>，这个Exchange就是负责根据复杂的业务规则把消息路由到内部的不同的Queue里去。</p>
<p>举个例子，如果要实现最简单的队列功能，就是让exchange往一个queue里写数据，然后多个消费者来消费这个queue里的数据，每条消息只能给一个消费者，那么可以是类似下面的方式。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/27/16af7d5d91903b11?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>如果想要实现Pub/Sub的模型，就是一条消息要被所有的消费者给消费到，那么就可以让每个消费者都有一个自己的Queue，然后绑定到一个Exchange上去。</p>
<p>接着，这个Exchange就设定把消息路由给所有的Queue即可，如下面这样。</p>
<p>此时Exchange可以把每条消息都路由给所有的Queue，每个Consumer都可以从自己的Queue里拿到所有的消息。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/27/16af7d5d91efcb5b?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>RabbitMQ这种流派，其实最核心的是，基于Exchange这个概念，他可以做很多复杂的事情。</p>
<p>比如：如果你想要某个Consumer只能消费到<strong>某一类数据</strong>，那么Exchange可以把消息里比如带“XXX”前缀的消息路由给某个Queue。或者你可以限定某个Consumer就只能消费<strong>某一部分数据</strong>。总之在这里你可以做很多的限制，设置复杂的路由规则。</p>
<p>但是也正是因为引入了这种复杂的消费模型，支持复杂的路由功能，导致RabbitMQ在内核以及架构设计上没法像Kafka做的那么的轻量级、高性能、可扩展、高吞吐，所以RabbitMQ在吞吐量上要比Kafka低一个数量级。</p>
<p>所以这种流派的MQ，往往适合用在Java业务系统中，不同的业务系统需要进行复杂的消息路由。</p>
<p>比如说业务系统A发送了10条消息，其中3条消息是给业务系统B的，7条消息是给业务系统C的，要实现这种复杂的路由模型，就必须依靠RabbitMQ来实现。</p>
<p>当然，对于这种业务系统之间的消息流转而言，可能不需要那么高的吞吐量，可能每秒业务系统之间也就转发几十条或者几百条消息，那么就完全适合采用RabbitMQ来实现。</p>
<h3 id="（3）无Broker的通信流派"><a href="#（3）无Broker的通信流派" class="headerlink" title="（3）无Broker的通信流派"></a>（3）无Broker的通信流派</h3><p><strong>ZeroMQ</strong>代表的是第三种MQ。说白了，他是不需要在服务器上部署的，就是一个客户端的库而已。</p>
<p>也就是说，他主要是封装了底层的Socket网络通讯，然后一个系统要发送一条消息给另外一个消息消费 。</p>
<p>通过ZeroMQ，本质就是底层ZeroMQ发送一条消息到另外一个系统上去。</p>
<p>所以ZeroMQ是<strong>去中心化</strong>的，不需要跟Kafka、RabbitMQ一样在服务器上部署的。</p>
<p>他主要是用来进行业务系统之间的网络通信的，有点类似于比如你是一个分布式系统架构，那么此时分布式架构中的各个子系统互相之间要通信，你是基于Dubbo RPC？还是Spring Cloud HTTP？</p>
<p>可能上述两种你都不想要，就是要基于原始的Socket进行网络通信，简单的收发消息而已。</p>
<p>此时就可以使用ZeroMQ作为分布式系统之间的消息通信，如下面那样。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/27/16af7d5d91f778d7?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<h3 id="（4）总结"><a href="#（4）总结" class="headerlink" title="（4）总结"></a>（4）总结</h3><p>其实现在基本上MQ主要就是这三个流派，很多小众的MQ一般很少有人会用。</p>
<p>而且用MQ的场景主要就是两大类：</p>
<pre><code>1. </code></pre><p><strong>业务系统之间异步通信</strong><br>    1.<br><strong>大数据领域的实时数据计算</strong></p>
<p>所以一般业务系统之间通信就是会采用RabbitMQ/RocketMQ，需要复杂的消息路由功能的支撑。</p>
<p>大数据的实时计算场景会采用Kafka，需要简单的消费模型，但是超高的吞吐量。</p>
<p>至于ZeroMQ，一般来说，少数分布式系统中子系统之间的分布式通信时会采用，作为轻量级的异步化的通信组件。</p>
<p><strong>END</strong></p>
<p><strong>作者简介：</strong></p>
<p><strong>爱钓鱼的桌子哥，资深架构师</strong></p>
<p>作者先后工作于滴滴、百度、字节跳动等国内一线互联网大厂，从事基础架构相关工作。带领团队设计与构建了大规模的分布式存储系统、分布式消息中间件、分布式数据库，对分布式架构设计、系统高可用体系构建、基础中间件架构都有丰富的经验。</p>
<p><strong>END</strong></p>
<p>长按下图二维码，即刻关注【狸猫技术窝】 阿里、京东、美团、字节跳动 顶尖技术专家坐镇 为IT人打造一个 “有温度” 的技术窝！</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/23/16a4aea4c6855bb5?imageView2/0/w/1280/h/960/ignore-error/1" alt><br>作者：狸猫技术窝<br>链接：<a href="https://juejin.im/post/5ce1975af265da1bd42450b5" target="_blank" rel="noopener">https://juejin.im/post/5ce1975af265da1bd42450b5</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/28/熟练掌握各种MQ？那面试官很可能用这道题目先摸摸你的老底！/" data-id="cjzj9197y0024s22aq22270bc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-从模板方法模式到JDBCTemplate" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/22/从模板方法模式到JDBCTemplate/" class="article-date">
  <time datetime="2019-05-22T14:33:24.024Z" itemprop="datePublished">2019-05-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/22/从模板方法模式到JDBCTemplate/">从模板方法模式到JDBCTemplate</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5cdb7f4af265da037371aa1f" target="_blank" rel="noopener">https://juejin.im/post/5cdb7f4af265da037371aa1f</a><br>将大象装进冰箱需要三步，那么老虎了？如何优雅的将大象装进冰箱？</p>
</blockquote>
<h3 id="把大象装进冰箱"><a href="#把大象装进冰箱" class="headerlink" title="把大象装进冰箱"></a>把大象装进冰箱</h3><table>
<thead>
<tr>
<th align="center">Step</th>
<th align="center">大象</th>
<th align="center">老虎</th>
<th align="center">…</th>
</tr>
</thead>
<tbody><tr>
<td align="center">First</td>
<td align="center">打开冰箱门</td>
<td align="center">打开冰箱门</td>
<td align="center">打开冰箱门</td>
</tr>
<tr>
<td align="center">Second</td>
<td align="center">把大象放进去</td>
<td align="center">把老虎放进去</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">Third</td>
<td align="center">关闭冰箱门</td>
<td align="center">关闭冰箱门</td>
<td align="center">关闭冰箱门</td>
</tr>
</tbody></table>
<p><strong><em>大象类</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Elephant &#123;</span><br><span class="line">        public void putRefrigerator() &#123;</span><br><span class="line">            openDoor();</span><br><span class="line">            putElephant();</span><br><span class="line">            closeDoor();</span><br><span class="line">        &#125;</span><br><span class="line">        public void openDoor() &#123;</span><br><span class="line">            System.out.println(&quot;open the door&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public void putElephant() &#123;</span><br><span class="line">            System.out.println(&quot;put in the Elephant&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public void closeDoor() &#123;</span><br><span class="line">            System.out.println(&quot;close the door&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>老虎类</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Tiger &#123;</span><br><span class="line">        public void putRefrigerator() &#123;</span><br><span class="line">            openDoor();</span><br><span class="line">            putTiger();</span><br><span class="line">            closeDoor();</span><br><span class="line">        &#125;</span><br><span class="line">        public void openDoor() &#123;</span><br><span class="line">            System.out.println(&quot;open the door&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public void putTiger() &#123;</span><br><span class="line">            System.out.println(&quot;put in the Tiger&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public void closeDoor() &#123;</span><br><span class="line">            System.out.println(&quot;close the door&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出我们将大象和老虎放进冰箱的过程中出现了大量的重复代码，这显然不是一个好的设计，如果我们在以后的系统升级过程中需要再放入长颈鹿怎么办，我们应该如何从我们的设计中删除这些重复代码？通过观察我们发现放大象和放老虎之间有很多共同点，都需要进行开关门的操作，只是放的过程不尽相同，我们是否可以将共同点抽离？我们一起试试看</p>
<p><strong><em>抽象超类</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractPutAnyAnimal &#123;</span><br><span class="line">        //这是一个模板方法，它是一个算法的模板，描述我们将动物放进冰箱的步骤，每一个方法代表了一个步骤</span><br><span class="line">        public void putRefrigerator() &#123;</span><br><span class="line">            openDoor();</span><br><span class="line">            putAnyAnimal();</span><br><span class="line">            closeDoor();</span><br><span class="line">        &#125;</span><br><span class="line">        //在超类中实现共同的方法，由超类来处理</span><br><span class="line">        public void openDoor() &#123;</span><br><span class="line">            System.out.println(&quot;open the door&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public void closeDoor() &#123;</span><br><span class="line">            System.out.println(&quot;close the door&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //每个子类可能有不同的方法,我们定义成抽象方法让子类去实现</span><br><span class="line">        abstract void putAnyAnimal();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>大象类</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Elephant extends AbstractPutAnyAnimal &#123;</span><br><span class="line">        //子类实现自己的业务逻辑</span><br><span class="line">        @Override</span><br><span class="line">        void putAnyAnimal() &#123;</span><br><span class="line">            System.out.println(&quot;put in the Elephant&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>老虎类</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Tiger extends AbstractPutAnyAnimal &#123;</span><br><span class="line">        //子类实现自己的业务逻辑</span><br><span class="line">        @Override</span><br><span class="line">        void putAnyAnimal() &#123;</span><br><span class="line">            System.out.println(&quot;put in the Tiger&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过将相同的方法抽离到超类中，并定义一个抽象方法供子类提供不同的实现，事实上我们刚刚实现了一个模板方法模式。</p>
<h3 id="模板方法模式定义？"><a href="#模板方法模式定义？" class="headerlink" title="模板方法模式定义？"></a>模板方法模式定义？</h3><p><strong>模板方法模式定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现</strong>，putRefrigerator 方法定义了我们将大象装进冰箱的步骤它就是一个模板方法。<strong>模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不在改变算法结构的情况下，重新定义算法的某些步骤</strong>（子类提供自己的实现）</p>
<h3 id="模板方法模式中的钩子"><a href="#模板方法模式中的钩子" class="headerlink" title="模板方法模式中的钩子"></a>模板方法模式中的钩子</h3><p>我们可以在超类中定义一个空方法，我们称这种方法为钩子（hook）。子类可以依据情况选择覆盖，钩子的存在可以让子类有能力对算法的不同点进行挂载；<strong>钩子可以让子类实现算法中的可选部分，钩子也可以让子类为抽象类做一些决定</strong>我们将大象装进冰箱后可能会想调整冰箱温度，也可能什么都不做使用默认温度，我们可以通过定义一个钩子，让子类来选择是否调整温度，如下：</p>
<p><strong><em>抽象父类</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractPutAnyAnimal &#123;</span><br><span class="line">        public void putRefrigerator() &#123;</span><br><span class="line">            openDoor();</span><br><span class="line">            putAnyAnimal();</span><br><span class="line">            closeDoor();</span><br><span class="line">            //默认为false,重新这个方法决定是否执行addTemperature();方法</span><br><span class="line">            if (isAdd()) &#123;</span><br><span class="line">                addTemperature();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public void openDoor() &#123;</span><br><span class="line">            System.out.println(&quot;open the door&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public void closeDoor() &#123;</span><br><span class="line">            System.out.println(&quot;close the door&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        abstract void putAnyAnimal();</span><br><span class="line">        void addTemperature()&#123;</span><br><span class="line">            System.out.println(&quot;plus one&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        //定义一个空实现，由子类决定是否对其进行实现</span><br><span class="line">        boolean isAdd()&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>大象类</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Elephant extends AbstractPutAnyAnimal &#123;</span><br><span class="line">        @Override</span><br><span class="line">        void putAnyAnimal() &#123;</span><br><span class="line">            System.out.println(&quot;put in the Elephant&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //子类实现钩子方法</span><br><span class="line">        @Override</span><br><span class="line">        boolean isAdd() &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们通过定义一个钩子方法，子类选择是否实现这个钩子方法，来决定是否调整温度；当然钩子方法的用途不止如此，<strong>它还能让子类有机会对模板中即将发生或刚刚发生的步骤做出反应</strong>，这在JDK中有很多的例子，甚至在前端开发领域也有很多例子，我就不具体展开代码演示了，后面在模板方法模式的更多应用中展开。</p>
<p>JDK以及Spring中使用了很多的设计模式，下面我们通过比较传统JDBC编程和JDBCTemplate来看看模板方法模式是如何帮我们消除样板代码的</p>
<h3 id="传统JDBC编程"><a href="#传统JDBC编程" class="headerlink" title="传统JDBC编程"></a>传统JDBC编程</h3><p><strong><em>JDBC编程之新增</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">String driver = &quot;com.mysql.jdbc.Driver&quot;;</span><br><span class="line">        String url = &quot;jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8&amp;amp;useSSL=true&quot;;</span><br><span class="line">        String username = &quot;root&quot;;</span><br><span class="line">        String password = &quot;1234&quot;;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        Statement statement = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(driver);</span><br><span class="line">            connection = DriverManager.getConnection(url, username, password);</span><br><span class="line">            String sql = &quot;insert into users(nickname,comment,age) values(&apos;小小谭&apos;,&apos;I love three thousand times&apos;, &apos;21&apos;)&quot;;</span><br><span class="line">            statement = connection.createStatement();</span><br><span class="line">            int i = statement.executeUpdate(sql);</span><br><span class="line">            return i;</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (null != statement) &#123;</span><br><span class="line">                    statement.close();</span><br><span class="line">                &#125;</span><br><span class="line">                if (null != connection) &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br></pre></td></tr></table></figure>

<p><strong><em>JDBC编程之查询</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">String driver = &quot;com.mysql.jdbc.Driver&quot;;</span><br><span class="line">        String url = &quot;jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8&amp;amp;useSSL=true&quot;;</span><br><span class="line">        String username = &quot;root&quot;;</span><br><span class="line">        String password = &quot;1234&quot;;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        Statement statement = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            Class.forName(driver);</span><br><span class="line">            connection = DriverManager.getConnection(url, username, password);</span><br><span class="line">            String sql = &quot;select nickname,comment,age from users&quot;;</span><br><span class="line">            statement = connection.createStatement();</span><br><span class="line">            ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line">            List&lt;Users&gt; usersList = new ArrayList&lt;&gt;();</span><br><span class="line">            while (resultSet.next()) &#123;</span><br><span class="line">                Users users = new Users();</span><br><span class="line">                users.setNickname(resultSet.getString(1));</span><br><span class="line">                users.setComment(resultSet.getString(2));</span><br><span class="line">                users.setAge(resultSet.getInt(3));</span><br><span class="line">                usersList.add(users);</span><br><span class="line">            &#125;</span><br><span class="line">            return usersList;</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (null != statement) &#123;</span><br><span class="line">                    statement.close();</span><br><span class="line">                &#125;</span><br><span class="line">                if (null != connection) &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br></pre></td></tr></table></figure>

<p>上面给出了我们在传统JDBC编程中的两个案例，可以看到传统JDBC的很多缺点，当然在实际项目中我们可能不会这么原始的进行数据库开发，可能会对JDBC进行一定的封装，方便我们的使用。Spring 官方为了简化JDBC的开发也发布了JDBCTemplate，下面我们就看一下它是如何简化开发的，以及模板方法模式在其中的应用</p>
<h3 id="JDBCTemplate是个啥，它到底简化了什么？"><a href="#JDBCTemplate是个啥，它到底简化了什么？" class="headerlink" title="JDBCTemplate是个啥，它到底简化了什么？"></a>JDBCTemplate是个啥，它到底简化了什么？</h3><p>从JDBCTemplate的名字我们就不难看出，它简化了我们JDBC的开发，而且很可能大量应用了模板方法模式，它到底为我们提供了什么？<strong>它提供了与平台无光的异常处理机制</strong>。使用过原生JDBC开发的同学可能有经历，几乎所有的操作代码都需要我们强制捕获异常，但是在出现异常时我们往往无法通过异常读懂错误。Spring解决了我们的问题它<strong>提供了多个数据访问异常，并且分别描述了他们抛出时对应的问题，同时对异常进行了包装不强制要求我们进行捕获，同时它为我们提供了数据访问的模板化</strong>，从上面的传统JDBC编程我们可以发现，很多操作其实是重复的不变得比如事务控制、资源的获取关闭以及异常处理等，同时结果集的处理实体的绑定，参数的绑定这些东西都是特有的。因此<strong>Spring将数据访问过程中固定部分和可变部分划分为了两个不同的类(Template)和回调(Callback),模板处理过程中不变得部分，回调处理自定义的访问代码</strong>；下面我们具体通过源码来学学习一下</p>
<h3 id="模板方法模式在JDBCTemplate中的应用"><a href="#模板方法模式在JDBCTemplate中的应用" class="headerlink" title="模板方法模式在JDBCTemplate中的应用"></a>模板方法模式在JDBCTemplate中的应用</h3><p>我所使用的版本是5.1.5.RELEASE</p>
<p>打开JdbcTemplate类(我这里就不截图了，截图可能不清晰我直接将代码copy出来)：</p>
<p><strong><em>JdbcTemplate</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcTemplate extends JdbcAccessor implements JdbcOperations &#123;</span><br><span class="line">        //查询前缀</span><br><span class="line">        private static final String RETURN_RESULT_SET_PREFIX = &quot;#result-set-&quot;;</span><br><span class="line">        //计数前缀</span><br><span class="line">        private static final String RETURN_UPDATE_COUNT_PREFIX = &quot;#update-count-&quot;;</span><br><span class="line">        //是否跳过警告</span><br><span class="line">        private boolean ignoreWarnings = true;</span><br><span class="line">        //查询大小</span><br><span class="line">        private int fetchSize = -1;</span><br><span class="line">        //最大行</span><br><span class="line">        private int maxRows = -1;</span><br><span class="line">        //查询超时</span><br><span class="line">        private int queryTimeout = -1;</span><br><span class="line">        //是否跳过结果集处理</span><br><span class="line">        private boolean skipResultsProcessing = false;</span><br><span class="line">        //是否跳过非公共结果集处理</span><br><span class="line">        private boolean skipUndeclaredResults = false;</span><br><span class="line">        //map结果集是否大小写敏感</span><br><span class="line">        private boolean resultsMapCaseInsensitive = false;</span><br><span class="line">    </span><br><span class="line">        public JdbcTemplate() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        //调用父类方法设置数据源和其他参数</span><br><span class="line">        public JdbcTemplate(DataSource dataSource) &#123;</span><br><span class="line">            this.setDataSource(dataSource);</span><br><span class="line">            this.afterPropertiesSet();</span><br><span class="line">        &#125;</span><br><span class="line">        //调用父类方法设置数据源，懒加载策略和其他参数</span><br><span class="line">        public JdbcTemplate(DataSource dataSource, boolean lazyInit) &#123;</span><br><span class="line">            this.setDataSource(dataSource);</span><br><span class="line">            this.setLazyInit(lazyInit);</span><br><span class="line">            this.afterPropertiesSet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>JdbcTemplate 继承了JdbcAccessor实现了JdbcOperations，JdbcAccessor主要封装了数据源的操作，JdbcOperations主要定义了一些操作接口。我们一起看一下JdbcOperations类；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public abstract class JdbcAccessor implements InitializingBean &#123;</span><br><span class="line">        protected final Log logger = LogFactory.getLog(this.getClass());</span><br><span class="line">        //数据源</span><br><span class="line">        @Nullable</span><br><span class="line">        private DataSource dataSource;</span><br><span class="line">        //异常翻译</span><br><span class="line">        @Nullable</span><br><span class="line">        private volatile SQLExceptionTranslator exceptionTranslator;</span><br><span class="line">        //懒加载策略</span><br><span class="line">        private boolean lazyInit = true;</span><br><span class="line">        public JdbcAccessor() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        public void setDataSource(@Nullable DataSource dataSource) &#123;</span><br><span class="line">            this.dataSource = dataSource;</span><br><span class="line">        &#125;</span><br><span class="line">        @Nullable</span><br><span class="line">        public DataSource getDataSource() &#123;</span><br><span class="line">            return this.dataSource;</span><br><span class="line">        &#125;</span><br><span class="line">        protected DataSource obtainDataSource() &#123;</span><br><span class="line">            DataSource dataSource = this.getDataSource();</span><br><span class="line">            Assert.state(dataSource != null, &quot;No DataSource set&quot;);</span><br><span class="line">            return dataSource;</span><br><span class="line">        &#125;</span><br><span class="line">        public void setDatabaseProductName(String dbName) &#123;</span><br><span class="line">            this.exceptionTranslator = new SQLErrorCodeSQLExceptionTranslator(dbName);</span><br><span class="line">        &#125;</span><br><span class="line">        public void setExceptionTranslator(SQLExceptionTranslator exceptionTranslator) &#123;</span><br><span class="line">            this.exceptionTranslator = exceptionTranslator;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>之所以<strong>前面提到spring让我们更方便的处理异常就是这里他包装了一个SQLExceptionTranslator</strong>，其他的代码都是做数据源的检查之类的设置数据源，我们看一下其中getExceptionTranslator()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public SQLExceptionTranslator getExceptionTranslator() &#123;</span><br><span class="line">        SQLExceptionTranslator exceptionTranslator = this.exceptionTranslator;</span><br><span class="line">        if (exceptionTranslator != null) &#123;</span><br><span class="line">            return exceptionTranslator;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            synchronized(this) &#123;</span><br><span class="line">                SQLExceptionTranslator exceptionTranslator = this.exceptionTranslator;</span><br><span class="line">                if (exceptionTranslator == null) &#123;</span><br><span class="line">                    DataSource dataSource = this.getDataSource();</span><br><span class="line">                    if (dataSource != null) &#123;</span><br><span class="line">                        exceptionTranslator = new SQLErrorCodeSQLExceptionTranslator(dataSource);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        exceptionTranslator = new SQLStateSQLExceptionTranslator();</span><br><span class="line">                    &#125;</span><br><span class="line">                    this.exceptionTranslator = (SQLExceptionTranslator)exceptionTranslator;</span><br><span class="line">                &#125;</span><br><span class="line">                return (SQLExceptionTranslator)exceptionTranslator;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这是一个标准的单例模式，我们在学习模板方法模式的路途中有捕获了一个野生的单例；我们继续看JdbcOperations接口我们调其中一个接口进行解析；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">    &lt;T&gt; T execute(StatementCallback&lt;T&gt; var1) throws DataAccessException;</span><br></pre></td></tr></table></figure>

<p><strong><em>StatementCallback 接口</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">    public interface StatementCallback&lt;T&gt; &#123;</span><br><span class="line">        @Nullable</span><br><span class="line">        T doInStatement(Statement var1) throws SQLException, DataAccessException;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>execute实现</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">    public &lt;T&gt; T execute(StatementCallback&lt;T&gt; action) throws DataAccessException &#123;</span><br><span class="line">        //参数检查</span><br><span class="line">        Assert.notNull(action, &quot;Callback object must not be null&quot;);</span><br><span class="line">        //获取连接</span><br><span class="line">        Connection con = DataSourceUtils.getConnection(this.obtainDataSource());</span><br><span class="line">        Statement stmt = null;</span><br><span class="line">        Object var11;</span><br><span class="line">        try &#123;</span><br><span class="line">            //创建一个Statement</span><br><span class="line">            stmt = con.createStatement();</span><br><span class="line">            //设置查询超时时间，最大行等参数（就是一开始那些成员变量）</span><br><span class="line">            this.applyStatementSettings(stmt);</span><br><span class="line">            //执行回调方法获取结果集</span><br><span class="line">            T result = action.doInStatement(stmt);</span><br><span class="line">            //处理警告</span><br><span class="line">            this.handleWarnings(stmt);</span><br><span class="line">            var11 = result;</span><br><span class="line">        &#125; catch (SQLException var9) &#123;</span><br><span class="line">            //出现错误优雅退出</span><br><span class="line">            String sql = getSql(action);</span><br><span class="line">            JdbcUtils.closeStatement(stmt);</span><br><span class="line">            stmt = null;</span><br><span class="line">            DataSourceUtils.releaseConnection(con, this.getDataSource());</span><br><span class="line">            con = null;</span><br><span class="line">            throw this.translateException(&quot;StatementCallback&quot;, sql, var9);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JdbcUtils.closeStatement(stmt);</span><br><span class="line">            DataSourceUtils.releaseConnection(con, this.getDataSource());</span><br><span class="line">        &#125;</span><br><span class="line">        return var11;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这一个方法可谓是展现的淋漓尽致，这是一个典型的模板方法+回调模式，我们不需要再写过多的重复代码只需要实现自己获取result的方法就好（StatementCallback）事实上我们自己也不需要实现这个方法，继续向上看，我们是如何调用execute方法的，以查询为例,我们看他是如何一步步调用的：</p>
<p><strong><em>查询方法</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Users&gt; findAll() &#123;</span><br><span class="line">        JdbcTemplate jdbcTemplate = DataSourceConfig.getTemplate();</span><br><span class="line">        String sql = &quot;select nickname,comment,age from users&quot;;</span><br><span class="line">        return jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;Users&gt;(Users.class));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>query实现</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper) throws DataAccessException &#123;</span><br><span class="line">        return (List)result(this.query((String)sql, (ResultSetExtractor)(new RowMapperResultSetExtractor(rowMapper))));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的RowMapper是负责将结果集中一行的数据映射成实体返回，用到了反射技术，这里就不展开了，有兴趣的同学可以自己打开源码阅读，继续向下：</p>
<p><strong><em>query实现</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">    public &lt;T&gt; T query(final String sql, final ResultSetExtractor&lt;T&gt; rse) throws DataAccessException &#123;</span><br><span class="line">        Assert.notNull(sql, &quot;SQL must not be null&quot;);</span><br><span class="line">        Assert.notNull(rse, &quot;ResultSetExtractor must not be null&quot;);</span><br><span class="line">        if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">            this.logger.debug(&quot;Executing SQL query [&quot; + sql + &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //实现回调接口</span><br><span class="line">        class QueryStatementCallback implements StatementCallback&lt;T&gt;, SqlProvider &#123;</span><br><span class="line">            QueryStatementCallback() &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            @Nullable</span><br><span class="line">            public T doInStatement(Statement stmt) throws SQLException &#123;</span><br><span class="line">                ResultSet rs = null;</span><br><span class="line">                Object var3;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //这里真正的执行我们的sql语句</span><br><span class="line">                    rs = stmt.executeQuery(sql);</span><br><span class="line">                    //处理对象映射</span><br><span class="line">                    var3 = rse.extractData(rs);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    JdbcUtils.closeResultSet(rs);</span><br><span class="line">                &#125;</span><br><span class="line">                return var3;</span><br><span class="line">            &#125;</span><br><span class="line">            public String getSql() &#123;</span><br><span class="line">                return sql;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //调用execute接口</span><br><span class="line">        return this.execute((StatementCallback)(new QueryStatementCallback()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看到这里相信你也不得拍手称奇，Spring处理的非常巧妙，请继续向下看：</p>
<p><strong><em>update详解</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected int update(PreparedStatementCreator psc, @Nullable PreparedStatementSetter pss) throws DataAccessException &#123;</span><br><span class="line">        this.logger.debug(&quot;Executing prepared SQL update&quot;);</span><br><span class="line">        return updateCount((Integer)this.execute(psc, (ps) -&gt; &#123;</span><br><span class="line">            Integer var4;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (pss != null) &#123;</span><br><span class="line">                    pss.setValues(ps);</span><br><span class="line">                &#125;</span><br><span class="line">                int rows = ps.executeUpdate();</span><br><span class="line">                if (this.logger.isTraceEnabled()) &#123;</span><br><span class="line">                    this.logger.trace(&quot;SQL update affected &quot; + rows + &quot; rows&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                var4 = rows;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (pss instanceof ParameterDisposer) &#123;</span><br><span class="line">                    ((ParameterDisposer)pss).cleanupParameters();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return var4;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>为什么我要把update函数拎出来讲了，因为update这里使用了lambda函数,回想我们StatementCallback定义只有一个方法的接口，他就是一个函数是接口，所以他是一个函数式接口，所以这里直接使用lambda语法，<strong>lambda函数允许你直接内连，为函数接口的抽象方法提供实现，并且整个表达式作为函数接口的一个实例</strong>。我们在平时学习中可能知道了lambda语法但是可能使用的较少，或者不知道如何用于实战，那么多阅读源码一定可以提升你的实战能力。 我们可以看到JDBCTemplate使用了很多回调。为什么要用回调（Callback)?<strong>如果父类有多个抽象方法，子类需要全部实现这样特别麻烦，而有时候某个子类只需要定制父类中的某一个方法该怎么办呢？这个时候就要用到Callback回调了就可以完美解决这个问题</strong>，可以发现JDBCTemplate并没有完全拘泥于模板方法，非常灵活。我们在实际开发中也可以借鉴这种方法。</p>
<h3 id="模板方法模式的更多应用"><a href="#模板方法模式的更多应用" class="headerlink" title="模板方法模式的更多应用"></a>模板方法模式的更多应用</h3><p>事实上很多有关生命周期的类都用到了模板方法模式，最典型的也是可能我们最熟悉的莫过于Servlet了，废话不多说上源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class HttpServlet extends GenericServlet</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2019/5/21/16ad9448cb69de5e?imageView2/0/w/1280/h/960/ignore-error/1" alt> HttpServlet的所有方法，我们看到HttpServlet继承了GenericServlet，我们继续看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">public abstract class GenericServlet </span><br><span class="line">    implements Servlet, ServletConfig, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    private static final String LSTRING_FILE = &quot;javax.servlet.LocalStrings&quot;;</span><br><span class="line">    private static ResourceBundle lStrings =</span><br><span class="line">        ResourceBundle.getBundle(LSTRING_FILE);</span><br><span class="line"></span><br><span class="line">    private transient ServletConfig config;</span><br><span class="line">    </span><br><span class="line">    public GenericServlet() &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    //没有实现钩子</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getInitParameter(String name) &#123;</span><br><span class="line">        ServletConfig sc = getServletConfig();</span><br><span class="line">        if (sc == null) &#123;</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sc.getInitParameter(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Enumeration&lt;String&gt; getInitParameterNames() &#123;</span><br><span class="line">        ServletConfig sc = getServletConfig();</span><br><span class="line">        if (sc == null) &#123;</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sc.getInitParameterNames();</span><br><span class="line">    &#125;   </span><br><span class="line">     </span><br><span class="line">    public ServletConfig getServletConfig() &#123;</span><br><span class="line">	return config;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public ServletContext getServletContext() &#123;</span><br><span class="line">        ServletConfig sc = getServletConfig();</span><br><span class="line">        if (sc == null) &#123;</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sc.getServletContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getServletInfo() &#123;</span><br><span class="line">	return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init(ServletConfig config) throws ServletException &#123;</span><br><span class="line">	this.config = config;</span><br><span class="line">	this.init();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void init() throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void log(String msg) &#123;</span><br><span class="line">	getServletContext().log(getServletName() + &quot;: &quot;+ msg);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public void log(String message, Throwable t) &#123;</span><br><span class="line">	getServletContext().log(getServletName() + &quot;: &quot; + message, t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public abstract void service(ServletRequest req, ServletResponse res)</span><br><span class="line">	throws ServletException, IOException;</span><br><span class="line">    </span><br><span class="line">    public String getServletName() &#123;</span><br><span class="line">        ServletConfig sc = getServletConfig();</span><br><span class="line">        if (sc == null) &#123;</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sc.getServletName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这就是个典型的模板方法类蛮，而且钩子函数也在这里展现的淋漓尽致，如init、destroy方法等，JDK中很多类都是用了模板方法等着你发现哦。</p>
<h3 id="模板方法模式在Vue-js中的应用"><a href="#模板方法模式在Vue-js中的应用" class="headerlink" title="模板方法模式在Vue.js中的应用"></a>模板方法模式在Vue.js中的应用</h3><p>模板方法模式在其他语言中也有实现比如Vue.js、React中；比如Vue生命周期肯定使用了模板方法，我就不对源码展开分析了。<br><img src="https://user-gold-cdn.xitu.io/2019/5/21/16ad94b7aa8bb518?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>设计模式在Spring中得到了大量的应用，感兴趣的同学可以看看Spring源码加以学习，如果你觉得我写的还不错的话点个赞吧，如果你发现了错误，或者不好的地方也可以及时告诉我加以改正，谢谢！您的赞赏和批评是进步路上的好伙伴。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/22/从模板方法模式到JDBCTemplate/" data-id="cjzj919750013s22azuv61byh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-拜托！面试请不要再问我SpringCloud底层原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/21/拜托！面试请不要再问我SpringCloud底层原理/" class="article-date">
  <time datetime="2019-05-21T02:50:09.009Z" itemprop="datePublished">2019-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/21/拜托！面试请不要再问我SpringCloud底层原理/">拜托！面试请不要再问我Spring Cloud底层原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5be13b83f265da6116393fc7" target="_blank" rel="noopener">https://juejin.im/post/5be13b83f265da6116393fc7</a><br>欢迎关注微信公众号：<strong>石杉的架构笔记（id：shishan100）</strong></p>
</blockquote>
<p>每周一至五早8点半，精品技术文章准时送上！</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><strong>一、业务场景介绍</strong></p>
<p><strong>二、Spring Cloud核心组件：Eureka</strong></p>
<p><strong>三、Spring Cloud核心组件：Feign</strong></p>
<p><strong>四、Spring Cloud核心组件：Ribbon</strong></p>
<p><strong>五、Spring Cloud核心组件：Hystrix</strong></p>
<p><strong>六、Spring Cloud核心组件：Zuul</strong></p>
<p><strong>七、总结</strong></p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>毫无疑问，Spring Cloud是目前微服务架构领域的翘楚，无数的书籍博客都在讲解这个技术。不过大多数讲解还停留在对Spring Cloud功能使用的层面，其底层的很多原理，很多人可能并不知晓。<strong>因此本文将通过大量的手绘图</strong>，给大家谈谈Spring Cloud微服务架构的底层原理。</p>
<p>实际上，Spring Cloud是一个全家桶式的技术栈，包含了很多组件。本文先从其最核心的几个组件入手，来剖析一下其底层的工作原理。<strong>也就是Eureka、Ribbon、Feign、Hystrix、Zuul这几个组件。</strong></p>
<hr>
<h2 id="一、业务场景介绍"><a href="#一、业务场景介绍" class="headerlink" title="一、业务场景介绍"></a>一、业务场景介绍</h2><p>先来给大家说一个业务场景，假设咱们现在开发一个电商网站，要实现支付订单的功能，流程如下：</p>
<pre><code>* 创建一个订单后，如果用户立刻支付了这个订单，我们需要将订单状态更新为“已支付”
* 扣减相应的商品库存
* 通知仓储中心，进行发货
* 给用户的这次购物增加相应的积分</code></pre><p>针对上述流程，<strong>我们需要有订单服务、库存服务、仓储服务、积分服务</strong>。整个流程的大体思路如下：</p>
<pre><code>* 用户针对一个订单完成支付之后，就会去找订单服务，更新订单状态
* 订单服务调用库存服务，完成相应功能
* 订单服务调用仓储服务，完成相应功能
* 订单服务调用积分服务，完成相应功能</code></pre><p><strong>至此，整个支付订单的业务流程结束</strong></p>
<hr>
<p>下图这张图，清晰表明了各服务间的调用过程：<br><img src="https://user-gold-cdn.xitu.io/2018/11/7/166ebffb48c481a3?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>好！有了业务场景之后，咱们就一起来看看Spring Cloud微服务架构中，这几个组件如何相互协作，各自发挥的作用以及其背后的原理。</p>
<h2 id="二、Spring-Cloud核心组件：Eureka"><a href="#二、Spring-Cloud核心组件：Eureka" class="headerlink" title="二、Spring Cloud核心组件：Eureka"></a>二、Spring Cloud核心组件：Eureka</h2><p><strong>咱们来考虑第一个问题</strong>：订单服务想要调用库存服务、仓储服务，或者积分服务，怎么调用？</p>
<pre><code>* 订单服务压根儿就不知道人家库存服务在哪台机器上啊！他就算想要发起一个请求，都不知道发送给谁，有心无力！
* 这时候，就轮到Spring Cloud Eureka出场了。Eureka是微服务架构中的注册中心，专门负责服务的注册与发现。</code></pre><p>咱们来看看下面的这张图，结合图来仔细剖析一下整个流程：<br><img src="https://user-gold-cdn.xitu.io/2018/11/7/166ebffcb7ce31b8?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>如上图所示，库存服务、仓储服务、积分服务中都有一个<strong>Eureka Client组件，这个组件专门负责将这个服务的信息注册到Eureka Server中</strong>。说白了，就是告诉Eureka Server，自己在哪台机器上，监听着哪个端口。而<strong>Eureka Server是一个注册中心，里面有一个注册表，保存了各服务所在的机器和端口号</strong></p>
<p>订单服务里也有一个Eureka Client组件，这个Eureka Client组件会找Eureka Server问一下：库存服务在哪台机器啊？监听着哪个端口啊？仓储服务呢？积分服务呢？然后就可以把这些相关信息从Eureka Server的注册表中拉取到自己本地缓存起来。</p>
<p>这时如果订单服务想要调用库存服务，不就可以找自己本地的Eureka Client问一下库存服务在哪台机器？监听哪个端口吗？收到响应后，紧接着就可以发送一个请求过去，调用库存服务扣减库存的那个接口！同理，如果订单服务要调用仓储服务、积分服务，也是如法炮制。</p>
<p>总结一下：</p>
<pre><code>* **Eureka Client：**负责将这个服务的信息注册到Eureka Server中
* **Eureka Server：**注册中心，里面有一个注册表，保存了各个服务所在的机器和端口号</code></pre><h2 id="三、Spring-Cloud核心组件：Feign"><a href="#三、Spring-Cloud核心组件：Feign" class="headerlink" title="三、Spring Cloud核心组件：Feign"></a>三、Spring Cloud核心组件：Feign</h2><p>现在订单服务确实知道库存服务、积分服务、仓库服务在哪里了，同时也监听着哪些端口号了。<strong>但是新问题又来了：难道订单服务要自己写一大堆代码，跟其他服务建立网络连接，然后构造一个复杂的请求，接着发送请求过去，最后对返回的响应结果再写一大堆代码来处理吗？</strong></p>
<hr>
<p>这是上述流程翻译的代码片段，咱们一起来看看，体会一下这种绝望而无助的感受！！！</p>
<p><strong>友情提示，前方高能：</strong><br><img src="https://user-gold-cdn.xitu.io/2018/11/7/166ebced960f2024?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<p>看完上面那一大段代码，有没有感到后背发凉、一身冷汗？实际上你进行服务间调用时，如果每次都手写代码，代码量比上面那段要多至少几倍，所以这个事压根儿就不是地球人能干的。</p>
<p>既然如此，那怎么办呢？别急，Feign早已为我们提供好了优雅的解决方案。来看看如果用Feign的话，你的订单服务调用库存服务的代码会变成啥样？<br><img src="https://user-gold-cdn.xitu.io/2018/11/7/166ebcf01b773dd4?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<p>看完上面的代码什么感觉？是不是感觉整个世界都干净了，又找到了活下去的勇气！没有底层的建立连接、构造请求、解析响应的代码，直接就是用注解定义一个 FeignClient接口，然后调用那个接口就可以了。人家Feign Client会在底层根据你的注解，跟你指定的服务建立连接、构造请求、发起靕求、获取响应、解析响应，等等。这一系列脏活累活，人家Feign全给你干了。</p>
<p>那么问题来了，Feign是如何做到这么神奇的呢？很简单，<strong>Feign的一个关键机制就是使用了动态代理</strong>。咱们一起来看看下面的图，结合图来分析：</p>
<pre><code>* 首先，如果你对某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理
* 接着你要是调用那个接口，本质就是会调用 Feign创建的动态代理，这是核心中的核心
* Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务的地址
* 最后针对这个地址，发起请求、解析响应</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/11/7/166ebfff505b2a20?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<h2 id="四、Spring-Cloud核心组件：Ribbon"><a href="#四、Spring-Cloud核心组件：Ribbon" class="headerlink" title="四、Spring Cloud核心组件：Ribbon"></a>四、Spring Cloud核心组件：Ribbon</h2><p>说完了Feign，还没完。现在新的问题又来了，如果人家库存服务部署在了5台机器上，如下所示：</p>
<pre><code>* 192.168.169:9000
* 192.168.170:9000
* 192.168.171:9000
* 192.168.172:9000
* 192.168.173:9000</code></pre><p><strong>这下麻烦了！人家Feign怎么知道该请求哪台机器呢？</strong></p>
<pre><code>* 这时Spring Cloud Ribbon就派上用场了。Ribbon就是专门解决这个问题的。它的作用是**负载均衡**，会帮你在每次请求时选择一台机器，均匀的把请求分发到各个机器上
* Ribbon的负载均衡默认使用的最经典的**Round Robin轮询算法**。这是啥？简单来说，就是如果订单服务对库存服务发起10次请求，那就先让你请求第1台机器、然后是第2台机器、第3台机器、第4台机器、第5台机器，接着再来—个循环，第1台机器、第2台机器。。。以此类推。</code></pre><p><strong>此外，Ribbon是和Feign以及Eureka紧密协作，完成工作的，具体如下：</strong></p>
<pre><code>* 首先Ribbon会从 Eureka Client里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口号。
* 然后Ribbon就可以使用默认的Round Robin算法，从中选择一台机器
* Feign就会针对这台机器，构造并发起请求。</code></pre><p>对上述整个过程，再来一张图，帮助大家更深刻的理解：<br><img src="https://user-gold-cdn.xitu.io/2018/11/7/166ec001dc155e98?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<hr>
<h2 id="五、Spring-Cloud核心组件：Hystrix"><a href="#五、Spring-Cloud核心组件：Hystrix" class="headerlink" title="五、Spring Cloud核心组件：Hystrix"></a>五、Spring Cloud核心组件：Hystrix</h2><p>在微服务架构里，一个系统会有很多的服务。<strong>以本文的业务场景为例</strong>：订单服务在一个业务流程里需要调用三个服务。现在假设订单服务自己最多只有100个线程可以处理请求，然后呢，积分服务不幸的挂了，每次订单服务调用积分服务的时候，都会卡住几秒钟，然后抛出—个超时异常。</p>
<p><strong>咱们一起来分析一下，这样会导致什么问题？</strong></p>
<pre><code>1. 如果系统处于高并发的场景下，大量请求涌过来的时候，订单服务的100个线程都会卡在请求积分服务这块。导致订单服务没有一个线程可以处理请求
1. 然后就会导致别人请求订单服务的时候，发现订单服务也挂了，不响应任何请求了</code></pre><p>上面这个，就是<strong>微服务架构中恐怖的服务雪崩问题</strong>，如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/11/7/166ec0033f64a0a7?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>如上图，这么多服务互相调用，要是不做任何保护的话，某一个服务挂了，就会引起连锁反应，导致别的服务也挂。比如积分服务挂了，会导致订单服务的线程全部卡在请求积分服务这里，没有一个线程可以工作，瞬间导致订单服务也挂了，别人请求订单服务全部会卡住，无法响应。</p>
<p><strong>但是我们思考一下，就算积分服务挂了，订单服务也可以不用挂啊！为什么？</strong></p>
<pre><code>* 我们结合业务来看：支付订单的时候，只要把库存扣减了，然后通知仓库发货就OK了
* 如果积分服务挂了，大不了等他恢复之后，慢慢人肉手工恢复数据！为啥一定要因为一个积分服务挂了，就直接导致订单服务也挂了呢？不可以接受！</code></pre><p><strong>现在问题分析完了，如何解决？</strong></p>
<p>这时就轮到Hystrix闪亮登场了。Hystrix是隔离、熔断以及降级的一个框架。啥意思呢？说白了，<strong>Hystrix会搞很多个小小的线程池</strong>，比如订单服务请求库存服务是一个线程池，请求仓储服务是一个线程池，请求积分服务是一个线程池。每个线程池里的线程就仅仅用于请求那个服务。</p>
<p><strong>打个比方：现在很不幸，积分服务挂了，会咋样？</strong></p>
<p>当然会导致订单服务里那个用来调用积分服务的线程都卡死不能工作了啊！但由于订单服务调用库存服务、仓储服务的这两个线程池都是正常工作的，所以这两个服务不会受到任何影响。</p>
<p>这个时候如果别人请求订单服务，订单服务还是可以正常调用库存服务扣减库存，调用仓储服务通知发货。只不过调用积分服务的时候，每次都会报错。<strong>但是如果积分服务都挂了，每次调用都要去卡住几秒钟干啥呢？有意义吗？当然没有！</strong>所以我们直接对积分服务熔断不就得了，比如在5分钟内请求积分服务直接就返回了，不要去走网络请求卡住几秒钟，<strong>这个过程，就是所谓的熔断！</strong></p>
<hr>
<p><strong>那人家又说，兄弟，积分服务挂了你就熔断，好歹你干点儿什么啊！别啥都不干就直接返回啊？</strong>没问题，咱们就来个降级：每次调用积分服务，你就在数据库里记录一条消息，说给某某用户增加了多少积分，因为积分服务挂了，导致没增加成功！这样等积分服务恢复了，你可以根据这些记录手工加一下积分。<strong>这个过程，就是所谓的降级。</strong></p>
<hr>
<p>为帮助大家更直观的理解，接下来用一张图，梳理一下Hystrix隔离、熔断和降级的全流程：<br><img src="https://user-gold-cdn.xitu.io/2018/11/7/166ec004edf94426?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<h2 id="六、Spring-Cloud核心组件：Zuul"><a href="#六、Spring-Cloud核心组件：Zuul" class="headerlink" title="六、Spring Cloud核心组件：Zuul"></a>六、Spring Cloud核心组件：Zuul</h2><p>说完了Hystrix，接着给大家说说最后一个组件：Zuul，也就是微服务网关。<strong>这个组件是负责网络路由的。</strong>不懂网络路由？行，那我给你说说，如果没有Zuul的日常工作会怎样？</p>
<p>假设你后台部署了几百个服务，现在有个前端兄弟，人家请求是直接从浏览器那儿发过来的。<strong>打个比方</strong>：人家要请求一下库存服务，你难道还让人家记着这服务的名字叫做inventory-service？部署在5台机器上？就算人家肯记住这一个，你后台可有几百个服务的名称和地址呢？难不成人家请求一个，就得记住一个？你要这样玩儿，那真是友谊的小船，说翻就翻！</p>
<p>上面这种情况，压根儿是不现实的。所以一般微服务架构中都必然会设计一个网关在里面，像android、ios、pc前端、微信小程序、H5等等，不用去关心后端有几百个服务，就知道有一个网关，所有请求都往网关走，网关会根据请求中的一些特征，将请求转发给后端的各个服务。</p>
<p>而且有一个网关之后，还有很多好处，比如可以做<strong>统一的降级、限流、认证授权、安全</strong>，等等。</p>
<h2 id="七、总结："><a href="#七、总结：" class="headerlink" title="七、总结："></a>七、总结：</h2><p>最后再来总结一下，上述几个Spring Cloud核心组件，在微服务架构中，分别扮演的角色：</p>
<pre><code>* **Eureka**：各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里
* **Ribbon**：服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台
* **Feign**：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求
* **Hystrix**：发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题
* **Zuul**：如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务</code></pre><p>以上就是我们通过一个电商业务场景，阐述了Spring Cloud微服务架构几个核心组件的底层原理。</p>
<p><strong>文字总结还不够直观？没问题！</strong>我们将Spring Cloud的5个核心组件通过一张图串联起来，再来直观的感受一下其底层的架构原理：<br><img src="https://user-gold-cdn.xitu.io/2018/11/7/166ec006b1536f43?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<p>如有收获，请帮忙转发，您的鼓励是作者最大的动力，谢谢！</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/6/166e9511e7162c8b?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>Spring Cloud原创系列文章，将会持续更新</p>
<p>欢迎关注微信公众号：<strong>石杉的架构笔记（id:shishan100）</strong></p>
<p>十余年<strong>BAT架构经验</strong>倾囊相授</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/21/拜托！面试请不要再问我SpringCloud底层原理/" data-id="cjzj9197r001qs22ak7r7y2lf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/">Spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微服务/">微服务</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/服务器/">服务器</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-用大白话告诉你小白都能看懂的Hadoop架构原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/21/用大白话告诉你小白都能看懂的Hadoop架构原理/" class="article-date">
  <time datetime="2019-05-21T01:57:19.019Z" itemprop="datePublished">2019-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/21/用大白话告诉你小白都能看懂的Hadoop架构原理/">用大白话告诉你小白都能看懂的Hadoop架构原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5beaf02ce51d457e90196069" target="_blank" rel="noopener">https://juejin.im/post/5beaf02ce51d457e90196069</a> </p>
</blockquote>
<p><strong>欢迎关注个人微信号：石杉的架构笔记（id：shishan100）</strong></p>
<p><strong>周一至周五早8点半！精品技术文章准时送上！</strong></p>
<hr>
<p><strong>往期文章</strong></p>
<p>1、<a href="https://juejin.im/post/5be13b83f265da6116393fc7" target="_blank" rel="noopener">拜托！面试请不要再问我Spring Cloud底层原理</a></p>
<p>2、<a href="https://juejin.im/post/5be3f8dcf265da613a5382ca" target="_blank" rel="noopener">【双11狂欢的背后】微服务注册中心如何承载大型系统的千万级访问？</a></p>
<p>3、<a href="https://juejin.im/post/5be83e166fb9a049a7115580" target="_blank" rel="noopener">【性能优化之道】每秒上万并发下的Spring Cloud参数优化实战</a></p>
<p>4、<a href="https://juejin.im/post/5be99a68e51d4511a8090440" target="_blank" rel="noopener">微服务架构如何保障双11狂欢下的99.99%高可用</a></p>
<hr>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>一、前奏</p>
<p>二、HDFS的NameNode架构原理</p>
<h1 id="一、前奏"><a href="#一、前奏" class="headerlink" title="一、前奏"></a>一、前奏</h1><p>Hadoop是目前大数据领域最主流的一套技术体系，包含了多种技术。</p>
<p>包括HDFS（分布式文件系统），YARN（分布式资源调度系统），MapReduce（分布式计算系统），等等。</p>
<p>有些朋友可能听说过Hadoop，但是却不太清楚他到底是个什么东西，这篇文章就用大白话给各位阐述一下。</p>
<p>假如你现在公司里的数据都是放在MySQL里的，那么就全部放在一台数据库服务器上，我们就假设这台服务器的磁盘空间有2T吧，<strong>大家先看下面这张图。</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/13/1670dbfd11e62805?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<p>现在问题来了，你不停的往这台服务器的MySQL里放数据，结果数据量越来越大了，超过了2T的大小了，现在咋办？</p>
<p>你说，我可以搞多台MySQL数据库服务器，分库分表啊！每台服务器放一部分数据不就得了。<strong>如上图所示！</strong></p>
<p>好，没问题，那咱们搞3台数据库服务器，3个MySQL实例，然后每台服务器都可以2T的数据。</p>
<p>现在我问你一个问题，<strong>所谓的大数据是在干什么？</strong></p>
<p>我们来说一下大数据最初级的一个使用场景。假设你有一个电商网站，现在要把这个电商网站里所有的用户在页面和APP上的点击、购买、浏览的行为日志都存放起来分析。</p>
<p>你现在把这些数据全都放在了3台MySQL服务器，数据量很大，但还是勉强可以放的下。</p>
<p>某天早上，你的boss来了。要看一张报表，比如要看每天网站的X指标、Y指标、Z指标，等等，二三十个数据指标。</p>
<p>好了，兄弟，现在你尝试去从那些点击、购买、浏览的日志里，通过写一个SQL来分析出那二三十个指标试试看？</p>
<p>我跟你打赌，你绝对会写出来一个几百行起步，甚至上千行的超级复杂大SQL。这个SQL，你觉得他能运行在分库分表后的3台MySQL服务器上么？</p>
<p>如果你觉得可以的话，那你一定是不太了解MySQL分库分表后有多坑，几百行的大SQL跨库join，各种复杂的计算，根本不现实。</p>
<p>所以说，大数据的存储和计算压根儿不是靠MySQL来搞的，因此，Hadoop、Spark等大数据技术体系才应运而生。</p>
<p>本质上，Hadoop、Spark等大数据技术，其实就是一系列的分布式系统。</p>
<p>比如hadoop中的HDFS，就是大数据技术体系中的核心基石，<strong>负责分布式存储数据，这是啥意思？别急，继续往下看。</strong></p>
<p>HDFS全称是Hadoop Distributed File System，是Hadoop的分布式文件系统。</p>
<p>它由很多机器组成，每台机器上运行一个DataNode进程，负责管理一部分数据。</p>
<p>然后有一台机器上运行了NameNode进程，NameNode大致可以认为是负责管理整个HDFS集群的这么一个进程，他里面存储了HDFS集群的所有元数据。</p>
<p>然后有很多台机器，每台机器存储一部分数据！好，HDFS现在可以很好的存储和管理大量的数据了。</p>
<p>这时候你肯定会有疑问：MySQL服务器也不是这样的吗？你要是这样想，那就大错特错了。</p>
<p>这个事情不是你想的那么简单的，HDFS天然就是分布式的技术，所以你上传大量数据，存储数据，管理数据，天然就可以用HDFS来做。</p>
<p>如果你硬要基于MySQL分库分表这个事儿，会痛苦很多倍，因为MySQL并不是设计为分布式系统架构的，他在分布式数据存储这块缺乏很多数据保障的机制。</p>
<p>好，你现在用HDFS分布式存储了数据，接着不就是要分布式来计算这些数据了吗？</p>
<p>对于分布式计算：</p>
<pre><code>* 很多公司用Hive写几百行的大SQL（底层基于MapReduce）
* 也有很多公司开始慢慢的用Spark写几百行的大SQL（底层是Spark Core引擎）。</code></pre><p>总之就是写一个大SQL，人家会拆分为很多的计算任务，放到各个机器上去，每个计算任务就负责计算一小部分数据，这就是所谓的分布式计算。</p>
<p>这个，绝对比你针对分库分表的MySQL来跑几百行大SQL要靠谱的多。</p>
<p>对于上述所说，老规矩，同样给大家来一张图，大伙儿跟着图来仔细捋一下整个过程。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/13/1670dc005dc982dc?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<h1 id="二、HDFS的NameNode架构原理"><a href="#二、HDFS的NameNode架构原理" class="headerlink" title="二、HDFS的NameNode架构原理"></a>二、HDFS的NameNode架构原理</h1><p>好了，前奏铺垫完之后，进入正题。本文其实主要就是讨论一下HDFS集群中的NameNode的核心架构原理。</p>
<p>NameNode有一个很核心的功能：<strong>管理整个HDFS集群的元数据</strong>，比如说文件目录树、权限的设置、副本数的设置，等等。</p>
<p>下面就用最典型的文件目录树的维护，来给大家举例说明，<strong>我们看看下面的图。</strong>现在有一个客户端系统要上传一个1TB的大文件到HDFS集群里。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/13/1670dc022eeddf7f?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<p>此时他会先跟NameNode通信，说：大哥，我想创建一个新的文件，他的名字叫“/usr/hive/warehouse/access_20180101.log”，大小是1TB，你看行不？</p>
<p>然后NameNode就会在自己内存的文件目录树里，在指定的目录下搞一个新的文件对象，名字就是“access_20180101.log”。</p>
<p>这个文件目录树不就是HDFS非常核心的一块元数据，维护了HDFS这个分布式文件系统中，有哪些目录，有哪些文件，对不对？</p>
<p>但是有个问题，这个文件目录树是在NameNode的内存里的啊！</p>
<p>这可坑爹了，你把重要的元数据都放在内存里，<strong>万一NameNode不小心宕机了可咋整？元数据不就全部丢失了？</strong></p>
<p>可你要是每次都频繁的修改磁盘文件里的元数据，性能肯定是极低的啊！毕竟这是大量的磁盘随机读写！</p>
<p>没关系，<strong>我们来看看HDFS优雅的解决方案。</strong></p>
<p>每次内存里改完了，写一条edits log，元数据修改的操作日志到磁盘文件里，不修改磁盘文件内容，就是顺序追加，这个性能就高多了。</p>
<p>每次NameNode重启的时候，把edits log里的操作日志读到内存里回放一下，不就可以恢复元数据了？</p>
<p><strong>大家顺着上面的文字，把整个过程，用下面这张图跟着走一遍。</strong></p>
<hr>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/13/1670dc03f2942281?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<p>但是问题又来了，那edits log如果越来越大的话，岂不是每次重启都会很慢？因为要读取大量的edits log回放恢复元数据！</p>
<p>所以HDFS说，我可以这样子啊，我引入一个新的磁盘文件叫做<strong>fsimage</strong>，然后呢，再引入一个<strong>JournalNodes</strong>集群，以及一个<strong>Standby NameNode</strong>（备节点）。</p>
<p>每次Active NameNode（主节点）修改一次元数据都会生成一条edits log，<strong>除了写入本地磁盘文件，还会写入JournalNodes集群。</strong></p>
<p>然后Standby NameNode就可以从JournalNodes集群拉取edits log，应用到自己内存的文件目录树里，跟Active NameNode保持一致。</p>
<p>然后每隔一段时间，Standby NameNode都把自己内存里的文件目录树写一份到磁盘上的fsimage，这可不是日志，这是完整的一份元数据。<strong>这个操作就是所谓的checkpoint检查点操作。</strong></p>
<p>然后把这个fsimage上传到到Active NameNode，接着清空掉Active NameNode的旧的edits log文件，这里可能都有100万行修改日志了！</p>
<p>然后Active NameNode继续接收修改元数据的请求，再写入edits log，写了一小会儿，这里可能就几十行修改日志而已！</p>
<p>如果说此时，Active NameNode重启了，bingo！没关系，只要把Standby NameNode传过来的fsimage直接读到内存里，<strong>这个fsimage直接就是元数据</strong>，不需要做任何额外操作，纯读取，效率很高！</p>
<p>然后把新的edits log里少量的几十行的修改日志回放到内存里就ok了！</p>
<p>这个过程的启动速度就快的多了！因为不需要回放大量上百万行的edits log来恢复元数据了！如下图所示。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/13/1670dc062e2fa9e8?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<p>此外，<strong>大家看看上面这张图</strong>，现在咱们有俩NameNode。</p>
<pre><code>* 一个是主节点对外提供服务接收请求
* 另外一个纯就是接收和同步主节点的edits log以及执行定期checkpoint的备节点。</code></pre><p>大家有没有发现！他们俩内存里的元数据几乎是一模一样的啊！</p>
<p>所以呢，如果Active NameNode挂了，是不是可以立马切换成Standby NameNode对外提供服务？</p>
<p><strong>这不就是所谓的NameNode主备高可用故障转移机制么！</strong></p>
<p>接下来大家再想想，HDFS客户端在NameNode内存里的文件目录树，新加了一个文件。</p>
<p>但是这个时候，人家要把数据上传到多台DataNode机器上去啊，<strong>这可是一个1TB的大文件！咋传呢？</strong></p>
<p>很简单，<strong>把1TB的大文件拆成N个block</strong>，每个block是128MB。1TB = 1024GB = 1048576MB，一个block是128MB，那么就是对应着8192个block。</p>
<p>这些block会分布在不同的机器上管理着，比如说一共有100台机器组成的集群，那么每台机器上放80个左右的block就ok了。</p>
<p>但是问题又来了，那如果这个时候1台机器宕机了，不就导致80个block丢失了？</p>
<p>也就是说上传上去的1TB的大文件，会丢失一小部分数据啊。没关系！HDFS都考虑好了！</p>
<p>它会<strong>默认给每个block搞3个副本</strong>，一模一样的副本，分放在不同的机器上，如果一台机器宕机了，同一个block还有另外两个副本在其他机器上呢！</p>
<p><strong>大伙儿看看下面这张图</strong>。每个block都在不同的机器上有3个副本，任何一台机器宕机都没事！还可以从其他的机器上拿到那个block。</p>
<p>这下子，你往HDFS上传一个1TB的大文件，可以高枕无忧了吧！</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/13/1670dc07b1a880a6?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<p>OK，上面就是大白话加上一系列手绘图，给大家先聊聊小白都能听懂的Hadoop的基本架构原理</p>
<p>接下来会给大家聊聊HDFS，这个作为世界上最优秀的分布式存储系统，承载高并发请求、高性能文件上传的一些核心机制以及原理。</p>
<p><strong>《大规模集群下Hadoop如何承载每秒上千次的高并发访问》，</strong>敬请期待</p>
<p><strong>《【冰山下的秘密】Hadoop如何将TB级大文件的上传性能提升上百倍？》</strong>，敬请期待</p>
<p><strong>如有收获，请帮忙转发，您的鼓励是作者最大的动力，谢谢！</strong></p>
<p><strong>一大波微服务、分布式、高并发、高可用的**</strong>原创系列<strong>**文章正在路上,</strong></p>
<hr>
<p><strong>**欢迎扫描下方二维码</strong>，持续关注：**
<img src="https://user-gold-cdn.xitu.io/2018/11/12/167088310d1d57b1?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p><strong>石杉的架构笔记（id:shishan100）</strong></p>
<p><strong>十余年BAT架构经验倾囊相授</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/21/用大白话告诉你小白都能看懂的Hadoop架构原理/" data-id="cjzj9197u001xs22a5jfhhe3l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HDFS/">HDFS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hadoop/">Hadoop</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Token认证，如何快速方便获取用户信息" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/20/Token认证，如何快速方便获取用户信息/" class="article-date">
  <time datetime="2019-05-20T06:31:29.029Z" itemprop="datePublished">2019-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/20/Token认证，如何快速方便获取用户信息/">Token认证，如何快速方便获取用户信息</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5ce0dfb45188250c942f6c1d" target="_blank" rel="noopener">https://juejin.im/post/5ce0dfb45188250c942f6c1d</a> </p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们有一个Web项目，这个项目提供了很多的Rest API。也做了权限控制，访问API的请求必须要带上事先认证后获取的Token才可以。</p>
<p>认证的话就在Filter中进行的，会获取请求的Token进行验证，如果成功了可以得到Token中的用户信息，本文的核心就是讲解如何将用户信息（用户ID）优雅的传递给API接口（Controller）。</p>
<h1 id="方式一（很挫）"><a href="#方式一（很挫）" class="headerlink" title="方式一（很挫）"></a>方式一（很挫）</h1><p>我们在Filter中进行了统一拦截，在Controller中获取用户ID的话，仍然可以再次解析一遍Token获取用户ID</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/hello&quot;)</span><br><span class="line">public String test(HttpServletRequest request) &#123;</span><br><span class="line">    String token = request.getHeader(&quot;token&quot;);</span><br><span class="line">    JWTResult result = JWTUtils.checkToken(token);</span><br><span class="line">    Long userId = result.getUserId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方式二（优雅）"><a href="#方式二（优雅）" class="headerlink" title="方式二（优雅）"></a>方式二（优雅）</h1><p>方式一需要重新解析一遍Token, 浪费资源。我们可以直接将Filter中解析好了的用户ID直接通过Header传递给接口啊。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</span><br><span class="line">			throws IOException, ServletException &#123;</span><br><span class="line">    HttpServletRequest httpRequest = (HttpServletRequest) request;</span><br><span class="line">	HttpServletResponse httpResponse = (HttpServletResponse) response;</span><br><span class="line">    String token = request.getHeader(&quot;token&quot;);</span><br><span class="line">    JWTResult result = JWTUtils.checkToken(token);</span><br><span class="line">    Long userId = result.getUserId();</span><br><span class="line">	HttpServletRequestWrapper requestWrapper = new HttpServletRequestWrapper(httpRequest) &#123;</span><br><span class="line">		@Override</span><br><span class="line">		public String getHeader(String name) &#123;</span><br><span class="line">			if (name.equals(&quot;loginUserId&quot;)) &#123;</span><br><span class="line">				return userId .toString();</span><br><span class="line">			&#125;</span><br><span class="line">			return super.getHeader(name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	chain.doFilter(requestWrapper, httpResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中直接从Header中获取解析好了的用户ID:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/hello&quot;)</span><br><span class="line">public String save2(HttpServletRequest request) &#123;</span><br><span class="line">	Long userId = Long.parseLong(request.getHeader(&quot;loginUserId&quot;));	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方式三（很优雅）"><a href="#方式三（很优雅）" class="headerlink" title="方式三（很优雅）"></a>方式三（很优雅）</h1><p>通过Header传递确实很方便，但如果你有代码洁癖的话总会觉得怪怪的，能不能不用Header方式，比如说我就在方法上定义一个loginUserId的参数，你给我直接注入进来，这个有点意思哈，下面我们来实现下：</p>
<h3 id="GET参数方式"><a href="#GET参数方式" class="headerlink" title="GET参数方式"></a>GET参数方式</h3><p>在Filter中追加参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</span><br><span class="line">			throws IOException, ServletException &#123;</span><br><span class="line">    HttpServletRequest httpRequest = (HttpServletRequest) request;</span><br><span class="line">	HttpServletResponse httpResponse = (HttpServletResponse) response;</span><br><span class="line">    String token = request.getHeader(&quot;token&quot;);</span><br><span class="line">    JWTResult result = JWTUtils.checkToken(token);</span><br><span class="line">    Long userId = result.getUserId();</span><br><span class="line">	HttpServletRequestWrapper requestWrapper = new HttpServletRequestWrapper(httpRequest) &#123;</span><br><span class="line">		    @Override</span><br><span class="line">			public String[] getParameterValues(String name) &#123;</span><br><span class="line">				if (name.equals(&quot;loginUserId&quot;)) &#123;</span><br><span class="line">					return new String[] &#123; userId .toString() &#125;;</span><br><span class="line">				&#125;</span><br><span class="line">				return super.getParameterValues(name);</span><br><span class="line">			&#125;</span><br><span class="line">			@Override</span><br><span class="line">			public Enumeration&lt;String&gt; getParameterNames() &#123;</span><br><span class="line">				Set&lt;String&gt; paramNames = new LinkedHashSet&lt;&gt;();</span><br><span class="line">				paramNames.add(&quot;loginUserId&quot;);</span><br><span class="line">				Enumeration&lt;String&gt; names =  super.getParameterNames();</span><br><span class="line">				while(names.hasMoreElements()) &#123;</span><br><span class="line">					paramNames.add(names.nextElement());</span><br><span class="line">				&#125;</span><br><span class="line">				return Collections.enumeration(paramNames);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	chain.doFilter(requestWrapper, httpResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中直接填写参数即可获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/hello&quot;)</span><br><span class="line">public String save2(String name, Long loginUserId) &#123;</span><br><span class="line">	// loginUserId 就是Filter中追加的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于post请求，也可以用这种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/hello&quot;)</span><br><span class="line">public String save2(User user, Long loginUserId) &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可是往往我们在用post请求的时候，要么就是表单提交，要么就是json体的方式提交，一般不会使用get方式参数，这也就意味着这个loginUserId我们需要注入到对象中：</p>
<p>先创建一个参数实体类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">	private String name;</span><br><span class="line">	</span><br><span class="line">	private Long loginUserId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先模拟表单提交的方式，看看行不行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/hello&quot;)</span><br><span class="line">public User save2(User user) &#123;</span><br><span class="line">	return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用PostMan测试一下，表单方式是直接支持的：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/19/16ace69edcd28f75?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>再次试下Json提交方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/hello&quot;)</span><br><span class="line">public User save2(@RequestBody User user) &#123;</span><br><span class="line">	return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下图，失败了，得重新想办法实现下</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/19/16ace69edcc90ca7?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>只需要在HttpServletRequestWrapper中重新对提交的内容进行修改即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ServletInputStream getInputStream() throws IOException &#123;</span><br><span class="line">	byte[] requestBody = new byte[0];</span><br><span class="line">	try &#123;</span><br><span class="line">		requestBody = StreamUtils.copyToByteArray(request.getInputStream());</span><br><span class="line">		Map map = JsonUtils.toBean(Map.class, new String(requestBody));</span><br><span class="line">		map.put(&quot;loginUserId&quot;, loginUserId);</span><br><span class="line">		requestBody = JsonUtils.toJson(map).getBytes();</span><br><span class="line">	&#125; catch (IOException e) &#123;</span><br><span class="line">		throw new RuntimeException(e);</span><br><span class="line">	&#125;</span><br><span class="line">	final ByteArrayInputStream bais = new ByteArrayInputStream(requestBody);</span><br><span class="line">	return new ServletInputStream() &#123;</span><br><span class="line">		 @Override</span><br><span class="line">		  public int read() throws IOException &#123;</span><br><span class="line">		       return bais.read();</span><br><span class="line">		  &#125;</span><br><span class="line">		 </span><br><span class="line">		  @Override</span><br><span class="line">		   public boolean isFinished() &#123;</span><br><span class="line">		       return false;</span><br><span class="line">		   &#125;</span><br><span class="line">		 </span><br><span class="line">		   @Override</span><br><span class="line">		   public boolean isReady() &#123;</span><br><span class="line">		        return true;</span><br><span class="line">		   &#125;</span><br><span class="line">		 </span><br><span class="line">		   @Override</span><br><span class="line">		    public void setReadListener(ReadListener listener) &#123;</span><br><span class="line">		 </span><br><span class="line">		    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，我们就可以直接将Token解析的用户ID直接注入到参数中了，不用去Header中获取，是不是很方便。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/15/16ab91d71d2ab715?imageView2/0/w/1280/h/960/ignore-error/1" alt="猿天地"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/20/Token认证，如何快速方便获取用户信息/" data-id="cjzj9196v000js22af5vaisxo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-【Spring】Autowired原理及与Resource注解区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/17/【Spring】Autowired原理及与Resource注解区别/" class="article-date">
  <time datetime="2019-05-17T07:03:08.008Z" itemprop="datePublished">2019-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/17/【Spring】Autowired原理及与Resource注解区别/">【Spring】Autowired原理及与Resource注解区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5cde05fae51d454759351d8c" target="_blank" rel="noopener">https://juejin.im/post/5cde05fae51d454759351d8c</a> </p>
</blockquote>
<h2 id="Autowired注解"><a href="#Autowired注解" class="headerlink" title="Autowired注解"></a>Autowired注解</h2><p>Autowired顾名思义，表示自动注入，如下是Autowired注解的源代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Autowired &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Declares whether the annotated dependency is required.</span><br><span class="line">     * &lt;p&gt;Defaults to &#123;@code true&#125;.</span><br><span class="line">     */</span><br><span class="line">    boolean required() default true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从Autowired的实现可以看到，Autowired可以用于类的构造方法，类的字段，类的方法以及注解类型上，但是Autowired不能用于类上面。</p>
<p>关于Autowired注解，有如下问题需要解决：</p>
<ol>
<li><p>Autowired作用在不同的范围上(构造方法，字段、方法)上，它的装配策略如何，按名称还是类型？</p>
</li>
<li><p>为构造方法，字段和方法添加Autowired注解之后，谁来解析这个Autowired注解，完成装配</p>
</li>
<li><p>装配的bean从何处而来，是在Spring的xml文件中定义的bean吗？</p>
</li>
</ol>
<h2 id="从Autowired的javadoc开始"><a href="#从Autowired的javadoc开始" class="headerlink" title="从Autowired的javadoc开始"></a>从Autowired的javadoc开始</h2><p>从Autowired的javadoc中得到如下信息</p>
<ol>
<li><p>AutowiredAnnotationBeanPostProcessor负责扫描Autowired注解，然后完成自动注入</p>
</li>
<li><p>可以对私有的字段使用Autowired进行自动装配，而无需为私有字段定义getter/setter来read/write这个字段</p>
</li>
<li><p>使用Autowired注解的类方法，可以是任意的方法名，任意的参数，Spring会从容器中找到合适的bean进行装配，setter自动注入跟对字段自动注入效果一样</p>
</li>
</ol>
<h2 id="Autowired注解的解析"><a href="#Autowired注解的解析" class="headerlink" title="Autowired注解的解析"></a>Autowired注解的解析</h2><p>当项目中使用了Autowired注解时，需要明确的告诉Spring,配置中引用了自动注入的功能，在Spring的配置文件，做法有两种</p>
<ol>
<li><p>配置AutowiredAnnotationBeanPostProcessor</p>
</li>
<li><p>使用<a href>context:annotation-config/</a>。<a href>context:annotationconfig/</a> 将隐式地向 Spring 容器注册<code>AutowiredAnnotationBeanPostProcessor</code>、<code>CommonAnnotationBeanPostProcessor</code>、<code>PersistenceAnnotationBeanPostProcessor</code>以及<code>RequiredAnnotationBeanPostProcessor</code> 这 4 个 BeanPostProcessor。</p>
</li>
</ol>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="1-实例一："><a href="#1-实例一：" class="headerlink" title="1. 实例一："></a>1. 实例一：</h3><pre><code>* UserSerice依赖的UserDao使用Autowired注解，
* UserDao没有在Spring配置文件中定义</code></pre><p><strong>结果：UserDao为null</strong></p>
<h3 id="2-实例二："><a href="#2-实例二：" class="headerlink" title="2. 实例二："></a>2. 实例二：</h3><pre><code>* UserSerice依赖的UserDao使用Autowired注解
* UserDao在Spring配置文件中有定义</code></pre><p><strong>结果：UserDao为null</strong></p>
<h3 id="3-实例三："><a href="#3-实例三：" class="headerlink" title="3. 实例三："></a>3. 实例三：</h3><pre><code>* UserSerice依赖的UserDao使用Autowired注解
* UserDao在Spring配置文件中有定义
* Spring中使用[context:annotation-config/]()</code></pre><p>/<em>/</em> 结果：UserDao正确注入，在Spring中配置的UserDao的实现，而在UserService中的是UserDao的接口，也就是说，虽然它们类型没有完全匹配，但是由于是实现/<em>/</em></p>
<p><strong>关系，Spring仍然能够完成自动注入</strong></p>
<h3 id="4-实例四："><a href="#4-实例四：" class="headerlink" title="4. 实例四："></a>4. 实例四：</h3><pre><code>* UserSerice依赖的UserDao使用Autowired注解
* UserDao在Spring配置文件中有定义
* Spring中配置AutowiredAnnotationBeanPostProcessor</code></pre><p><strong>结果：UserDao正确注入，同实例三</strong></p>
<h3 id="5-实例五："><a href="#5-实例五：" class="headerlink" title="5. 实例五："></a>5. 实例五：</h3><pre><code>* UserSerice依赖的UserDao使用Autowired注解
* UserDao在Spring配置文件中有两份定义(id不同)
* Spring中使用[context:annotation-config/]()</code></pre><p><strong>结果：</strong></p>
<p><strong>1. 如果UserDao的属性名与某个bean的id相同，那么按照属性名和id名称匹配原则，自动装配</strong></p>
<p><strong>2. 如果UserService中定义的UserDao的属性名，与Spring配置文件中的两个id都不同，那么注入失败，异常抛出，提示，无法完整自动装配</strong></p>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a><strong>结论：</strong></h2><ol>
<li><p>使用Autowired自动装配，必须在Spring的配置文件中使用<a href>context:annotation-config/</a>来告诉Spring需要进行自动装配扫描（AutowiredAnnotationBeanPostProcessor不推荐使用）</p>
</li>
<li><p>Autowired默认按类型进行匹配，当匹配到多个满足条件的bean时，再按照属性名和bean的id进行匹配，如果仍然有多个匹配上或者没有一个匹配上，则抛出异常，提示自动装配失败</p>
</li>
<li><p>在使用Autowired时，可以使用Qualifier注解，显式的指定，当冲突发生时，使用那个id对应的bean</p>
</li>
<li><p>Autowired注解自动装配功能完成的是依赖的自动注入，因此，在一个bean中，它依赖的bean可以通过自动注入的方式完成而不需要显式的为它的属性进行注入。但是这些依赖的bean仍然不能省略，还是要在Spring中进行配置，省略的仅仅是bean属性的注入配置代码</p>
</li>
</ol>
<h2 id="Resource注解"><a href="#Resource注解" class="headerlink" title="Resource注解"></a>Resource注解</h2><p>Resource注解在功能和目的上，等效于Autowried+Qualifier注解，Resource注解是JSR-250规范的一部分，它定义在JDK的javax.annoation包中，如下是它的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">package javax.annotation;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line">import static java.lang.annotation.ElementType.*;</span><br><span class="line">import static java.lang.annotation.RetentionPolicy.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The Resource annotation marks a resource that is needed</span><br><span class="line"> * by the application.  This annotation may be applied to an</span><br><span class="line"> * application component class, or to fields or methods of the</span><br><span class="line"> * component class.  When the annotation is applied to a</span><br><span class="line"> * field or method, the container will inject an instance</span><br><span class="line"> * of the requested resource into the application component</span><br><span class="line"> * when the component is initialized.  If the annotation is</span><br><span class="line"> * applied to the component class, the annotation declares a</span><br><span class="line"> * resource that the application will look up at runtime. &lt;p&gt;</span><br><span class="line"> *</span><br><span class="line"> * Even though this annotation is not marked Inherited, deployment</span><br><span class="line"> * tools are required to examine all superclasses of any component</span><br><span class="line"> * class to discover all uses of this annotation in all superclasses.</span><br><span class="line"> * All such annotation instances specify resources that are needed</span><br><span class="line"> * by the application component.  Note that this annotation may</span><br><span class="line"> * appear on private fields and methods of superclasses; the container</span><br><span class="line"> * is required to perform injection in these cases as well.</span><br><span class="line"> *</span><br><span class="line"> * @since Common Annotations 1.0</span><br><span class="line"> */</span><br><span class="line">@Target(&#123;TYPE, FIELD, METHOD&#125;)</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line">public @interface Resource &#123;</span><br><span class="line">    /**</span><br><span class="line">     * The JNDI name of the resource.  For field annotations,</span><br><span class="line">     * the default is the field name.  For method annotations,</span><br><span class="line">     * the default is the JavaBeans property name corresponding</span><br><span class="line">     * to the method.  For class annotations, there is no default</span><br><span class="line">     * and this must be specified.</span><br><span class="line">     */</span><br><span class="line">    String name() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The name of the resource that the reference points to. It can</span><br><span class="line">     * link to any compatible resource using the global JNDI names.</span><br><span class="line">     *</span><br><span class="line">     * @since Common Annotations 1.1</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    String lookup() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The Java type of the resource.  For field annotations,</span><br><span class="line">     * the default is the type of the field.  For method annotations,</span><br><span class="line">     * the default is the type of the JavaBeans property.</span><br><span class="line">     * For class annotations, there is no default and this must be</span><br><span class="line">     * specified.</span><br><span class="line">     */</span><br><span class="line">    Class&lt;?&gt; type() default java.lang.Object.class;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The two possible authentication types for a resource.</span><br><span class="line">     */</span><br><span class="line">    enum AuthenticationType &#123;</span><br><span class="line">            CONTAINER,</span><br><span class="line">            APPLICATION</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The authentication type to use for this resource.</span><br><span class="line">     * This may be specified for resources representing a</span><br><span class="line">     * connection factory of any supported type, and must</span><br><span class="line">     * not be specified for resources of other types.</span><br><span class="line">     */</span><br><span class="line">    AuthenticationType authenticationType() default AuthenticationType.CONTAINER;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Indicates whether this resource can be shared between</span><br><span class="line">     * this component and other components.</span><br><span class="line">     * This may be specified for resources representing a</span><br><span class="line">     * connection factory of any supported type, and must</span><br><span class="line">     * not be specified for resources of other types.</span><br><span class="line">     */</span><br><span class="line">    boolean shareable() default true;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * A product specific name that this resource should be mapped to.</span><br><span class="line">     * The name of this resource, as defined by the &lt;code&gt;name&lt;/code&gt;</span><br><span class="line">     * element or defaulted, is a name that is local to the application</span><br><span class="line">     * component using the resource.  (It&apos;s a name in the JNDI</span><br><span class="line">     * &lt;code&gt;java:comp/env&lt;/code&gt; namespace.)  Many application servers</span><br><span class="line">     * provide a way to map these local names to names of resources</span><br><span class="line">     * known to the application server.  This mapped name is often a</span><br><span class="line">     * &lt;i&gt;global&lt;/i&gt; JNDI name, but may be a name of any form. &lt;p&gt;</span><br><span class="line">     *</span><br><span class="line">     * Application servers are not required to support any particular</span><br><span class="line">     * form or type of mapped name, nor the ability to use mapped names.</span><br><span class="line">     * The mapped name is product-dependent and often installation-dependent.</span><br><span class="line">     * No use of a mapped name is portable.</span><br><span class="line">     */</span><br><span class="line">    String mappedName() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Description of this resource.  The description is expected</span><br><span class="line">     * to be in the default language of the system on which the</span><br><span class="line">     * application is deployed.  The description can be presented</span><br><span class="line">     * to the Deployer to help in choosing the correct resource.</span><br><span class="line">     */</span><br><span class="line">    String description() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Autowried注解，首先根据类型匹配，如果类型匹配到多个，那么在根据属性名和bean的id进行匹配(可以由Qualifier注解强制匹配指定的bean id)。Resource注解则顺序不同，它有如下几种可能的情况：</p>
<pre><code>* Resource注解指定了name属性和type属性</code></pre><p>策略：首先进行按名称匹配策略： 匹配name属性和bean的id，如果匹配，则判断查找到的bean是否是type属性指定的类型，如果是type属性指定的类型，则匹配成功。如果不是<strong><strong>type属性指定的类型</strong></strong>，则抛出异常，提示匹配失败；如果name属性跟bean的id不匹配，则抛出异常提示没有bean的id匹配name属性</p>
<pre><code>* Resource注解指定了name属性，未指定type属性</code></pre><p>策略：查找bean的id为name属性的bean，查找到，不关心类型为什么，都是匹配成功；如果找不到name属性指定的bean id，则匹配失败，抛出异常</p>
<pre><code>* Resource注解指定了type属性，未指定name属性</code></pre><p>策略：首先进行按名称匹配策略： 匹配属性名和bean的id，如果匹配，则判断查找到的bean是否是type属性指定的类型，如果是type属性指定的类型，则匹配成功。如果不是<strong><strong>type属性指定的类型</strong></strong>，则抛出异常，提示匹配失败；其次进行按类型匹配策略： 如果属性名跟bean的id不匹配，则查找类型为type的bean，如果仅仅找到一个，自动装配成功，其它情况失败。</p>
<pre><code>* Resource注解未指定type属性和name属性</code></pre><p>策略：首先进行按属性名匹配策略，匹配则注入成功；如果属性名不匹配，则进行类型匹配策略，只有为一个类型匹配才成功，其他情况都失败</p>
<h3 id="作者注：欢迎关注笔者公号，定期分享IT互联网、金融等工作经验心得、人生感悟，欢迎交流，目前就职阿里-移动事业部，需要大厂内推的也可到公众号砸简历，或查看我个人资料获取。（公号ID：weknow619）。"><a href="#作者注：欢迎关注笔者公号，定期分享IT互联网、金融等工作经验心得、人生感悟，欢迎交流，目前就职阿里-移动事业部，需要大厂内推的也可到公众号砸简历，或查看我个人资料获取。（公号ID：weknow619）。" class="headerlink" title="作者注：欢迎关注笔者公号，定期分享IT互联网、金融等工作经验心得、人生感悟，欢迎交流，目前就职阿里-移动事业部，需要大厂内推的也可到公众号砸简历，或查看我个人资料获取。（公号ID：weknow619）。"></a>作者注：欢迎关注笔者公号，定期分享IT互联网、金融等工作经验心得、人生感悟，欢迎交流，目前就职阿里-移动事业部，需要大厂内推的也可到公众号砸简历，或查看我个人资料获取。（公号ID：weknow619）。</h3><p><img src="https://user-gold-cdn.xitu.io/2018/9/9/165bc4a503dfcc18?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/17/【Spring】Autowired原理及与Resource注解区别/" data-id="cjzj91971000ws22a54olorsw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java的12个语法糖" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/16/Java的12个语法糖/" class="article-date">
  <time datetime="2019-05-16T07:40:26.026Z" itemprop="datePublished">2019-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/16/Java的12个语法糖/">Java的12个语法糖</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5cd8c5e6f265da03555c9d79" target="_blank" rel="noopener">https://juejin.im/post/5cd8c5e6f265da03555c9d79</a> </p>
</blockquote>
<p>GitHub 2.5k Star 的<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fhollischuang%2FtoBeTopJavaer" target="_blank" rel="noopener">Java工程师成神之路</a> ，不来了解一下吗?</p>
<p>GitHub 2.5k Star 的<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fhollischuang%2FtoBeTopJavaer" target="_blank" rel="noopener">Java工程师成神之路</a> ，真的不来了解一下吗?</p>
<p>GitHub 2.5k Star 的<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fhollischuang%2FtoBeTopJavaer" target="_blank" rel="noopener">Java工程师成神之路</a> ，真的确定不来了解一下吗?</p>
<p>本文从 Java 编译原理角度，深入字节码及 class 文件，抽丝剥茧，了解 Java 中的语法糖原理及用法，帮助大家在学会如何使用 Java。</p>
<h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><p>语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。<br>有意思的是，在编程领域，除了语法糖，还有语法盐和语法糖精的说法，篇幅有限这里不做扩展了。</p>
<p>我们所熟知的编程语言中几乎都有语法糖。作者认为，语法糖的多少是评判一个语言够不够牛逼的标准之一。很多人说Java是一个“低糖语言”，其实从Java 7开始Java语言层面上一直在添加各种糖，主要是在“Project Coin”项目下研发。尽管现在Java有人还是认为现在的Java是低糖，未来还会持续向着“高糖”的方向发展。</p>
<h3 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h3><p>前面提到过，语法糖的存在主要是方便开发人员使用。但其实，Java虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。</p>
<p>说到编译，大家肯定都知道，Java语言中，<code>javac</code>命令可以将后缀名为<code>.java</code>的源文件编译为后缀名为<code>.class</code>的可以运行于Java虚拟机的字节码。如果你去看<code>com.sun.tools.javac.main.JavaCompiler</code>的源码，你会发现在<code>compile()</code>中有一个步骤就是调用<code>desugar()</code>，这个方法就是负责解语法糖的实现的。</p>
<p>Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。本文主要来分析下这些语法糖背后的原理。一步一步剥去糖衣，看看其本质。</p>
<h3 id="糖块一、-switch-支持-String-与枚举"><a href="#糖块一、-switch-支持-String-与枚举" class="headerlink" title="糖块一、 switch 支持 String 与枚举"></a>糖块一、 switch 支持 String 与枚举</h3><p>前面提到过，从Java 7 开始，Java语言中的语法糖在逐渐丰富，其中一个比较重要的就是Java 7中<code>switch</code>开始支持<code>String</code>。</p>
<p>在开始coding之前先科普下，Java中的<code>swith</code>自身原本就支持基本类型。比如<code>int</code>、<code>char</code>等。对于<code>int</code>类型，直接进行数值的比较。对于<code>char</code>类型则是比较其ascii码。所以，对于编译器来说，<code>switch</code>中其实只能使用整型，任何类型的比较都要转换成整型。比如<code>byte</code>。<code>short</code>，<code>char</code>(ackii码是整型)以及<code>int</code>。</p>
<p>那么接下来看下<code>switch</code>对<code>String</code>得支持，有以下代码：<br><code>public class switchDemoString {
    public static void main(String[] args) {
        String str = &quot;world&quot;;
        switch (str) {
        case &quot;hello&quot;:
            System.out.println(&quot;hello&quot;);
            break;
        case &quot;world&quot;:
            System.out.println(&quot;world&quot;);
            break;
        default:
            break;
        }
    }
}</code></p>
<p><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F58" target="_blank" rel="noopener">反编译</a>后内容如下：</p>
<p><code>public class switchDemoString
{
    public switchDemoString()
    {
    }
    public static void main(String args[])
    {
        String str = &quot;world&quot;;
        String s;
        switch((s = str).hashCode())
        {
        default:
            break;
        case 99162322:
            if(s.equals(&quot;hello&quot;))
                System.out.println(&quot;hello&quot;);
            break;
        case 113318802:
            if(s.equals(&quot;world&quot;))
                System.out.println(&quot;world&quot;);
            break;
        }
    }
}</code></p>
<p>看到这个代码，你知道原来/<em>/</em>字符串的switch是通过<code>equals()</code>和<code>hashCode()</code>方法来实现的。/<em>/</em>还好<code>hashCode()</code>方法返回的是<code>int</code>，而不是<code>long</code>。</p>
<p>仔细看下可以发现，进行<code>switch</code>的实际是哈希值，然后通过使用<code>equals</code>方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行switch或者使用纯整数常量，但这也不是很差。</p>
<h3 id="糖块二、-泛型"><a href="#糖块二、-泛型" class="headerlink" title="糖块二、 泛型"></a>糖块二、 泛型</h3><p>我们都知道，很多语言都是支持泛型的，但是很多人不知道的是，不同的编译器对于泛型的处理方式是不同的，通常情况下，一个编译器处理泛型有两种方式：<code>Code specialization</code>和<code>Code sharing</code>。C++和C/#是使用<code>Code specialization</code>的处理机制，而Java使用的是<code>Code sharing</code>的机制。<br>Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（<code>type erasue</code>）实现的。</p>
<p>也就是说，<strong>对于Java虚拟机来说，他根本不认识<code>Map&lt;String, String&gt; map</code>这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。</strong></p>
<p>类型擦除的主要过程如下： 1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。 2.移除所有的类型参数。</p>
<p>以下代码：<br><code>Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();  
map.put(&quot;name&quot;, &quot;hollis&quot;);  
map.put(&quot;wechat&quot;, &quot;Hollis&quot;);  
map.put(&quot;blog&quot;, &quot;www.hollischuang.com&quot;);</code></p>
<p>解语法糖之后会变成：</p>
<p><code>Map map = new HashMap();  
map.put(&quot;name&quot;, &quot;hollis&quot;);  
map.put(&quot;wechat&quot;, &quot;Hollis&quot;);  
map.put(&quot;blog&quot;, &quot;www.hollischuang.com&quot;);</code></p>
<p>以下代码：</p>
<p><code>public static &lt;A extends Comparable&lt;A&gt;&gt; A max(Collection&lt;A&gt; xs) {
    Iterator&lt;A&gt; xi = xs.iterator();
    A w = xi.next();
    while (xi.hasNext()) {
        A x = xi.next();
        if (w.compareTo(x) &lt; 0)
            w = x;
    }
    return w;
}</code></p>
<p>类型擦除后会变成：</p>
<p><code>public static Comparable max(Collection xs){
    Iterator xi = xs.iterator();
    Comparable w = (Comparable)xi.next();
    while(xi.hasNext())
    {
        Comparable x = (Comparable)xi.next();
        if(w.compareTo(x) &lt; 0)
            w = x;
    }
    return w;
}</code></p>
<p><strong>虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的<code>Class</code>类对象。比如并不存在<code>List&lt;String&gt;.class</code>或是<code>List&lt;Integer&gt;.class</code>，而只有<code>List.class</code>。</strong></p>
<h3 id="糖块三、-自动装箱与拆箱"><a href="#糖块三、-自动装箱与拆箱" class="headerlink" title="糖块三、 自动装箱与拆箱"></a>糖块三、 自动装箱与拆箱</h3><p>自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。原始类型byte, short, char, int, long, float, double 和 boolean 对应的封装类为Byte, Short, Character, Integer, Long, Float, Double, Boolean。</p>
<p>先来看个自动装箱的代码：<br><code>public static void main(String[] args) {
    int i = 10;
    Integer n = i;
}</code></p>
<p>反编译后代码如下:</p>
<p><code>public static void main(String args[])
{
    int i = 10;
    Integer n = Integer.valueOf(i);
}</code></p>
<p>再来看个自动拆箱的代码：</p>
<p>`public static void main(String[] args) {</p>
<pre><code>Integer i = 10;
int n = i;</code></pre><p>}`</p>
<p>反编译后代码如下：</p>
<p><code>public static void main(String args[])
{
    Integer i = Integer.valueOf(10);
    int n = i.intValue();
}</code></p>
<p>从反编译得到内容可以看出，在装箱的时候自动调用的是<code>Integer</code>的<code>valueOf(int)</code>方法。而在拆箱的时候自动调用的是<code>Integer</code>的<code>intValue</code>方法。</p>
<p>所以，<strong>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。</strong></p>
<h3 id="糖块四-、-方法变长参数"><a href="#糖块四-、-方法变长参数" class="headerlink" title="糖块四 、 方法变长参数"></a>糖块四 、 方法变长参数</h3><p>可变参数(<code>variable arguments</code>)是在Java 1.5中引入的一个特性。它允许一个方法把任意数量的值作为参数。</p>
<p>看下以下可变参数代码，其中print方法接收可变参数：<br>`public static void main(String[] args)<br>    {<br>        print(“Holis”, “公众号:Hollis”, “博客：<a href="http://www.hollischuang.com&quot;" target="_blank" rel="noopener">www.hollischuang.com&quot;</a>, “QQ：907607222”);<br>    }</p>
<p>public static void print(String… strs)<br>{
    for (int i = 0; i &lt; strs.length; i++)<br>    {<br>        System.out.println(strs[i]);<br>    }<br>}`</p>
<p>反编译后代码：</p>
<p>`public static void main(String args[])<br>{
    print(new String[] {<br>        “Holis”, “\u516C\u4F17\u53F7:Hollis”, “\u535A\u5BA2\uFF1A<a href="http://www.hollischuang.com&quot;" target="_blank" rel="noopener">www.hollischuang.com&quot;</a>, “QQ\uFF1A907607222”<br>    });<br>}</p>
<p>public static transient void print(String strs[])<br>{
    for(int i = 0; i &lt; strs.length; i++)<br>        System.out.println(strs[i]);</p>
<p>}`</p>
<p>从反编译后代码可以看出，可变参数在被使用的时候，他首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数，然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。</p>
<p>PS：反编译后的print方法声明中有一个transient标识，是不是很奇怪？transient不是不可以修饰方法吗？transient不是和序列化有关么？transient在这里的作用是什么？因为这个与本文关系不大，这里不做深入分析了。相了解的同学可以关注我微信公众号或者博客。</p>
<h3 id="糖块五-、-枚举"><a href="#糖块五-、-枚举" class="headerlink" title="糖块五 、 枚举"></a>糖块五 、 枚举</h3><p>Java SE5提供了一种新的类型-Java的枚举类型，关键字<code>enum</code>可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。</p>
<p>要想看源码，首先得有一个类吧，那么枚举类型到底是什么类呢？是<code>enum</code>吗？答案很明显不是，<code>enum</code>就和<code>class</code>一样，只是一个关键字，他并不是一个类，那么枚举是由什么类维护的呢，我们简单的写一个枚举：<br><code>public enum t {
    SPRING,SUMMER;
}</code></p>
<p>然后我们使用反编译，看看这段代码到底是怎么实现的，反编译后代码内容如下：</p>
<p>`public final class T extends Enum<br>{
    private T(String s, int i)<br>    {<br>        super(s, i);<br>    }<br>    public static T[] values()<br>    {<br>        T at[];<br>        int i;<br>        T at1[];<br>        System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i);<br>        return at1;<br>    }</p>
<pre><code>public static T valueOf(String s)
{
    return (T)Enum.valueOf(demo/T, s);
}

public static final T SPRING;
public static final T SUMMER;
private static final T ENUM$VALUES[];
static
{
    SPRING = new T(&quot;SPRING&quot;, 0);
    SUMMER = new T(&quot;SUMMER&quot;, 1);
    ENUM$VALUES = (new T[] {
        SPRING, SUMMER
    });
}</code></pre><p>}`</p>
<p>通过反编译后代码我们可以看到，<code>public final class T extends Enum</code>，说明，该类是继承了<code>Enum</code>类的，同时<code>final</code>关键字告诉我们，这个类也是不能被继承的。<strong>当我们使用<code>enmu</code>来定义一个枚举类型的时候，编译器会自动帮我们创建一个<code>final</code>类型的类继承<code>Enum</code>类，所以枚举类型不能被继承。</strong></p>
<h3 id="糖块六-、-内部类"><a href="#糖块六-、-内部类" class="headerlink" title="糖块六 、 内部类"></a>糖块六 、 内部类</h3><p>内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。</p>
<p><strong>内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念，<code>outer.java</code>里面定义了一个内部类<code>inner</code>，一旦编译成功，就会生成两个完全不同的<code>.class</code>文件了，分别是<code>outer.class</code>和<code>outer$inner.class</code>。所以内部类的名字完全可以和它的外部类名字相同。</strong><br>`public class OutterClass {<br>    private String userName;</p>
<pre><code>public String getUserName() {
    return userName;
}

public void setUserName(String userName) {
    this.userName = userName;
}

public static void main(String[] args) {

}

class InnerClass{
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</code></pre><p>}`</p>
<p>以上代码编译后会生成两个class文件：<code>OutterClass$InnerClass.class</code> 、<code>OutterClass.class</code> 。当我们尝试对<code>OutterClass.class</code>文件进行反编译的时候，命令行会打印以下内容：<code>Parsing OutterClass.class...Parsing inner class OutterClass$InnerClass.class... Generating OutterClass.jad</code> 。他会把两个文件全部进行反编译，然后一起生成一个<code>OutterClass.jad</code>文件。文件内容如下：</p>
<p>`public class OutterClass<br>{
    class InnerClass<br>    {<br>        public String getName()<br>        {<br>            return name;<br>        }<br>        public void setName(String name)<br>        {<br>            this.name = name;<br>        }<br>        private String name;<br>        final OutterClass this$0;</p>
<pre><code>    InnerClass()
    {
        this.this$0 = OutterClass.this;
        super();
    }
}

public OutterClass()
{
}
public String getUserName()
{
    return userName;
}
public void setUserName(String userName){
    this.userName = userName;
}
public static void main(String args1[])
{
}
private String userName;</code></pre><p>}`</p>
<h3 id="糖块七-、条件编译"><a href="#糖块七-、条件编译" class="headerlink" title="糖块七 、条件编译"></a>糖块七 、条件编译</h3><p>—般情况下，程序中的每一行代码都要参加编译。但有时候出于对程序代码优化的考虑，希望只对其中一部分内容进行编译，此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。</p>
<p>如在C或CPP中，可以通过预处理语句来实现条件编译。其实在Java中也可实现条件编译。我们先来看一段代码：<br>`public class ConditionalCompilation {<br>    public static void main(String[] args) {<br>        final boolean DEBUG = true;<br>        if(DEBUG) {<br>            System.out.println(“Hello, DEBUG!”);<br>        }</p>
<pre><code>    final boolean ONLINE = false;

    if(ONLINE){
        System.out.println(&quot;Hello, ONLINE!&quot;);
    }
}</code></pre><p>}`</p>
<p>反编译后代码如下：</p>
<p>`public class ConditionalCompilation<br>{</p>
<pre><code>public ConditionalCompilation()
{
}

public static void main(String args[])
{
    boolean DEBUG = true;
    System.out.println(&quot;Hello, DEBUG!&quot;);
    boolean ONLINE = false;
}</code></pre><p>}`</p>
<p>首先，我们发现，在反编译后的代码中没有<code>System.out.println(&quot;Hello, ONLINE!&quot;);</code>，这其实就是条件编译。当<code>if(ONLINE)</code>为false的时候，编译器就没有对其内的代码进行编译。</p>
<p>所以，<strong>Java语法的条件编译，是通过判断条件为常量的if语句实现的。其原理也是Java语言的语法糖。根据if判断条件的真假，编译器直接把分支为false的代码块消除。通过该方式实现的条件编译，必须在方法体内实现，而无法在正整个Java类的结构或者类的属性上进行条件编译，这与C/C++的条件编译相比，确实更有局限性。在Java语言设计之初并没有引入条件编译的功能，虽有局限，但是总比没有更强。</strong></p>
<h3 id="糖块八-、-断言"><a href="#糖块八-、-断言" class="headerlink" title="糖块八 、 断言"></a>糖块八 、 断言</h3><p>在Java中，<code>assert</code>关键字是从JAVA SE 1.4 引入的，为了避免和老版本的Java代码中使用了<code>assert</code>关键字导致错误，Java在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！），如果要开启断言检查，则需要用开关<code>-enableassertions</code>或<code>-ea</code>来开启。</p>
<p>看一段包含断言的代码：<br><code>public class AssertTest {
    public static void main(String args[]) {
        int a = 1;
        int b = 1;
        assert a == b;
        System.out.println(&quot;公众号：Hollis&quot;);
        assert a != b : &quot;Hollis&quot;;
        System.out.println(&quot;博客：www.hollischuang.com&quot;);
    }
}</code></p>
<p>反编译后代码如下：</p>
<p>`public class AssertTest {<br>   public AssertTest()<br>    {<br>    }<br>    public static void main(String args[])<br>{
    int a = 1;<br>    int b = 1;<br>    if(!$assertionsDisabled &amp;&amp; a != b)<br>        throw new AssertionError();<br>    System.out.println(“\u516C\u4F17\u53F7\uFF1AHollis”);<br>    if(!$assertionsDisabled &amp;&amp; a == b)<br>    {<br>        throw new AssertionError(“Hollis”);<br>    } else<br>    {<br>        System.out.println(“\u535A\u5BA2\uFF1A<a href="http://www.hollischuang.com&quot;" target="_blank" rel="noopener">www.hollischuang.com&quot;</a>);<br>        return;<br>    }<br>}</p>
<p>static final boolean $assertionsDisabled = !com/hollis/suguar/AssertTest.desiredAssertionStatus();</p>
<p>}`</p>
<p>很明显，反编译之后的代码要比我们自己的代码复杂的多。所以，使用了assert这个语法糖我们节省了很多代码。<strong>其实断言的底层实现就是if语言，如果断言结果为true，则什么都不做，程序继续执行，如果断言结果为false，则程序抛出AssertError来打断程序的执行。</strong><code>-enableassertions</code>会设置$assertionsDisabled字段的值。</p>
<h3 id="糖块九-、-数值字面量"><a href="#糖块九-、-数值字面量" class="headerlink" title="糖块九 、 数值字面量"></a>糖块九 、 数值字面量</h3><p>在java 7中，数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。这些下划线不会对字面量的数值产生影响，目的就是方便阅读。</p>
<p>比如：<br><code>public class Test {
    public static void main(String... args) {
        int i = 10_000;
        System.out.println(i);
    }
}</code></p>
<p>反编译后：</p>
<p><code>public class Test
{
  public static void main(String[] args)
  {
    int i = 10000;
    System.out.println(i);
  }
}</code></p>
<p>反编译后就是把<code>_</code>删除了。也就是说 <strong>编译器并不认识在数字字面量中的<code>_</code>，需要在编译阶段把他去掉。</strong></p>
<h3 id="糖块十-、-for-each"><a href="#糖块十-、-for-each" class="headerlink" title="糖块十 、 for-each"></a>糖块十 、 for-each</h3><p>增强for循环（<code>for-each</code>）相信大家都不陌生，日常开发经常会用到的，他会比for循环要少写很多代码，那么这个语法糖背后是如何实现的呢？<br><code>public static void main(String... args) {
    String[] strs = {&quot;Hollis&quot;, &quot;公众号：Hollis&quot;, &quot;博客：www.hollischuang.com&quot;};
    for (String s : strs) {
        System.out.println(s);
    }
    List&lt;String&gt; strList = ImmutableList.of(&quot;Hollis&quot;, &quot;公众号：Hollis&quot;, &quot;博客：www.hollischuang.com&quot;);
    for (String s : strList) {
        System.out.println(s);
    }
}</code></p>
<p>反编译后代码如下：</p>
<p>`public static transient void main(String args[])<br>{
    String strs[] = {<br>        “Hollis”, “\u516C\u4F17\u53F7\uFF1AHollis”, “\u535A\u5BA2\uFF1A<a href="http://www.hollischuang.com&quot;" target="_blank" rel="noopener">www.hollischuang.com&quot;</a><br>    };<br>    String args1[] = strs;<br>    int i = args1.length;<br>    for(int j = 0; j &lt; i; j++)<br>    {<br>        String s = args1[j];<br>        System.out.println(s);<br>    }</p>
<pre><code>List strList = ImmutableList.of(&quot;Hollis&quot;, &quot;\u516C\u4F17\u53F7\uFF1AHollis&quot;, &quot;\u535A\u5BA2\uFF1Awww.hollischuang.com&quot;);
String s;
for(Iterator iterator = strList.iterator(); iterator.hasNext(); System.out.println(s))
    s = (String)iterator.next();</code></pre><p>}`</p>
<p>代码很简单，<strong>for-each的实现原理其实就是使用了普通的for循环和迭代器。</strong></p>
<h3 id="糖块十一-、-try-with-resource"><a href="#糖块十一-、-try-with-resource" class="headerlink" title="糖块十一 、 try-with-resource"></a>糖块十一 、 try-with-resource</h3><p>Java里，对于文件操作IO流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过close方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄露等问题。</p>
<p>关闭资源的常用方式就是在<code>finally</code>块里是释放，即调用<code>close</code>方法。比如，我们经常会写这样的代码：<br><code>public static void main(String[] args) {
    BufferedReader br = null;
    try {
        String line;
        br = new BufferedReader(new FileReader(&quot;d:\\hollischuang.xml&quot;));
        while ((line = br.readLine()) != null) {
            System.out.println(line);
        }
    } catch (IOException e) {
        // handle exception
    } finally {
        try {
            if (br != null) {
                br.close();
            }
        } catch (IOException ex) {
            // handle exception
        }
    }
}</code></p>
<p>从Java 7开始，jdk提供了一种更好的方式关闭资源，使用<code>try-with-resources</code>语句，改写一下上面的代码，效果如下：</p>
<p><code>public static void main(String... args) {
    try (BufferedReader br = new BufferedReader(new FileReader(&quot;d:\\ hollischuang.xml&quot;))) {
        String line;
        while ((line = br.readLine()) != null) {
            System.out.println(line);
        }
    } catch (IOException e) {
        // handle exception
    }
}</code></p>
<p>看，这简直是一大福音啊，虽然我之前一般使用<code>IOUtils</code>去关闭流，并不会使用在<code>finally</code>中写很多代码的方式，但是这种新的语法糖看上去好像优雅很多呢。看下他的背后：</p>
<p><code>public static transient void main(String args[])
    {
        BufferedReader br;
        Throwable throwable;
        br = new BufferedReader(new FileReader(&quot;d:\\ hollischuang.xml&quot;));
        throwable = null;
        String line;
        try
        {
            while((line = br.readLine()) != null)
                System.out.println(line);
        }
        catch(Throwable throwable2)
        {
            throwable = throwable2;
            throw throwable2;
        }
        if(br != null)
            if(throwable != null)
                try
                {
                    br.close();
                }
                catch(Throwable throwable1)
                {
                    throwable.addSuppressed(throwable1);
                }
            else
                br.close();
            break MISSING_BLOCK_LABEL_113;
            Exception exception;
            exception;
            if(br != null)
                if(throwable != null)
                    try
                    {
                        br.close();
                    }
                    catch(Throwable throwable3)
                      {
                        throwable.addSuppressed(throwable3);
                    }
                else
                    br.close();
        throw exception;
        IOException ioexception;
        ioexception;
    }
}</code></p>
<p><strong>其实背后的原理也很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。所以，再次印证了，语法糖的作用就是方便程序员的使用，但最终还是要转成编译器认识的语言。</strong></p>
<h3 id="糖块十二、Lambda表达式"><a href="#糖块十二、Lambda表达式" class="headerlink" title="糖块十二、Lambda表达式"></a>糖块十二、Lambda表达式</h3><p>关于lambda表达式，有人可能会有质疑，因为网上有人说他并不是语法糖。其实我想纠正下这个说法。<strong>Labmda表达式不是匿名内部类的语法糖，但是他也是一个语法糖。实现方式其实是依赖了几个JVM底层提供的lambda相关api。</strong></p>
<p>先来看一个简单的lambda表达式。遍历一个list：<br>`public static void main(String… args) {<br>    List<string> strList = ImmutableList.of(“Hollis”, “公众号：Hollis”, “博客：<a href="http://www.hollischuang.com&quot;" target="_blank" rel="noopener">www.hollischuang.com&quot;</a>);</string></p>
<pre><code>strList.forEach( s -&gt; { System.out.println(s); } );</code></pre><p>}`</p>
<p>为啥说他并不是内部类的语法糖呢，前面讲内部类我们说过，内部类在编译之后会有两个class文件，但是，包含lambda表达式的类编译后只有一个文件。</p>
<p>反编译后代码如下:<br>`public static /* varargs */ void main(String … args) {<br>    ImmutableList strList = ImmutableList.of((Object)”Hollis”, (Object)”\u516c\u4f17\u53f7\uff1aHollis”, (Object)”\u535a\u5ba2\uff1a<a href="http://www.hollischuang.com&quot;" target="_blank" rel="noopener">www.hollischuang.com&quot;</a>);<br>    strList.forEach((Consumer<string>)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$0(java.lang.String ), (Ljava/lang/String;)V)());<br>}</string></p>
<p>private static /* synthetic */ void lambda$main$0(String s) {<br>    System.out.println(s);<br>}`</p>
<p>可以看到，在<code>forEach</code>方法中，其实是调用了<code>java.lang.invoke.LambdaMetafactory#metafactory</code>方法，该方法的第四个参数implMethod指定了方法实现。可以看到这里其实是调用了一个<code>lambda$main$0</code>方法进行了输出。</p>
<p>再来看一个稍微复杂一点的，先对List进行过滤，然后再输出：<br>`public static void main(String… args) {<br>    List<string> strList = ImmutableList.of(“Hollis”, “公众号：Hollis”, “博客：<a href="http://www.hollischuang.com&quot;" target="_blank" rel="noopener">www.hollischuang.com&quot;</a>);</string></p>
<pre><code>List HollisList = strList.stream().filter(string -&gt; string.contains(&quot;Hollis&quot;)).collect(Collectors.toList());

HollisList.forEach( s -&gt; { System.out.println(s); } );</code></pre><p>}`</p>
<p>反编译后代码如下：</p>
<p>`public static /* varargs */ void main(String … args) {<br>    ImmutableList strList = ImmutableList.of((Object)”Hollis”, (Object)”\u516c\u4f17\u53f7\uff1aHollis”, (Object)”\u535a\u5ba2\uff1a<a href="http://www.hollischuang.com&quot;" target="_blank" rel="noopener">www.hollischuang.com&quot;</a>);<br>    List<object> HollisList = strList.stream().filter((Predicate<string>)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)Z, lambda$main$0(java.lang.String ), (Ljava/lang/String;)Z)()).collect(Collectors.toList());<br>    HollisList.forEach((Consumer<object>)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$1(java.lang.Object ), (Ljava/lang/Object;)V)());<br>}</object></string></object></p>
<p>private static /* synthetic */ void lambda$main$1(Object s) {<br>    System.out.println(s);<br>}</p>
<p>private static /* synthetic */ boolean lambda$main$0(String string) {<br>    return string.contains(“Hollis”);<br>}`</p>
<p>两个lambda表达式分别调用了<code>lambda$main$1</code>和<code>lambda$main$0</code>两个方法。</p>
<p><strong>所以，lambda表达式的实现其实是依赖了一些底层的api，在编译阶段，编译器会把lambda表达式进行解糖，转换成调用内部api的方式。</strong></p>
<h3 id="可能遇到的坑"><a href="#可能遇到的坑" class="headerlink" title="可能遇到的坑"></a>可能遇到的坑</h3><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p><strong>一、当泛型遇到重载</strong> public class GenericTypes {<br>`public static void method(List<string> list) {<br>        System.out.println(“invoke method(List<string> list)”);<br>    }  </string></string></p>
<pre><code>public static void method(List&lt;Integer&gt; list) {  
    System.out.println(&quot;invoke method(List&lt;Integer&gt; list)&quot;);  
}  </code></pre><p>}`</p>
<p>上面这段代码，有两个重载的函数，因为他们的参数类型不同，一个是List另一个是List ，但是，这段代码是编译通不过的。因为我们前面讲过，参数List和List编译之后都被擦除了，变成了一样的原生类型List，擦除动作导致这两个方法的特征签名变得一模一样。</p>
<p><strong>二、当泛型遇到catch</strong> 泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型<code>MyException&lt;String&gt;</code>和<code>MyException&lt;Integer&gt;</code>的</p>
<p><strong>三、当泛型内包含静态变量</strong><br><code>public class StaticTest{
    public static void main(String[] args){
        GT&lt;Integer&gt; gti = new GT&lt;Integer&gt;();
        gti.var=1;
        GT&lt;String&gt; gts = new GT&lt;String&gt;();
        gts.var=2;
        System.out.println(gti.var);
    }
}
class GT&lt;T&gt;{
    public static int var=0;
    public void nothing(T x){}
}</code></p>
<p>以上代码输出结果为：2！由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的。</p>
<h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><p><strong>对象相等比较</strong></p>
<p>public class BoxingTest {<br><code>public static void main(String[] args) {
    Integer a = 1000;
    Integer b = 1000;
    Integer c = 100;
    Integer d = 100;
    System.out.println(&quot;a == b is &quot; + (a == b));
    System.out.println((&quot;c == d is &quot; + (c == d)));
}</code></p>
<p>输出结果：</p>
<p><code>a == b is false
c == d is true</code></p>
<p>在Java 5中，在Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。</p>
<p>适用于整数值区间-128 至 +127。</p>
<p>只适用于自动装箱。使用构造函数创建对象不适用。</p>
<h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><p><strong>ConcurrentModificationException</strong><br><code>for (Student stu : students) {    
    if (stu.getId() == 2)     
        students.remove(stu);    
}</code></p>
<p>会抛出<code>ConcurrentModificationException</code>异常。</p>
<p>Iterator是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出<code>java.util.ConcurrentModificationException</code>异常。</p>
<p>所以 <code>Iterator</code> 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 <code>Iterator</code> 本身的方法<code>remove()</code>来删除对象，<code>Iterator.remove()</code> 方法会在删除当前迭代对象的同时维护索引的一致性。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前面介绍了12种Java中常用的语法糖。所谓语法糖就是提供给开发人员便于开发的一种语法而已。但是这种语法只有开发人员认识。要想被执行，需要进行解糖，即转成JVM认识的语法。当我们把语法糖解糖之后，你就会发现其实我们日常使用的这些方便的语法，其实都是一些其他更简单的语法构成的。</p>
<p>有了这些语法糖，我们在日常开发的时候可以大大提升效率，但是同时也要避免过渡使用。使用之前最好了解下原理，避免掉坑。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/13/16aaec8209852aa9?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>参考资料： <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F58" target="_blank" rel="noopener">Java的反编译</a> <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F61" target="_blank" rel="noopener">Java中的Switch对整型、字符型、字符串型的具体实现细节</a> <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F197" target="_blank" rel="noopener">深度分析Java的枚举类型—-枚举的线程安全性及序列化问题</a> <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F195" target="_blank" rel="noopener">Java的枚举类型用法介绍</a> <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F1776" target="_blank" rel="noopener">Java中的增强for循环（for each）的实现原理与坑</a> <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F230" target="_blank" rel="noopener">Java中泛型的理解</a> <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F1174" target="_blank" rel="noopener">Java中整型的缓存机制</a> <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F1271" target="_blank" rel="noopener">Java中的可变参数</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/16/Java的12个语法糖/" data-id="cjzj9196f0004s22agz3jjsdm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java8新的异步编程方式CompletableFuture(3)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/14/Java8新的异步编程方式CompletableFuture(3)/" class="article-date">
  <time datetime="2019-05-14T03:46:27.027Z" itemprop="datePublished">2019-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/14/Java8新的异步编程方式CompletableFuture(3)/">Java8新的异步编程方式 CompletableFuture(三)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/59eae7636fb9a045117044c6" target="_blank" rel="noopener">https://juejin.im/post/59eae7636fb9a045117044c6</a> </p>
</blockquote>
<p>前面两篇文章已经整理了CompletableFuture大部分的特性，本文会整理完CompletableFuture余下的特性，以及将它跟RxJava进行比较。</p>
<h2 id="3-6-Either"><a href="#3-6-Either" class="headerlink" title="3.6 Either"></a>3.6 Either</h2><p>Either 表示的是两个CompletableFuture，当其中任意一个CompletableFuture计算完成的时候就会执行。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">acceptEither(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)</td>
<td align="center">当任意一个CompletableFuture完成的时候，action这个消费者就会被执行。</td>
</tr>
<tr>
<td align="center">acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)</td>
<td align="center">当任意一个CompletableFuture完成的时候，action这个消费者就会被执行。使用ForkJoinPool</td>
</tr>
<tr>
<td align="center">acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action, Executor executor)</td>
<td align="center">当任意一个CompletableFuture完成的时候，action这个消费者就会被执行。使用指定的线程池</td>
</tr>
<tr>
<td align="center">`Random random =  Random();</td>
<td align="center"></td>
</tr>
</tbody></table>
<pre><code>CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(()-&gt;{

     {
        Thread.sleep(random.nextInt());
    }  (InterruptedException e) {
        e.printStackTrace();
    }

     ;
});

CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(()-&gt;{

     {
        Thread.sleep(random.nextInt());
    }  (InterruptedException e) {
        e.printStackTrace();
    }

     ;
});

CompletableFuture&lt;Void&gt; future =  future1.acceptEither(future2,str-&gt;System.out.println(+str));

 {
    future.get();
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>执行结果：The future is from future1 或者 The future is from future2。<br>因为future1和future2，执行的顺序是随机的。</p>
<p>applyToEither 跟 acceptEither 类似。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">applyToEither(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn)</td>
<td align="center">当任意一个CompletableFuture完成的时候，fn会被执行，它的返回值会当作新的CompletableFuture<u>的计算结果。</u></td>
</tr>
<tr>
<td align="center">applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn)</td>
<td align="center">当任意一个CompletableFuture完成的时候，fn会被执行，它的返回值会当作新的CompletableFuture<u>的计算结果。使用ForkJoinPool</u></td>
</tr>
<tr>
<td align="center">applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn, Executor executor)</td>
<td align="center">当任意一个CompletableFuture完成的时候，fn会被执行，它的返回值会当作新的CompletableFuture<u>的计算结果。使用指定的线程池</u></td>
</tr>
<tr>
<td align="center">`Random random =  Random();</td>
<td align="center"></td>
</tr>
</tbody></table>
<pre><code>CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(()-&gt;{

     {
        Thread.sleep(random.nextInt());
    }  (InterruptedException e) {
        e.printStackTrace();
    }

     ;
});

CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(()-&gt;{

     {
        Thread.sleep(random.nextInt());
    }  (InterruptedException e) {
        e.printStackTrace();
    }

     ;
});

CompletableFuture&lt;String&gt; future =  future1.applyToEither(future2,str-&gt;+str);

 {
    System.out.println(future.get());
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>执行结果也跟上面的程序类似。</p>
<h2 id="3-7-其他方法"><a href="#3-7-其他方法" class="headerlink" title="3.7 其他方法"></a>3.7 其他方法</h2><p>allOf、anyOf是CompletableFuture的静态方法。</p>
<h3 id="3-7-1-allOf"><a href="#3-7-1-allOf" class="headerlink" title="3.7.1 allOf"></a>3.7.1 allOf</h3><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">allOf(CompletableFuture&lt;?&gt;… cfs)</td>
<td align="center">在所有Future对象完成后结束，并返回一个future。</td>
</tr>
</tbody></table>
<p>allOf()方法所返回的CompletableFuture，并不能组合前面多个CompletableFuture的计算结果。于是我们借助Java 8的Stream来组合多个future的结果。<br>`CompletableFuture<string> future1 = CompletableFuture.supplyAsync(() -&gt; );</string></p>
<pre><code>CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; );

CompletableFuture&lt;String&gt; future3 = CompletableFuture.supplyAsync(() -&gt; );

CompletableFuture.allOf(future1, future2, future3)
        .thenApply(v -&gt;
        Stream.of(future1, future2, future3)
                .map(CompletableFuture::join)
                .collect(Collectors.joining()))
        .thenAccept(System.out::print);`</code></pre><p>执行结果：</p>
<p><code>tony cafei aaron</code></p>
<h3 id="3-7-2-anyOf"><a href="#3-7-2-anyOf" class="headerlink" title="3.7.2 anyOf"></a>3.7.2 anyOf</h3><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">anyOf(CompletableFuture&lt;?&gt;… cfs)</td>
<td align="center">在任何一个Future对象结束后结束，并返回一个future。</td>
</tr>
<tr>
<td align="center">`Random rand =  Random();</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">CompletableFuture<string> future1 = CompletableFuture.supplyAsync(() -&gt; {</string></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">{</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Thread.sleep(rand.nextInt());</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">}  (InterruptedException e) {</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">e.printStackTrace();</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">}</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">});</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">CompletableFuture<string> future2 = CompletableFuture.supplyAsync(() -&gt; {</string></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">{</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Thread.sleep(rand.nextInt());</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">}  (InterruptedException e) {</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">e.printStackTrace();</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">}</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">});</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">CompletableFuture<string> future3 = CompletableFuture.supplyAsync(() -&gt; {</string></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">{</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Thread.sleep(rand.nextInt());</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">}  (InterruptedException e) {</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">e.printStackTrace();</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">}</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">});</td>
<td align="center"></td>
</tr>
</tbody></table>
<pre><code>CompletableFuture&lt;Object&gt; future =  CompletableFuture.anyOf(future1,future2,future3);

 {
    System.out.println(future.get());
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>使用anyOf()时，只要某一个future完成，就结束了。所以执行结果可能是”from future1”、”from future2”、”from future3”中的任意一个。</p>
<p>anyOf 和 acceptEither、applyToEither的区别在于，后两者只能使用在两个future中，而anyOf可以使用在多个future中。</p>
<h2 id="3-8-CompletableFuture异常处理"><a href="#3-8-CompletableFuture异常处理" class="headerlink" title="3.8 CompletableFuture异常处理"></a>3.8 CompletableFuture异常处理</h2><p>CompletableFuture在运行时如果遇到异常，可以使用get()并抛出异常进行处理，但这并不是一个最好的方法。CompletableFuture本身也提供了几种方式来处理异常。</p>
<h3 id="3-8-1-exceptionally"><a href="#3-8-1-exceptionally" class="headerlink" title="3.8.1 exceptionally"></a>3.8.1 exceptionally</h3><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">exceptionally(Function fn)</td>
<td align="center">只有当CompletableFuture抛出异常的时候，才会触发这个exceptionally的计算，调用function计算值。</td>
</tr>
<tr>
<td align="center">`CompletableFuture.supplyAsync(() -&gt; )</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">.thenApply(s -&gt; {</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">s = ;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">length = s.length();</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">length;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">}).thenAccept(i -&gt; System.out.println(i))</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">.exceptionally(t -&gt; {</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">System.out.println( + t);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">});`</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>执行结果：</p>
<p><code>Unexpected error:java.util.concurrent.CompletionException: java.lang.NullPointerException</code></p>
<p>对上面的代码稍微做了一下修改，修复了空指针的异常。</p>
<p>`CompletableFuture.supplyAsync(() -&gt; )<br>                .thenApply(s -&gt; {</p>
<pre><code>     length = s.length();
     length;
}).thenAccept(i -&gt; System.out.println(i))
.exceptionally(t -&gt; {
    System.out.println( + t);
     ;
});`</code></pre><p>执行结果：</p>
<p>``</p>
<h3 id="3-8-2-whenComplete"><a href="#3-8-2-whenComplete" class="headerlink" title="3.8.2 whenComplete"></a>3.8.2 whenComplete</h3><p>whenComplete 在上一篇文章其实已经介绍过了，在这里跟exceptionally的作用差不多，可以捕获任意阶段的异常。如果没有异常的话，就执行action。<br>`CompletableFuture.supplyAsync(() -&gt; )<br>                .thenApply(s -&gt; {<br>                    s = ;<br>                     length = s.length();<br>                     length;<br>                }).thenAccept(i -&gt; System.out.println(i))<br>                .whenComplete((result, throwable) -&gt; {</p>
<pre><code>     (throwable != ) {
       System.out.println(+throwable);
    }  {
        System.out.println(result);
    }

});`</code></pre><p>执行结果：</p>
<p><code>Unexpected error:java.util.concurrent.CompletionException: java.lang.NullPointerException</code></p>
<p>跟whenComplete相似的方法是handle，handle的用法在上一篇文章中也已经介绍过。</p>
<h1 id="四-CompletableFuture-VS-Java8-Stream-VS-RxJava1-amp-RxJava2"><a href="#四-CompletableFuture-VS-Java8-Stream-VS-RxJava1-amp-RxJava2" class="headerlink" title="四. CompletableFuture VS Java8 Stream VS RxJava1 &amp; RxJava2"></a>四. CompletableFuture VS Java8 Stream VS RxJava1 &amp; RxJava2</h1><p>CompletableFuture 有很多特性跟RxJava很像，所以将CompletableFuture、Java 8 Stream和RxJava做一个相互的比较。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">composable</th>
<th align="center">lazy</th>
<th align="center">resuable</th>
<th align="center">async</th>
<th align="center">cached</th>
<th align="center">push</th>
<th align="center">back pressure</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CompletableFuture</td>
<td align="center">支持</td>
<td align="center">不支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">Stream</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">Observable(RxJava1)</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">Observable(RxJava2)</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">Flowable(RxJava2)</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
</tbody></table>
<h1 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h1><p>Java 8提供了一种函数风格的异步和事件驱动编程模型CompletableFuture，它不会造成堵塞。CompletableFuture背后依靠的是fork/join框架来启动新的线程实现异步与并发。当然，我们也能通过指定线程池来做这些事情。</p>
<p>CompletableFuture特别是对微服务架构而言，会有很大的作为。举一个具体的场景，电商的商品页面可能会涉及到商品详情服务、商品评论服务、相关商品推荐服务等等。获取商品的信息时（/productdetails?productid=xxx），需要调用多个服务来处理这一个请求并返回结果。这里可能会涉及到并发编程，我们完全可以使用Java 8的CompletableFuture或者RxJava来实现。</p>
<p>先前的文章：<br><a href="https://juejin.im/post/59eae61b51882549fc512b34" target="_blank" rel="noopener">Java8新的异步编程方式 CompletableFuture(一)</a><br><a href="https://juejin.im/post/59eae6e4f265da430e4e4cb5" target="_blank" rel="noopener">Java8新的异步编程方式 CompletableFuture(二)</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/14/Java8新的异步编程方式CompletableFuture(3)/" data-id="cjzj9196b0002s22avhalafyx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RxJava/">RxJava</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java8新的异步编程方式CompletableFuture(2)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/14/Java8新的异步编程方式CompletableFuture(2)/" class="article-date">
  <time datetime="2019-05-14T03:46:06.006Z" itemprop="datePublished">2019-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/14/Java8新的异步编程方式CompletableFuture(2)/">Java8新的异步编程方式 CompletableFuture(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/59eae6e4f265da430e4e4cb5" target="_blank" rel="noopener">https://juejin.im/post/59eae6e4f265da430e4e4cb5</a> </p>
</blockquote>
<p><a href="https://juejin.im/post/59eae61b51882549fc512b34" target="_blank" rel="noopener">上一篇文章</a>，讲述了Future模式的机制、缺点，CompletableFuture产生的由来、静态工厂方法、complete()方法等等。</p>
<p>本文将继续整理CompletableFuture的特性。</p>
<h2 id="3-3-转换"><a href="#3-3-转换" class="headerlink" title="3.3 转换"></a>3.3 转换</h2><p>我们可以通过CompletableFuture来异步获取一组数据，并对数据进行一些转换，类似RxJava、Scala的map、flatMap操作。</p>
<h3 id="3-3-1-map"><a href="#3-3-1-map" class="headerlink" title="3.3.1 map"></a>3.3.1 map</h3><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">thenApply(Function&lt;? super T,? extends U&gt; fn)</td>
<td align="center">接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture</td>
</tr>
<tr>
<td align="center">thenApplyAsync(Function&lt;? super T,? extends U&gt; fn)</td>
<td align="center">接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture，使用ForkJoinPool</td>
</tr>
<tr>
<td align="center">thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor)</td>
<td align="center">接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture，使用指定的线程池</td>
</tr>
</tbody></table>
<p>thenApply的功能相当于将CompletableFuture<t>转换成CompletableFuture<u>。
`CompletableFuture<string> future = CompletableFuture.supplyAsync(() -&gt; );</string></u></t></p>
<pre><code>future = future.thenApply( Function&lt;String, String&gt;() {


    {

         s + ;
    }
}).thenApply( Function&lt;String, String&gt;() {

    {

         s.toUpperCase();
    }
});

 {
    System.out.println(future.get());
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>再用lambda表达式简化一下</p>
<p>`CompletableFuture<string> future = CompletableFuture.supplyAsync(() -&gt; )<br>                .thenApply(s -&gt; s + ).thenApply(String::toUpperCase);</string></p>
<pre><code> {
    System.out.println(future.get());
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>执行结果：</p>
<p><code>HELLO WORLD</code></p>
<p>下面的例子，展示了数据流的类型经历了如下的转换：String -&gt; Integer -&gt; Double。</p>
<p>`CompletableFuture<double> future = CompletableFuture.supplyAsync(() -&gt; )<br>                .thenApply(Integer::parseInt)<br>                .thenApply(i-&gt;i*);</double></p>
<pre><code> {
    System.out.println(future.get());
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>执行结果：</p>
<p>``</p>
<h3 id="3-3-2-flatMap"><a href="#3-3-2-flatMap" class="headerlink" title="3.3.2 flatMap"></a>3.3.2 flatMap</h3><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">thenCompose(Function&lt;? super T, ? extends CompletionStage<u>&gt; fn)</u></td>
<td align="center">在异步操作完成的时候对异步操作的结果进行一些操作，并且仍然返回CompletableFuture类型。</td>
</tr>
<tr>
<td align="center">thenComposeAsync(Function&lt;? super T, ? extends CompletionStage<u>&gt; fn)</u></td>
<td align="center">在异步操作完成的时候对异步操作的结果进行一些操作，并且仍然返回CompletableFuture类型。使用ForkJoinPool。</td>
</tr>
<tr>
<td align="center">thenComposeAsync(Function&lt;? super T, ? extends CompletionStage<u>&gt; fn,Executor executor)</u></td>
<td align="center">在异步操作完成的时候对异步操作的结果进行一些操作，并且仍然返回CompletableFuture类型。使用指定的线程池。</td>
</tr>
</tbody></table>
<p>thenCompose可以用于组合多个CompletableFuture，将前一个结果作为下一个计算的参数，它们之间存在着先后顺序。<br>`CompletableFuture<string> future = CompletableFuture.supplyAsync(() -&gt; )<br>                .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + ));</string></p>
<pre><code> {
    System.out.println(future.get());
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>执行结果：</p>
<p><code>Hello World</code></p>
<p>下面的例子展示了多次调用thenCompose()</p>
<p>`CompletableFuture<double> future = CompletableFuture.supplyAsync(() -&gt; )<br>                .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + ))<br>                .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; Double.parseDouble(s)));</double></p>
<pre><code> {
    System.out.println(future.get());
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>执行结果：</p>
<p>``</p>
<h2 id="3-4-组合"><a href="#3-4-组合" class="headerlink" title="3.4 组合"></a>3.4 组合</h2><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">thenCombine(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn)</td>
<td align="center">当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。</td>
</tr>
<tr>
<td align="center">thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn)</td>
<td align="center">当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。使用ForkJoinPool。</td>
</tr>
<tr>
<td align="center">thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn, Executor executor)</td>
<td align="center">当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。使用指定的线程池。</td>
</tr>
</tbody></table>
<p>现在有CompletableFuture<t>、CompletableFuture<u>和一个函数(T,U)-&gt;V，thenCompose就是将CompletableFuture<t>和CompletableFuture<u>变为CompletableFuture<v>。
`CompletableFuture<string> future1 = CompletableFuture.supplyAsync(() -&gt; );<br>        CompletableFuture<integer> future2 = CompletableFuture.supplyAsync(() -&gt; );</integer></string></v></u></t></u></t></p>
<pre><code>CompletableFuture&lt;Double&gt; future = future1.thenCombine(future2, (s, i) -&gt; Double.parseDouble(s + i));

 {
    System.out.println(future.get());
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>执行结果：</p>
<p>``
使用thenCombine()之后future1、future2之间是并行执行的，最后再将结果汇总。这一点跟thenCompose()不同。</p>
<p>thenAcceptBoth跟thenCombine类似，但是返回CompletableFuture类型。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">thenAcceptBoth(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action)</td>
<td align="center">当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。</td>
</tr>
<tr>
<td align="center">thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action)</td>
<td align="center">当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。使用ForkJoinPool。</td>
</tr>
<tr>
<td align="center">thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action, Executor executor)</td>
<td align="center">当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。使用指定的线程池。</td>
</tr>
<tr>
<td align="center">`CompletableFuture<string> future1 = CompletableFuture.supplyAsync(() -&gt; );</string></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">CompletableFuture<integer> future2 = CompletableFuture.supplyAsync(() -&gt; );</integer></td>
<td align="center"></td>
</tr>
</tbody></table>
<pre><code>CompletableFuture&lt;Void&gt; future = future1.thenAcceptBoth(future2, (s, i) -&gt; System.out.println(Double.parseDouble(s + i)));

 {
    future.get();
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>执行结果：</p>
<p>``</p>
<h2 id="3-5-计算结果完成时的处理"><a href="#3-5-计算结果完成时的处理" class="headerlink" title="3.5 计算结果完成时的处理"></a>3.5 计算结果完成时的处理</h2><p>当CompletableFuture完成计算结果后，我们可能需要对结果进行一些处理。</p>
<p>/#/#/#3.5.1 执行特定的Action</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">whenComplete(BiConsumer&lt;? super T,? super Throwable&gt; action)</td>
<td align="center">当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。</td>
</tr>
<tr>
<td align="center">whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action)</td>
<td align="center">当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。使用ForkJoinPool。</td>
</tr>
<tr>
<td align="center">whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action, Executor executor)</td>
<td align="center">当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。使用指定的线程池。</td>
</tr>
<tr>
<td align="center">`CompletableFuture.supplyAsync(() -&gt; )</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">.thenApply(s-&gt;s+)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">.thenApply(s-&gt;s+ )</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">.thenApply(String::toLowerCase)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">.whenComplete((result, throwable) -&gt; System.out.println(result));`</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>执行结果：</p>
<p><code>hello world
 is completablefuture demo</code></p>
<p>/#/#/#3.5.2 执行完Action可以做转换</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)</td>
<td align="center">当CompletableFuture完成计算结果或者抛出异常的时候，执行提供的fn</td>
</tr>
<tr>
<td align="center">handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)</td>
<td align="center">当CompletableFuture完成计算结果或者抛出异常的时候，执行提供的fn，使用ForkJoinPool。</td>
</tr>
<tr>
<td align="center">handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn, Executor executor)</td>
<td align="center">当CompletableFuture完成计算结果或者抛出异常的时候，执行提供的fn，使用指定的线程池。</td>
</tr>
<tr>
<td align="center">`CompletableFuture<double> future = CompletableFuture.supplyAsync(() -&gt; )</double></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">.thenApply(s-&gt;s+)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">.handle((s, t) -&gt; s !=  ? Double.parseDouble(s) : );</td>
<td align="center"></td>
</tr>
</tbody></table>
<pre><code> {
    System.out.println(future.get());
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>执行结果：</p>
<p>``</p>
<p>在这里，handle()的参数是BiFunction，apply()方法返回R，相当于转换的操作。</p>
<p>`{</p>
<pre><code>;


 &lt;V&gt; {
    Objects.requireNonNull(after);
     (T t, U u) -&gt; after.apply(apply(t, u));
}</code></pre><p>}`</p>
<p>而whenComplete()的参数是BiConsumer，accept()方法返回void。</p>
<p>`{</p>
<pre><code>;


{
    Objects.requireNonNull(after);

     (l, r) -&gt; {
        accept(l, r);
        after.accept(l, r);
    };
}</code></pre><p>}`
所以，handle()相当于whenComplete()+转换。</p>
<p>/#/#/#3.5.3 纯消费(执行Action)</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">thenAccept(Consumer&lt;? super T&gt; action)</td>
<td align="center">当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值</td>
</tr>
<tr>
<td align="center">thenAcceptAsync(Consumer&lt;? super T&gt; action)</td>
<td align="center">当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值，使用ForkJoinPool。</td>
</tr>
<tr>
<td align="center">thenAcceptAsync(Consumer&lt;? super T&gt; action, Executor executor)</td>
<td align="center">当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值</td>
</tr>
</tbody></table>
<p>thenAccept()是只会对计算结果进行消费而不会返回任何结果的方法。<br><code>CompletableFuture.supplyAsync(() -&gt; )
                .thenApply(s-&gt;s+)
                .thenApply(s-&gt;s+ )
                .thenApply(String::toLowerCase)
                .thenAccept(System.out::print);</code></p>
<p>执行结果：</p>
<p><code>hello world
 is completablefuture demo</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/14/Java8新的异步编程方式CompletableFuture(2)/" data-id="cjzj9196h0006s22agcwdjpt2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HDFS/">HDFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactor/">Reactor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/">RxJava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue-js/">Vue.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端/">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微服务/">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/HDFS/" style="font-size: 10px;">HDFS</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 13.33px;">MySQL</a> <a href="/tags/Reactor/" style="font-size: 10px;">Reactor</a> <a href="/tags/RxJava/" style="font-size: 10px;">RxJava</a> <a href="/tags/Shell/" style="font-size: 10px;">Shell</a> <a href="/tags/Spring/" style="font-size: 13.33px;">Spring</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP/IP</a> <a href="/tags/Vue-js/" style="font-size: 10px;">Vue.js</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/后端/" style="font-size: 10px;">后端</a> <a href="/tags/微服务/" style="font-size: 10px;">微服务</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/服务器/" style="font-size: 10px;">服务器</a> <a href="/tags/架构/" style="font-size: 16.67px;">架构</a> <a href="/tags/源码/" style="font-size: 10px;">源码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/20/惊！史上最全的select加锁分析(Mysql)/">惊！史上最全的select加锁分析(Mysql)</a>
          </li>
        
          <li>
            <a href="/2019/08/06/万万没想到，JVM内存结构的面试题可以问的这么难？/">万万没想到，JVM内存结构的面试题可以问的这么难？</a>
          </li>
        
          <li>
            <a href="/2019/06/28/分布式数据库中间件MyCat搞起来！/">分布式数据库中间件 MyCat 搞起来！</a>
          </li>
        
          <li>
            <a href="/2019/06/20/Linux生产环境上，最常用的一套“AWK“技巧/">Linux生产环境上，最常用的一套“AWK“技巧</a>
          </li>
        
          <li>
            <a href="/2019/06/18/死磕Java内部类（一篇就够）/">死磕Java内部类（一篇就够）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 huan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>