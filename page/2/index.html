<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>HUAN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="HUAN">
<meta property="og:url" content="http://sillyfan.top/page/2/index.html">
<meta property="og:site_name" content="HUAN">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HUAN">
  
    <link rel="alternate" href="/atom.xml" title="HUAN" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HUAN</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://sillyfan.top"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Token认证，如何快速方便获取用户信息" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/20/Token认证，如何快速方便获取用户信息/" class="article-date">
  <time datetime="2019-05-20T06:31:29.029Z" itemprop="datePublished">2019-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/20/Token认证，如何快速方便获取用户信息/">Token认证，如何快速方便获取用户信息</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5ce0dfb45188250c942f6c1d" target="_blank" rel="noopener">https://juejin.im/post/5ce0dfb45188250c942f6c1d</a> </p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们有一个Web项目，这个项目提供了很多的Rest API。也做了权限控制，访问API的请求必须要带上事先认证后获取的Token才可以。</p>
<p>认证的话就在Filter中进行的，会获取请求的Token进行验证，如果成功了可以得到Token中的用户信息，本文的核心就是讲解如何将用户信息（用户ID）优雅的传递给API接口（Controller）。</p>
<h1 id="方式一（很挫）"><a href="#方式一（很挫）" class="headerlink" title="方式一（很挫）"></a>方式一（很挫）</h1><p>我们在Filter中进行了统一拦截，在Controller中获取用户ID的话，仍然可以再次解析一遍Token获取用户ID</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/hello&quot;)</span><br><span class="line">public String test(HttpServletRequest request) &#123;</span><br><span class="line">    String token = request.getHeader(&quot;token&quot;);</span><br><span class="line">    JWTResult result = JWTUtils.checkToken(token);</span><br><span class="line">    Long userId = result.getUserId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方式二（优雅）"><a href="#方式二（优雅）" class="headerlink" title="方式二（优雅）"></a>方式二（优雅）</h1><p>方式一需要重新解析一遍Token, 浪费资源。我们可以直接将Filter中解析好了的用户ID直接通过Header传递给接口啊。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</span><br><span class="line">			throws IOException, ServletException &#123;</span><br><span class="line">    HttpServletRequest httpRequest = (HttpServletRequest) request;</span><br><span class="line">	HttpServletResponse httpResponse = (HttpServletResponse) response;</span><br><span class="line">    String token = request.getHeader(&quot;token&quot;);</span><br><span class="line">    JWTResult result = JWTUtils.checkToken(token);</span><br><span class="line">    Long userId = result.getUserId();</span><br><span class="line">	HttpServletRequestWrapper requestWrapper = new HttpServletRequestWrapper(httpRequest) &#123;</span><br><span class="line">		@Override</span><br><span class="line">		public String getHeader(String name) &#123;</span><br><span class="line">			if (name.equals(&quot;loginUserId&quot;)) &#123;</span><br><span class="line">				return userId .toString();</span><br><span class="line">			&#125;</span><br><span class="line">			return super.getHeader(name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	chain.doFilter(requestWrapper, httpResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中直接从Header中获取解析好了的用户ID:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/hello&quot;)</span><br><span class="line">public String save2(HttpServletRequest request) &#123;</span><br><span class="line">	Long userId = Long.parseLong(request.getHeader(&quot;loginUserId&quot;));	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方式三（很优雅）"><a href="#方式三（很优雅）" class="headerlink" title="方式三（很优雅）"></a>方式三（很优雅）</h1><p>通过Header传递确实很方便，但如果你有代码洁癖的话总会觉得怪怪的，能不能不用Header方式，比如说我就在方法上定义一个loginUserId的参数，你给我直接注入进来，这个有点意思哈，下面我们来实现下：</p>
<h3 id="GET参数方式"><a href="#GET参数方式" class="headerlink" title="GET参数方式"></a>GET参数方式</h3><p>在Filter中追加参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</span><br><span class="line">			throws IOException, ServletException &#123;</span><br><span class="line">    HttpServletRequest httpRequest = (HttpServletRequest) request;</span><br><span class="line">	HttpServletResponse httpResponse = (HttpServletResponse) response;</span><br><span class="line">    String token = request.getHeader(&quot;token&quot;);</span><br><span class="line">    JWTResult result = JWTUtils.checkToken(token);</span><br><span class="line">    Long userId = result.getUserId();</span><br><span class="line">	HttpServletRequestWrapper requestWrapper = new HttpServletRequestWrapper(httpRequest) &#123;</span><br><span class="line">		    @Override</span><br><span class="line">			public String[] getParameterValues(String name) &#123;</span><br><span class="line">				if (name.equals(&quot;loginUserId&quot;)) &#123;</span><br><span class="line">					return new String[] &#123; userId .toString() &#125;;</span><br><span class="line">				&#125;</span><br><span class="line">				return super.getParameterValues(name);</span><br><span class="line">			&#125;</span><br><span class="line">			@Override</span><br><span class="line">			public Enumeration&lt;String&gt; getParameterNames() &#123;</span><br><span class="line">				Set&lt;String&gt; paramNames = new LinkedHashSet&lt;&gt;();</span><br><span class="line">				paramNames.add(&quot;loginUserId&quot;);</span><br><span class="line">				Enumeration&lt;String&gt; names =  super.getParameterNames();</span><br><span class="line">				while(names.hasMoreElements()) &#123;</span><br><span class="line">					paramNames.add(names.nextElement());</span><br><span class="line">				&#125;</span><br><span class="line">				return Collections.enumeration(paramNames);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	chain.doFilter(requestWrapper, httpResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中直接填写参数即可获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/hello&quot;)</span><br><span class="line">public String save2(String name, Long loginUserId) &#123;</span><br><span class="line">	// loginUserId 就是Filter中追加的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于post请求，也可以用这种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/hello&quot;)</span><br><span class="line">public String save2(User user, Long loginUserId) &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可是往往我们在用post请求的时候，要么就是表单提交，要么就是json体的方式提交，一般不会使用get方式参数，这也就意味着这个loginUserId我们需要注入到对象中：</p>
<p>先创建一个参数实体类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">	private String name;</span><br><span class="line">	</span><br><span class="line">	private Long loginUserId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先模拟表单提交的方式，看看行不行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/hello&quot;)</span><br><span class="line">public User save2(User user) &#123;</span><br><span class="line">	return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用PostMan测试一下，表单方式是直接支持的：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/19/16ace69edcd28f75?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>再次试下Json提交方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/hello&quot;)</span><br><span class="line">public User save2(@RequestBody User user) &#123;</span><br><span class="line">	return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下图，失败了，得重新想办法实现下</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/19/16ace69edcc90ca7?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>只需要在HttpServletRequestWrapper中重新对提交的内容进行修改即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ServletInputStream getInputStream() throws IOException &#123;</span><br><span class="line">	byte[] requestBody = new byte[0];</span><br><span class="line">	try &#123;</span><br><span class="line">		requestBody = StreamUtils.copyToByteArray(request.getInputStream());</span><br><span class="line">		Map map = JsonUtils.toBean(Map.class, new String(requestBody));</span><br><span class="line">		map.put(&quot;loginUserId&quot;, loginUserId);</span><br><span class="line">		requestBody = JsonUtils.toJson(map).getBytes();</span><br><span class="line">	&#125; catch (IOException e) &#123;</span><br><span class="line">		throw new RuntimeException(e);</span><br><span class="line">	&#125;</span><br><span class="line">	final ByteArrayInputStream bais = new ByteArrayInputStream(requestBody);</span><br><span class="line">	return new ServletInputStream() &#123;</span><br><span class="line">		 @Override</span><br><span class="line">		  public int read() throws IOException &#123;</span><br><span class="line">		       return bais.read();</span><br><span class="line">		  &#125;</span><br><span class="line">		 </span><br><span class="line">		  @Override</span><br><span class="line">		   public boolean isFinished() &#123;</span><br><span class="line">		       return false;</span><br><span class="line">		   &#125;</span><br><span class="line">		 </span><br><span class="line">		   @Override</span><br><span class="line">		   public boolean isReady() &#123;</span><br><span class="line">		        return true;</span><br><span class="line">		   &#125;</span><br><span class="line">		 </span><br><span class="line">		   @Override</span><br><span class="line">		    public void setReadListener(ReadListener listener) &#123;</span><br><span class="line">		 </span><br><span class="line">		    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，我们就可以直接将Token解析的用户ID直接注入到参数中了，不用去Header中获取，是不是很方便。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/15/16ab91d71d2ab715?imageView2/0/w/1280/h/960/ignore-error/1" alt="猿天地"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/20/Token认证，如何快速方便获取用户信息/" data-id="cjwkcoov4000jn02a797fe9ki" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-【Spring】Autowired原理及与Resource注解区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/17/【Spring】Autowired原理及与Resource注解区别/" class="article-date">
  <time datetime="2019-05-17T07:03:08.008Z" itemprop="datePublished">2019-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/17/【Spring】Autowired原理及与Resource注解区别/">【Spring】Autowired原理及与Resource注解区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5cde05fae51d454759351d8c" target="_blank" rel="noopener">https://juejin.im/post/5cde05fae51d454759351d8c</a> </p>
</blockquote>
<h2 id="Autowired注解"><a href="#Autowired注解" class="headerlink" title="Autowired注解"></a>Autowired注解</h2><p>Autowired顾名思义，表示自动注入，如下是Autowired注解的源代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Autowired &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Declares whether the annotated dependency is required.</span><br><span class="line">     * &lt;p&gt;Defaults to &#123;@code true&#125;.</span><br><span class="line">     */</span><br><span class="line">    boolean required() default true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从Autowired的实现可以看到，Autowired可以用于类的构造方法，类的字段，类的方法以及注解类型上，但是Autowired不能用于类上面。</p>
<p>关于Autowired注解，有如下问题需要解决：</p>
<ol>
<li><p>Autowired作用在不同的范围上(构造方法，字段、方法)上，它的装配策略如何，按名称还是类型？</p>
</li>
<li><p>为构造方法，字段和方法添加Autowired注解之后，谁来解析这个Autowired注解，完成装配</p>
</li>
<li><p>装配的bean从何处而来，是在Spring的xml文件中定义的bean吗？</p>
</li>
</ol>
<h2 id="从Autowired的javadoc开始"><a href="#从Autowired的javadoc开始" class="headerlink" title="从Autowired的javadoc开始"></a>从Autowired的javadoc开始</h2><p>从Autowired的javadoc中得到如下信息</p>
<ol>
<li><p>AutowiredAnnotationBeanPostProcessor负责扫描Autowired注解，然后完成自动注入</p>
</li>
<li><p>可以对私有的字段使用Autowired进行自动装配，而无需为私有字段定义getter/setter来read/write这个字段</p>
</li>
<li><p>使用Autowired注解的类方法，可以是任意的方法名，任意的参数，Spring会从容器中找到合适的bean进行装配，setter自动注入跟对字段自动注入效果一样</p>
</li>
</ol>
<h2 id="Autowired注解的解析"><a href="#Autowired注解的解析" class="headerlink" title="Autowired注解的解析"></a>Autowired注解的解析</h2><p>当项目中使用了Autowired注解时，需要明确的告诉Spring,配置中引用了自动注入的功能，在Spring的配置文件，做法有两种</p>
<ol>
<li><p>配置AutowiredAnnotationBeanPostProcessor</p>
</li>
<li><p>使用<a href>context:annotation-config/</a>。<a href>context:annotationconfig/</a> 将隐式地向 Spring 容器注册<code>AutowiredAnnotationBeanPostProcessor</code>、<code>CommonAnnotationBeanPostProcessor</code>、<code>PersistenceAnnotationBeanPostProcessor</code>以及<code>RequiredAnnotationBeanPostProcessor</code> 这 4 个 BeanPostProcessor。</p>
</li>
</ol>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="1-实例一："><a href="#1-实例一：" class="headerlink" title="1. 实例一："></a>1. 实例一：</h3><pre><code>* UserSerice依赖的UserDao使用Autowired注解，
* UserDao没有在Spring配置文件中定义</code></pre><p><strong>结果：UserDao为null</strong></p>
<h3 id="2-实例二："><a href="#2-实例二：" class="headerlink" title="2. 实例二："></a>2. 实例二：</h3><pre><code>* UserSerice依赖的UserDao使用Autowired注解
* UserDao在Spring配置文件中有定义</code></pre><p><strong>结果：UserDao为null</strong></p>
<h3 id="3-实例三："><a href="#3-实例三：" class="headerlink" title="3. 实例三："></a>3. 实例三：</h3><pre><code>* UserSerice依赖的UserDao使用Autowired注解
* UserDao在Spring配置文件中有定义
* Spring中使用[context:annotation-config/]()</code></pre><p>/<em>/</em> 结果：UserDao正确注入，在Spring中配置的UserDao的实现，而在UserService中的是UserDao的接口，也就是说，虽然它们类型没有完全匹配，但是由于是实现/<em>/</em></p>
<p><strong>关系，Spring仍然能够完成自动注入</strong></p>
<h3 id="4-实例四："><a href="#4-实例四：" class="headerlink" title="4. 实例四："></a>4. 实例四：</h3><pre><code>* UserSerice依赖的UserDao使用Autowired注解
* UserDao在Spring配置文件中有定义
* Spring中配置AutowiredAnnotationBeanPostProcessor</code></pre><p><strong>结果：UserDao正确注入，同实例三</strong></p>
<h3 id="5-实例五："><a href="#5-实例五：" class="headerlink" title="5. 实例五："></a>5. 实例五：</h3><pre><code>* UserSerice依赖的UserDao使用Autowired注解
* UserDao在Spring配置文件中有两份定义(id不同)
* Spring中使用[context:annotation-config/]()</code></pre><p><strong>结果：</strong></p>
<p><strong>1. 如果UserDao的属性名与某个bean的id相同，那么按照属性名和id名称匹配原则，自动装配</strong></p>
<p><strong>2. 如果UserService中定义的UserDao的属性名，与Spring配置文件中的两个id都不同，那么注入失败，异常抛出，提示，无法完整自动装配</strong></p>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a><strong>结论：</strong></h2><ol>
<li><p>使用Autowired自动装配，必须在Spring的配置文件中使用<a href>context:annotation-config/</a>来告诉Spring需要进行自动装配扫描（AutowiredAnnotationBeanPostProcessor不推荐使用）</p>
</li>
<li><p>Autowired默认按类型进行匹配，当匹配到多个满足条件的bean时，再按照属性名和bean的id进行匹配，如果仍然有多个匹配上或者没有一个匹配上，则抛出异常，提示自动装配失败</p>
</li>
<li><p>在使用Autowired时，可以使用Qualifier注解，显式的指定，当冲突发生时，使用那个id对应的bean</p>
</li>
<li><p>Autowired注解自动装配功能完成的是依赖的自动注入，因此，在一个bean中，它依赖的bean可以通过自动注入的方式完成而不需要显式的为它的属性进行注入。但是这些依赖的bean仍然不能省略，还是要在Spring中进行配置，省略的仅仅是bean属性的注入配置代码</p>
</li>
</ol>
<h2 id="Resource注解"><a href="#Resource注解" class="headerlink" title="Resource注解"></a>Resource注解</h2><p>Resource注解在功能和目的上，等效于Autowried+Qualifier注解，Resource注解是JSR-250规范的一部分，它定义在JDK的javax.annoation包中，如下是它的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">package javax.annotation;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line">import static java.lang.annotation.ElementType.*;</span><br><span class="line">import static java.lang.annotation.RetentionPolicy.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The Resource annotation marks a resource that is needed</span><br><span class="line"> * by the application.  This annotation may be applied to an</span><br><span class="line"> * application component class, or to fields or methods of the</span><br><span class="line"> * component class.  When the annotation is applied to a</span><br><span class="line"> * field or method, the container will inject an instance</span><br><span class="line"> * of the requested resource into the application component</span><br><span class="line"> * when the component is initialized.  If the annotation is</span><br><span class="line"> * applied to the component class, the annotation declares a</span><br><span class="line"> * resource that the application will look up at runtime. &lt;p&gt;</span><br><span class="line"> *</span><br><span class="line"> * Even though this annotation is not marked Inherited, deployment</span><br><span class="line"> * tools are required to examine all superclasses of any component</span><br><span class="line"> * class to discover all uses of this annotation in all superclasses.</span><br><span class="line"> * All such annotation instances specify resources that are needed</span><br><span class="line"> * by the application component.  Note that this annotation may</span><br><span class="line"> * appear on private fields and methods of superclasses; the container</span><br><span class="line"> * is required to perform injection in these cases as well.</span><br><span class="line"> *</span><br><span class="line"> * @since Common Annotations 1.0</span><br><span class="line"> */</span><br><span class="line">@Target(&#123;TYPE, FIELD, METHOD&#125;)</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line">public @interface Resource &#123;</span><br><span class="line">    /**</span><br><span class="line">     * The JNDI name of the resource.  For field annotations,</span><br><span class="line">     * the default is the field name.  For method annotations,</span><br><span class="line">     * the default is the JavaBeans property name corresponding</span><br><span class="line">     * to the method.  For class annotations, there is no default</span><br><span class="line">     * and this must be specified.</span><br><span class="line">     */</span><br><span class="line">    String name() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The name of the resource that the reference points to. It can</span><br><span class="line">     * link to any compatible resource using the global JNDI names.</span><br><span class="line">     *</span><br><span class="line">     * @since Common Annotations 1.1</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    String lookup() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The Java type of the resource.  For field annotations,</span><br><span class="line">     * the default is the type of the field.  For method annotations,</span><br><span class="line">     * the default is the type of the JavaBeans property.</span><br><span class="line">     * For class annotations, there is no default and this must be</span><br><span class="line">     * specified.</span><br><span class="line">     */</span><br><span class="line">    Class&lt;?&gt; type() default java.lang.Object.class;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The two possible authentication types for a resource.</span><br><span class="line">     */</span><br><span class="line">    enum AuthenticationType &#123;</span><br><span class="line">            CONTAINER,</span><br><span class="line">            APPLICATION</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The authentication type to use for this resource.</span><br><span class="line">     * This may be specified for resources representing a</span><br><span class="line">     * connection factory of any supported type, and must</span><br><span class="line">     * not be specified for resources of other types.</span><br><span class="line">     */</span><br><span class="line">    AuthenticationType authenticationType() default AuthenticationType.CONTAINER;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Indicates whether this resource can be shared between</span><br><span class="line">     * this component and other components.</span><br><span class="line">     * This may be specified for resources representing a</span><br><span class="line">     * connection factory of any supported type, and must</span><br><span class="line">     * not be specified for resources of other types.</span><br><span class="line">     */</span><br><span class="line">    boolean shareable() default true;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * A product specific name that this resource should be mapped to.</span><br><span class="line">     * The name of this resource, as defined by the &lt;code&gt;name&lt;/code&gt;</span><br><span class="line">     * element or defaulted, is a name that is local to the application</span><br><span class="line">     * component using the resource.  (It&apos;s a name in the JNDI</span><br><span class="line">     * &lt;code&gt;java:comp/env&lt;/code&gt; namespace.)  Many application servers</span><br><span class="line">     * provide a way to map these local names to names of resources</span><br><span class="line">     * known to the application server.  This mapped name is often a</span><br><span class="line">     * &lt;i&gt;global&lt;/i&gt; JNDI name, but may be a name of any form. &lt;p&gt;</span><br><span class="line">     *</span><br><span class="line">     * Application servers are not required to support any particular</span><br><span class="line">     * form or type of mapped name, nor the ability to use mapped names.</span><br><span class="line">     * The mapped name is product-dependent and often installation-dependent.</span><br><span class="line">     * No use of a mapped name is portable.</span><br><span class="line">     */</span><br><span class="line">    String mappedName() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Description of this resource.  The description is expected</span><br><span class="line">     * to be in the default language of the system on which the</span><br><span class="line">     * application is deployed.  The description can be presented</span><br><span class="line">     * to the Deployer to help in choosing the correct resource.</span><br><span class="line">     */</span><br><span class="line">    String description() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Autowried注解，首先根据类型匹配，如果类型匹配到多个，那么在根据属性名和bean的id进行匹配(可以由Qualifier注解强制匹配指定的bean id)。Resource注解则顺序不同，它有如下几种可能的情况：</p>
<pre><code>* Resource注解指定了name属性和type属性</code></pre><p>策略：首先进行按名称匹配策略： 匹配name属性和bean的id，如果匹配，则判断查找到的bean是否是type属性指定的类型，如果是type属性指定的类型，则匹配成功。如果不是<strong><strong>type属性指定的类型</strong></strong>，则抛出异常，提示匹配失败；如果name属性跟bean的id不匹配，则抛出异常提示没有bean的id匹配name属性</p>
<pre><code>* Resource注解指定了name属性，未指定type属性</code></pre><p>策略：查找bean的id为name属性的bean，查找到，不关心类型为什么，都是匹配成功；如果找不到name属性指定的bean id，则匹配失败，抛出异常</p>
<pre><code>* Resource注解指定了type属性，未指定name属性</code></pre><p>策略：首先进行按名称匹配策略： 匹配属性名和bean的id，如果匹配，则判断查找到的bean是否是type属性指定的类型，如果是type属性指定的类型，则匹配成功。如果不是<strong><strong>type属性指定的类型</strong></strong>，则抛出异常，提示匹配失败；其次进行按类型匹配策略： 如果属性名跟bean的id不匹配，则查找类型为type的bean，如果仅仅找到一个，自动装配成功，其它情况失败。</p>
<pre><code>* Resource注解未指定type属性和name属性</code></pre><p>策略：首先进行按属性名匹配策略，匹配则注入成功；如果属性名不匹配，则进行类型匹配策略，只有为一个类型匹配才成功，其他情况都失败</p>
<h3 id="作者注：欢迎关注笔者公号，定期分享IT互联网、金融等工作经验心得、人生感悟，欢迎交流，目前就职阿里-移动事业部，需要大厂内推的也可到公众号砸简历，或查看我个人资料获取。（公号ID：weknow619）。"><a href="#作者注：欢迎关注笔者公号，定期分享IT互联网、金融等工作经验心得、人生感悟，欢迎交流，目前就职阿里-移动事业部，需要大厂内推的也可到公众号砸简历，或查看我个人资料获取。（公号ID：weknow619）。" class="headerlink" title="作者注：欢迎关注笔者公号，定期分享IT互联网、金融等工作经验心得、人生感悟，欢迎交流，目前就职阿里-移动事业部，需要大厂内推的也可到公众号砸简历，或查看我个人资料获取。（公号ID：weknow619）。"></a>作者注：欢迎关注笔者公号，定期分享IT互联网、金融等工作经验心得、人生感悟，欢迎交流，目前就职阿里-移动事业部，需要大厂内推的也可到公众号砸简历，或查看我个人资料获取。（公号ID：weknow619）。</h3><p><img src="https://user-gold-cdn.xitu.io/2018/9/9/165bc4a503dfcc18?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/17/【Spring】Autowired原理及与Resource注解区别/" data-id="cjwkcoov7000qn02ai15rj3ae" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java的12个语法糖" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/16/Java的12个语法糖/" class="article-date">
  <time datetime="2019-05-16T07:40:26.026Z" itemprop="datePublished">2019-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/16/Java的12个语法糖/">Java的12个语法糖</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5cd8c5e6f265da03555c9d79" target="_blank" rel="noopener">https://juejin.im/post/5cd8c5e6f265da03555c9d79</a> </p>
</blockquote>
<p>GitHub 2.5k Star 的<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fhollischuang%2FtoBeTopJavaer" target="_blank" rel="noopener">Java工程师成神之路</a> ，不来了解一下吗?</p>
<p>GitHub 2.5k Star 的<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fhollischuang%2FtoBeTopJavaer" target="_blank" rel="noopener">Java工程师成神之路</a> ，真的不来了解一下吗?</p>
<p>GitHub 2.5k Star 的<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fhollischuang%2FtoBeTopJavaer" target="_blank" rel="noopener">Java工程师成神之路</a> ，真的确定不来了解一下吗?</p>
<p>本文从 Java 编译原理角度，深入字节码及 class 文件，抽丝剥茧，了解 Java 中的语法糖原理及用法，帮助大家在学会如何使用 Java。</p>
<h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><p>语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。<br>有意思的是，在编程领域，除了语法糖，还有语法盐和语法糖精的说法，篇幅有限这里不做扩展了。</p>
<p>我们所熟知的编程语言中几乎都有语法糖。作者认为，语法糖的多少是评判一个语言够不够牛逼的标准之一。很多人说Java是一个“低糖语言”，其实从Java 7开始Java语言层面上一直在添加各种糖，主要是在“Project Coin”项目下研发。尽管现在Java有人还是认为现在的Java是低糖，未来还会持续向着“高糖”的方向发展。</p>
<h3 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h3><p>前面提到过，语法糖的存在主要是方便开发人员使用。但其实，Java虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。</p>
<p>说到编译，大家肯定都知道，Java语言中，<code>javac</code>命令可以将后缀名为<code>.java</code>的源文件编译为后缀名为<code>.class</code>的可以运行于Java虚拟机的字节码。如果你去看<code>com.sun.tools.javac.main.JavaCompiler</code>的源码，你会发现在<code>compile()</code>中有一个步骤就是调用<code>desugar()</code>，这个方法就是负责解语法糖的实现的。</p>
<p>Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。本文主要来分析下这些语法糖背后的原理。一步一步剥去糖衣，看看其本质。</p>
<h3 id="糖块一、-switch-支持-String-与枚举"><a href="#糖块一、-switch-支持-String-与枚举" class="headerlink" title="糖块一、 switch 支持 String 与枚举"></a>糖块一、 switch 支持 String 与枚举</h3><p>前面提到过，从Java 7 开始，Java语言中的语法糖在逐渐丰富，其中一个比较重要的就是Java 7中<code>switch</code>开始支持<code>String</code>。</p>
<p>在开始coding之前先科普下，Java中的<code>swith</code>自身原本就支持基本类型。比如<code>int</code>、<code>char</code>等。对于<code>int</code>类型，直接进行数值的比较。对于<code>char</code>类型则是比较其ascii码。所以，对于编译器来说，<code>switch</code>中其实只能使用整型，任何类型的比较都要转换成整型。比如<code>byte</code>。<code>short</code>，<code>char</code>(ackii码是整型)以及<code>int</code>。</p>
<p>那么接下来看下<code>switch</code>对<code>String</code>得支持，有以下代码：<br><code>public class switchDemoString {
    public static void main(String[] args) {
        String str = &quot;world&quot;;
        switch (str) {
        case &quot;hello&quot;:
            System.out.println(&quot;hello&quot;);
            break;
        case &quot;world&quot;:
            System.out.println(&quot;world&quot;);
            break;
        default:
            break;
        }
    }
}</code></p>
<p><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F58" target="_blank" rel="noopener">反编译</a>后内容如下：</p>
<p><code>public class switchDemoString
{
    public switchDemoString()
    {
    }
    public static void main(String args[])
    {
        String str = &quot;world&quot;;
        String s;
        switch((s = str).hashCode())
        {
        default:
            break;
        case 99162322:
            if(s.equals(&quot;hello&quot;))
                System.out.println(&quot;hello&quot;);
            break;
        case 113318802:
            if(s.equals(&quot;world&quot;))
                System.out.println(&quot;world&quot;);
            break;
        }
    }
}</code></p>
<p>看到这个代码，你知道原来/<em>/</em>字符串的switch是通过<code>equals()</code>和<code>hashCode()</code>方法来实现的。/<em>/</em>还好<code>hashCode()</code>方法返回的是<code>int</code>，而不是<code>long</code>。</p>
<p>仔细看下可以发现，进行<code>switch</code>的实际是哈希值，然后通过使用<code>equals</code>方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行switch或者使用纯整数常量，但这也不是很差。</p>
<h3 id="糖块二、-泛型"><a href="#糖块二、-泛型" class="headerlink" title="糖块二、 泛型"></a>糖块二、 泛型</h3><p>我们都知道，很多语言都是支持泛型的，但是很多人不知道的是，不同的编译器对于泛型的处理方式是不同的，通常情况下，一个编译器处理泛型有两种方式：<code>Code specialization</code>和<code>Code sharing</code>。C++和C/#是使用<code>Code specialization</code>的处理机制，而Java使用的是<code>Code sharing</code>的机制。<br>Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（<code>type erasue</code>）实现的。</p>
<p>也就是说，<strong>对于Java虚拟机来说，他根本不认识<code>Map&lt;String, String&gt; map</code>这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。</strong></p>
<p>类型擦除的主要过程如下： 1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。 2.移除所有的类型参数。</p>
<p>以下代码：<br><code>Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();  
map.put(&quot;name&quot;, &quot;hollis&quot;);  
map.put(&quot;wechat&quot;, &quot;Hollis&quot;);  
map.put(&quot;blog&quot;, &quot;www.hollischuang.com&quot;);</code></p>
<p>解语法糖之后会变成：</p>
<p><code>Map map = new HashMap();  
map.put(&quot;name&quot;, &quot;hollis&quot;);  
map.put(&quot;wechat&quot;, &quot;Hollis&quot;);  
map.put(&quot;blog&quot;, &quot;www.hollischuang.com&quot;);</code></p>
<p>以下代码：</p>
<p><code>public static &lt;A extends Comparable&lt;A&gt;&gt; A max(Collection&lt;A&gt; xs) {
    Iterator&lt;A&gt; xi = xs.iterator();
    A w = xi.next();
    while (xi.hasNext()) {
        A x = xi.next();
        if (w.compareTo(x) &lt; 0)
            w = x;
    }
    return w;
}</code></p>
<p>类型擦除后会变成：</p>
<p><code>public static Comparable max(Collection xs){
    Iterator xi = xs.iterator();
    Comparable w = (Comparable)xi.next();
    while(xi.hasNext())
    {
        Comparable x = (Comparable)xi.next();
        if(w.compareTo(x) &lt; 0)
            w = x;
    }
    return w;
}</code></p>
<p><strong>虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的<code>Class</code>类对象。比如并不存在<code>List&lt;String&gt;.class</code>或是<code>List&lt;Integer&gt;.class</code>，而只有<code>List.class</code>。</strong></p>
<h3 id="糖块三、-自动装箱与拆箱"><a href="#糖块三、-自动装箱与拆箱" class="headerlink" title="糖块三、 自动装箱与拆箱"></a>糖块三、 自动装箱与拆箱</h3><p>自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。原始类型byte, short, char, int, long, float, double 和 boolean 对应的封装类为Byte, Short, Character, Integer, Long, Float, Double, Boolean。</p>
<p>先来看个自动装箱的代码：<br><code>public static void main(String[] args) {
    int i = 10;
    Integer n = i;
}</code></p>
<p>反编译后代码如下:</p>
<p><code>public static void main(String args[])
{
    int i = 10;
    Integer n = Integer.valueOf(i);
}</code></p>
<p>再来看个自动拆箱的代码：</p>
<p>`public static void main(String[] args) {</p>
<pre><code>Integer i = 10;
int n = i;</code></pre><p>}`</p>
<p>反编译后代码如下：</p>
<p><code>public static void main(String args[])
{
    Integer i = Integer.valueOf(10);
    int n = i.intValue();
}</code></p>
<p>从反编译得到内容可以看出，在装箱的时候自动调用的是<code>Integer</code>的<code>valueOf(int)</code>方法。而在拆箱的时候自动调用的是<code>Integer</code>的<code>intValue</code>方法。</p>
<p>所以，<strong>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。</strong></p>
<h3 id="糖块四-、-方法变长参数"><a href="#糖块四-、-方法变长参数" class="headerlink" title="糖块四 、 方法变长参数"></a>糖块四 、 方法变长参数</h3><p>可变参数(<code>variable arguments</code>)是在Java 1.5中引入的一个特性。它允许一个方法把任意数量的值作为参数。</p>
<p>看下以下可变参数代码，其中print方法接收可变参数：<br>`public static void main(String[] args)<br>    {<br>        print(“Holis”, “公众号:Hollis”, “博客：<a href="http://www.hollischuang.com&quot;" target="_blank" rel="noopener">www.hollischuang.com&quot;</a>, “QQ：907607222”);<br>    }</p>
<p>public static void print(String… strs)<br>{
    for (int i = 0; i &lt; strs.length; i++)<br>    {<br>        System.out.println(strs[i]);<br>    }<br>}`</p>
<p>反编译后代码：</p>
<p>`public static void main(String args[])<br>{
    print(new String[] {<br>        “Holis”, “\u516C\u4F17\u53F7:Hollis”, “\u535A\u5BA2\uFF1A<a href="http://www.hollischuang.com&quot;" target="_blank" rel="noopener">www.hollischuang.com&quot;</a>, “QQ\uFF1A907607222”<br>    });<br>}</p>
<p>public static transient void print(String strs[])<br>{
    for(int i = 0; i &lt; strs.length; i++)<br>        System.out.println(strs[i]);</p>
<p>}`</p>
<p>从反编译后代码可以看出，可变参数在被使用的时候，他首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数，然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。</p>
<p>PS：反编译后的print方法声明中有一个transient标识，是不是很奇怪？transient不是不可以修饰方法吗？transient不是和序列化有关么？transient在这里的作用是什么？因为这个与本文关系不大，这里不做深入分析了。相了解的同学可以关注我微信公众号或者博客。</p>
<h3 id="糖块五-、-枚举"><a href="#糖块五-、-枚举" class="headerlink" title="糖块五 、 枚举"></a>糖块五 、 枚举</h3><p>Java SE5提供了一种新的类型-Java的枚举类型，关键字<code>enum</code>可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。</p>
<p>要想看源码，首先得有一个类吧，那么枚举类型到底是什么类呢？是<code>enum</code>吗？答案很明显不是，<code>enum</code>就和<code>class</code>一样，只是一个关键字，他并不是一个类，那么枚举是由什么类维护的呢，我们简单的写一个枚举：<br><code>public enum t {
    SPRING,SUMMER;
}</code></p>
<p>然后我们使用反编译，看看这段代码到底是怎么实现的，反编译后代码内容如下：</p>
<p>`public final class T extends Enum<br>{
    private T(String s, int i)<br>    {<br>        super(s, i);<br>    }<br>    public static T[] values()<br>    {<br>        T at[];<br>        int i;<br>        T at1[];<br>        System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i);<br>        return at1;<br>    }</p>
<pre><code>public static T valueOf(String s)
{
    return (T)Enum.valueOf(demo/T, s);
}

public static final T SPRING;
public static final T SUMMER;
private static final T ENUM$VALUES[];
static
{
    SPRING = new T(&quot;SPRING&quot;, 0);
    SUMMER = new T(&quot;SUMMER&quot;, 1);
    ENUM$VALUES = (new T[] {
        SPRING, SUMMER
    });
}</code></pre><p>}`</p>
<p>通过反编译后代码我们可以看到，<code>public final class T extends Enum</code>，说明，该类是继承了<code>Enum</code>类的，同时<code>final</code>关键字告诉我们，这个类也是不能被继承的。<strong>当我们使用<code>enmu</code>来定义一个枚举类型的时候，编译器会自动帮我们创建一个<code>final</code>类型的类继承<code>Enum</code>类，所以枚举类型不能被继承。</strong></p>
<h3 id="糖块六-、-内部类"><a href="#糖块六-、-内部类" class="headerlink" title="糖块六 、 内部类"></a>糖块六 、 内部类</h3><p>内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。</p>
<p><strong>内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念，<code>outer.java</code>里面定义了一个内部类<code>inner</code>，一旦编译成功，就会生成两个完全不同的<code>.class</code>文件了，分别是<code>outer.class</code>和<code>outer$inner.class</code>。所以内部类的名字完全可以和它的外部类名字相同。</strong><br>`public class OutterClass {<br>    private String userName;</p>
<pre><code>public String getUserName() {
    return userName;
}

public void setUserName(String userName) {
    this.userName = userName;
}

public static void main(String[] args) {

}

class InnerClass{
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</code></pre><p>}`</p>
<p>以上代码编译后会生成两个class文件：<code>OutterClass$InnerClass.class</code> 、<code>OutterClass.class</code> 。当我们尝试对<code>OutterClass.class</code>文件进行反编译的时候，命令行会打印以下内容：<code>Parsing OutterClass.class...Parsing inner class OutterClass$InnerClass.class... Generating OutterClass.jad</code> 。他会把两个文件全部进行反编译，然后一起生成一个<code>OutterClass.jad</code>文件。文件内容如下：</p>
<p>`public class OutterClass<br>{
    class InnerClass<br>    {<br>        public String getName()<br>        {<br>            return name;<br>        }<br>        public void setName(String name)<br>        {<br>            this.name = name;<br>        }<br>        private String name;<br>        final OutterClass this$0;</p>
<pre><code>    InnerClass()
    {
        this.this$0 = OutterClass.this;
        super();
    }
}

public OutterClass()
{
}
public String getUserName()
{
    return userName;
}
public void setUserName(String userName){
    this.userName = userName;
}
public static void main(String args1[])
{
}
private String userName;</code></pre><p>}`</p>
<h3 id="糖块七-、条件编译"><a href="#糖块七-、条件编译" class="headerlink" title="糖块七 、条件编译"></a>糖块七 、条件编译</h3><p>—般情况下，程序中的每一行代码都要参加编译。但有时候出于对程序代码优化的考虑，希望只对其中一部分内容进行编译，此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。</p>
<p>如在C或CPP中，可以通过预处理语句来实现条件编译。其实在Java中也可实现条件编译。我们先来看一段代码：<br>`public class ConditionalCompilation {<br>    public static void main(String[] args) {<br>        final boolean DEBUG = true;<br>        if(DEBUG) {<br>            System.out.println(“Hello, DEBUG!”);<br>        }</p>
<pre><code>    final boolean ONLINE = false;

    if(ONLINE){
        System.out.println(&quot;Hello, ONLINE!&quot;);
    }
}</code></pre><p>}`</p>
<p>反编译后代码如下：</p>
<p>`public class ConditionalCompilation<br>{</p>
<pre><code>public ConditionalCompilation()
{
}

public static void main(String args[])
{
    boolean DEBUG = true;
    System.out.println(&quot;Hello, DEBUG!&quot;);
    boolean ONLINE = false;
}</code></pre><p>}`</p>
<p>首先，我们发现，在反编译后的代码中没有<code>System.out.println(&quot;Hello, ONLINE!&quot;);</code>，这其实就是条件编译。当<code>if(ONLINE)</code>为false的时候，编译器就没有对其内的代码进行编译。</p>
<p>所以，<strong>Java语法的条件编译，是通过判断条件为常量的if语句实现的。其原理也是Java语言的语法糖。根据if判断条件的真假，编译器直接把分支为false的代码块消除。通过该方式实现的条件编译，必须在方法体内实现，而无法在正整个Java类的结构或者类的属性上进行条件编译，这与C/C++的条件编译相比，确实更有局限性。在Java语言设计之初并没有引入条件编译的功能，虽有局限，但是总比没有更强。</strong></p>
<h3 id="糖块八-、-断言"><a href="#糖块八-、-断言" class="headerlink" title="糖块八 、 断言"></a>糖块八 、 断言</h3><p>在Java中，<code>assert</code>关键字是从JAVA SE 1.4 引入的，为了避免和老版本的Java代码中使用了<code>assert</code>关键字导致错误，Java在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！），如果要开启断言检查，则需要用开关<code>-enableassertions</code>或<code>-ea</code>来开启。</p>
<p>看一段包含断言的代码：<br><code>public class AssertTest {
    public static void main(String args[]) {
        int a = 1;
        int b = 1;
        assert a == b;
        System.out.println(&quot;公众号：Hollis&quot;);
        assert a != b : &quot;Hollis&quot;;
        System.out.println(&quot;博客：www.hollischuang.com&quot;);
    }
}</code></p>
<p>反编译后代码如下：</p>
<p>`public class AssertTest {<br>   public AssertTest()<br>    {<br>    }<br>    public static void main(String args[])<br>{
    int a = 1;<br>    int b = 1;<br>    if(!$assertionsDisabled &amp;&amp; a != b)<br>        throw new AssertionError();<br>    System.out.println(“\u516C\u4F17\u53F7\uFF1AHollis”);<br>    if(!$assertionsDisabled &amp;&amp; a == b)<br>    {<br>        throw new AssertionError(“Hollis”);<br>    } else<br>    {<br>        System.out.println(“\u535A\u5BA2\uFF1A<a href="http://www.hollischuang.com&quot;" target="_blank" rel="noopener">www.hollischuang.com&quot;</a>);<br>        return;<br>    }<br>}</p>
<p>static final boolean $assertionsDisabled = !com/hollis/suguar/AssertTest.desiredAssertionStatus();</p>
<p>}`</p>
<p>很明显，反编译之后的代码要比我们自己的代码复杂的多。所以，使用了assert这个语法糖我们节省了很多代码。<strong>其实断言的底层实现就是if语言，如果断言结果为true，则什么都不做，程序继续执行，如果断言结果为false，则程序抛出AssertError来打断程序的执行。</strong><code>-enableassertions</code>会设置$assertionsDisabled字段的值。</p>
<h3 id="糖块九-、-数值字面量"><a href="#糖块九-、-数值字面量" class="headerlink" title="糖块九 、 数值字面量"></a>糖块九 、 数值字面量</h3><p>在java 7中，数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。这些下划线不会对字面量的数值产生影响，目的就是方便阅读。</p>
<p>比如：<br><code>public class Test {
    public static void main(String... args) {
        int i = 10_000;
        System.out.println(i);
    }
}</code></p>
<p>反编译后：</p>
<p><code>public class Test
{
  public static void main(String[] args)
  {
    int i = 10000;
    System.out.println(i);
  }
}</code></p>
<p>反编译后就是把<code>_</code>删除了。也就是说 <strong>编译器并不认识在数字字面量中的<code>_</code>，需要在编译阶段把他去掉。</strong></p>
<h3 id="糖块十-、-for-each"><a href="#糖块十-、-for-each" class="headerlink" title="糖块十 、 for-each"></a>糖块十 、 for-each</h3><p>增强for循环（<code>for-each</code>）相信大家都不陌生，日常开发经常会用到的，他会比for循环要少写很多代码，那么这个语法糖背后是如何实现的呢？<br><code>public static void main(String... args) {
    String[] strs = {&quot;Hollis&quot;, &quot;公众号：Hollis&quot;, &quot;博客：www.hollischuang.com&quot;};
    for (String s : strs) {
        System.out.println(s);
    }
    List&lt;String&gt; strList = ImmutableList.of(&quot;Hollis&quot;, &quot;公众号：Hollis&quot;, &quot;博客：www.hollischuang.com&quot;);
    for (String s : strList) {
        System.out.println(s);
    }
}</code></p>
<p>反编译后代码如下：</p>
<p>`public static transient void main(String args[])<br>{
    String strs[] = {<br>        “Hollis”, “\u516C\u4F17\u53F7\uFF1AHollis”, “\u535A\u5BA2\uFF1A<a href="http://www.hollischuang.com&quot;" target="_blank" rel="noopener">www.hollischuang.com&quot;</a><br>    };<br>    String args1[] = strs;<br>    int i = args1.length;<br>    for(int j = 0; j &lt; i; j++)<br>    {<br>        String s = args1[j];<br>        System.out.println(s);<br>    }</p>
<pre><code>List strList = ImmutableList.of(&quot;Hollis&quot;, &quot;\u516C\u4F17\u53F7\uFF1AHollis&quot;, &quot;\u535A\u5BA2\uFF1Awww.hollischuang.com&quot;);
String s;
for(Iterator iterator = strList.iterator(); iterator.hasNext(); System.out.println(s))
    s = (String)iterator.next();</code></pre><p>}`</p>
<p>代码很简单，<strong>for-each的实现原理其实就是使用了普通的for循环和迭代器。</strong></p>
<h3 id="糖块十一-、-try-with-resource"><a href="#糖块十一-、-try-with-resource" class="headerlink" title="糖块十一 、 try-with-resource"></a>糖块十一 、 try-with-resource</h3><p>Java里，对于文件操作IO流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过close方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄露等问题。</p>
<p>关闭资源的常用方式就是在<code>finally</code>块里是释放，即调用<code>close</code>方法。比如，我们经常会写这样的代码：<br><code>public static void main(String[] args) {
    BufferedReader br = null;
    try {
        String line;
        br = new BufferedReader(new FileReader(&quot;d:\\hollischuang.xml&quot;));
        while ((line = br.readLine()) != null) {
            System.out.println(line);
        }
    } catch (IOException e) {
        // handle exception
    } finally {
        try {
            if (br != null) {
                br.close();
            }
        } catch (IOException ex) {
            // handle exception
        }
    }
}</code></p>
<p>从Java 7开始，jdk提供了一种更好的方式关闭资源，使用<code>try-with-resources</code>语句，改写一下上面的代码，效果如下：</p>
<p><code>public static void main(String... args) {
    try (BufferedReader br = new BufferedReader(new FileReader(&quot;d:\\ hollischuang.xml&quot;))) {
        String line;
        while ((line = br.readLine()) != null) {
            System.out.println(line);
        }
    } catch (IOException e) {
        // handle exception
    }
}</code></p>
<p>看，这简直是一大福音啊，虽然我之前一般使用<code>IOUtils</code>去关闭流，并不会使用在<code>finally</code>中写很多代码的方式，但是这种新的语法糖看上去好像优雅很多呢。看下他的背后：</p>
<p><code>public static transient void main(String args[])
    {
        BufferedReader br;
        Throwable throwable;
        br = new BufferedReader(new FileReader(&quot;d:\\ hollischuang.xml&quot;));
        throwable = null;
        String line;
        try
        {
            while((line = br.readLine()) != null)
                System.out.println(line);
        }
        catch(Throwable throwable2)
        {
            throwable = throwable2;
            throw throwable2;
        }
        if(br != null)
            if(throwable != null)
                try
                {
                    br.close();
                }
                catch(Throwable throwable1)
                {
                    throwable.addSuppressed(throwable1);
                }
            else
                br.close();
            break MISSING_BLOCK_LABEL_113;
            Exception exception;
            exception;
            if(br != null)
                if(throwable != null)
                    try
                    {
                        br.close();
                    }
                    catch(Throwable throwable3)
                      {
                        throwable.addSuppressed(throwable3);
                    }
                else
                    br.close();
        throw exception;
        IOException ioexception;
        ioexception;
    }
}</code></p>
<p><strong>其实背后的原理也很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。所以，再次印证了，语法糖的作用就是方便程序员的使用，但最终还是要转成编译器认识的语言。</strong></p>
<h3 id="糖块十二、Lambda表达式"><a href="#糖块十二、Lambda表达式" class="headerlink" title="糖块十二、Lambda表达式"></a>糖块十二、Lambda表达式</h3><p>关于lambda表达式，有人可能会有质疑，因为网上有人说他并不是语法糖。其实我想纠正下这个说法。<strong>Labmda表达式不是匿名内部类的语法糖，但是他也是一个语法糖。实现方式其实是依赖了几个JVM底层提供的lambda相关api。</strong></p>
<p>先来看一个简单的lambda表达式。遍历一个list：<br>`public static void main(String… args) {<br>    List<string> strList = ImmutableList.of(“Hollis”, “公众号：Hollis”, “博客：<a href="http://www.hollischuang.com&quot;" target="_blank" rel="noopener">www.hollischuang.com&quot;</a>);</string></p>
<pre><code>strList.forEach( s -&gt; { System.out.println(s); } );</code></pre><p>}`</p>
<p>为啥说他并不是内部类的语法糖呢，前面讲内部类我们说过，内部类在编译之后会有两个class文件，但是，包含lambda表达式的类编译后只有一个文件。</p>
<p>反编译后代码如下:<br>`public static /* varargs */ void main(String … args) {<br>    ImmutableList strList = ImmutableList.of((Object)”Hollis”, (Object)”\u516c\u4f17\u53f7\uff1aHollis”, (Object)”\u535a\u5ba2\uff1a<a href="http://www.hollischuang.com&quot;" target="_blank" rel="noopener">www.hollischuang.com&quot;</a>);<br>    strList.forEach((Consumer<string>)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$0(java.lang.String ), (Ljava/lang/String;)V)());<br>}</string></p>
<p>private static /* synthetic */ void lambda$main$0(String s) {<br>    System.out.println(s);<br>}`</p>
<p>可以看到，在<code>forEach</code>方法中，其实是调用了<code>java.lang.invoke.LambdaMetafactory#metafactory</code>方法，该方法的第四个参数implMethod指定了方法实现。可以看到这里其实是调用了一个<code>lambda$main$0</code>方法进行了输出。</p>
<p>再来看一个稍微复杂一点的，先对List进行过滤，然后再输出：<br>`public static void main(String… args) {<br>    List<string> strList = ImmutableList.of(“Hollis”, “公众号：Hollis”, “博客：<a href="http://www.hollischuang.com&quot;" target="_blank" rel="noopener">www.hollischuang.com&quot;</a>);</string></p>
<pre><code>List HollisList = strList.stream().filter(string -&gt; string.contains(&quot;Hollis&quot;)).collect(Collectors.toList());

HollisList.forEach( s -&gt; { System.out.println(s); } );</code></pre><p>}`</p>
<p>反编译后代码如下：</p>
<p>`public static /* varargs */ void main(String … args) {<br>    ImmutableList strList = ImmutableList.of((Object)”Hollis”, (Object)”\u516c\u4f17\u53f7\uff1aHollis”, (Object)”\u535a\u5ba2\uff1a<a href="http://www.hollischuang.com&quot;" target="_blank" rel="noopener">www.hollischuang.com&quot;</a>);<br>    List<object> HollisList = strList.stream().filter((Predicate<string>)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)Z, lambda$main$0(java.lang.String ), (Ljava/lang/String;)Z)()).collect(Collectors.toList());<br>    HollisList.forEach((Consumer<object>)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$1(java.lang.Object ), (Ljava/lang/Object;)V)());<br>}</object></string></object></p>
<p>private static /* synthetic */ void lambda$main$1(Object s) {<br>    System.out.println(s);<br>}</p>
<p>private static /* synthetic */ boolean lambda$main$0(String string) {<br>    return string.contains(“Hollis”);<br>}`</p>
<p>两个lambda表达式分别调用了<code>lambda$main$1</code>和<code>lambda$main$0</code>两个方法。</p>
<p><strong>所以，lambda表达式的实现其实是依赖了一些底层的api，在编译阶段，编译器会把lambda表达式进行解糖，转换成调用内部api的方式。</strong></p>
<h3 id="可能遇到的坑"><a href="#可能遇到的坑" class="headerlink" title="可能遇到的坑"></a>可能遇到的坑</h3><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p><strong>一、当泛型遇到重载</strong> public class GenericTypes {<br>`public static void method(List<string> list) {<br>        System.out.println(“invoke method(List<string> list)”);<br>    }  </string></string></p>
<pre><code>public static void method(List&lt;Integer&gt; list) {  
    System.out.println(&quot;invoke method(List&lt;Integer&gt; list)&quot;);  
}  </code></pre><p>}`</p>
<p>上面这段代码，有两个重载的函数，因为他们的参数类型不同，一个是List另一个是List ，但是，这段代码是编译通不过的。因为我们前面讲过，参数List和List编译之后都被擦除了，变成了一样的原生类型List，擦除动作导致这两个方法的特征签名变得一模一样。</p>
<p><strong>二、当泛型遇到catch</strong> 泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型<code>MyException&lt;String&gt;</code>和<code>MyException&lt;Integer&gt;</code>的</p>
<p><strong>三、当泛型内包含静态变量</strong><br><code>public class StaticTest{
    public static void main(String[] args){
        GT&lt;Integer&gt; gti = new GT&lt;Integer&gt;();
        gti.var=1;
        GT&lt;String&gt; gts = new GT&lt;String&gt;();
        gts.var=2;
        System.out.println(gti.var);
    }
}
class GT&lt;T&gt;{
    public static int var=0;
    public void nothing(T x){}
}</code></p>
<p>以上代码输出结果为：2！由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的。</p>
<h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><p><strong>对象相等比较</strong></p>
<p>public class BoxingTest {<br><code>public static void main(String[] args) {
    Integer a = 1000;
    Integer b = 1000;
    Integer c = 100;
    Integer d = 100;
    System.out.println(&quot;a == b is &quot; + (a == b));
    System.out.println((&quot;c == d is &quot; + (c == d)));
}</code></p>
<p>输出结果：</p>
<p><code>a == b is false
c == d is true</code></p>
<p>在Java 5中，在Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。</p>
<p>适用于整数值区间-128 至 +127。</p>
<p>只适用于自动装箱。使用构造函数创建对象不适用。</p>
<h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><p><strong>ConcurrentModificationException</strong><br><code>for (Student stu : students) {    
    if (stu.getId() == 2)     
        students.remove(stu);    
}</code></p>
<p>会抛出<code>ConcurrentModificationException</code>异常。</p>
<p>Iterator是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出<code>java.util.ConcurrentModificationException</code>异常。</p>
<p>所以 <code>Iterator</code> 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 <code>Iterator</code> 本身的方法<code>remove()</code>来删除对象，<code>Iterator.remove()</code> 方法会在删除当前迭代对象的同时维护索引的一致性。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前面介绍了12种Java中常用的语法糖。所谓语法糖就是提供给开发人员便于开发的一种语法而已。但是这种语法只有开发人员认识。要想被执行，需要进行解糖，即转成JVM认识的语法。当我们把语法糖解糖之后，你就会发现其实我们日常使用的这些方便的语法，其实都是一些其他更简单的语法构成的。</p>
<p>有了这些语法糖，我们在日常开发的时候可以大大提升效率，但是同时也要避免过渡使用。使用之前最好了解下原理，避免掉坑。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/13/16aaec8209852aa9?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>参考资料： <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F58" target="_blank" rel="noopener">Java的反编译</a> <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F61" target="_blank" rel="noopener">Java中的Switch对整型、字符型、字符串型的具体实现细节</a> <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F197" target="_blank" rel="noopener">深度分析Java的枚举类型—-枚举的线程安全性及序列化问题</a> <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F195" target="_blank" rel="noopener">Java的枚举类型用法介绍</a> <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F1776" target="_blank" rel="noopener">Java中的增强for循环（for each）的实现原理与坑</a> <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F230" target="_blank" rel="noopener">Java中泛型的理解</a> <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F1174" target="_blank" rel="noopener">Java中整型的缓存机制</a> <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F1271" target="_blank" rel="noopener">Java中的可变参数</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/16/Java的12个语法糖/" data-id="cjwkcoouy000bn02atnbcfesh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java8新的异步编程方式CompletableFuture(3)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/14/Java8新的异步编程方式CompletableFuture(3)/" class="article-date">
  <time datetime="2019-05-14T03:46:27.027Z" itemprop="datePublished">2019-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/14/Java8新的异步编程方式CompletableFuture(3)/">Java8新的异步编程方式 CompletableFuture(三)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/59eae7636fb9a045117044c6" target="_blank" rel="noopener">https://juejin.im/post/59eae7636fb9a045117044c6</a> </p>
</blockquote>
<p>前面两篇文章已经整理了CompletableFuture大部分的特性，本文会整理完CompletableFuture余下的特性，以及将它跟RxJava进行比较。</p>
<h2 id="3-6-Either"><a href="#3-6-Either" class="headerlink" title="3.6 Either"></a>3.6 Either</h2><p>Either 表示的是两个CompletableFuture，当其中任意一个CompletableFuture计算完成的时候就会执行。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">acceptEither(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)</td>
<td align="center">当任意一个CompletableFuture完成的时候，action这个消费者就会被执行。</td>
</tr>
<tr>
<td align="center">acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)</td>
<td align="center">当任意一个CompletableFuture完成的时候，action这个消费者就会被执行。使用ForkJoinPool</td>
</tr>
<tr>
<td align="center">acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action, Executor executor)</td>
<td align="center">当任意一个CompletableFuture完成的时候，action这个消费者就会被执行。使用指定的线程池</td>
</tr>
<tr>
<td align="center">`Random random =  Random();</td>
<td align="center"></td>
</tr>
</tbody></table>
<pre><code>CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(()-&gt;{

     {
        Thread.sleep(random.nextInt());
    }  (InterruptedException e) {
        e.printStackTrace();
    }

     ;
});

CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(()-&gt;{

     {
        Thread.sleep(random.nextInt());
    }  (InterruptedException e) {
        e.printStackTrace();
    }

     ;
});

CompletableFuture&lt;Void&gt; future =  future1.acceptEither(future2,str-&gt;System.out.println(+str));

 {
    future.get();
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>执行结果：The future is from future1 或者 The future is from future2。<br>因为future1和future2，执行的顺序是随机的。</p>
<p>applyToEither 跟 acceptEither 类似。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">applyToEither(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn)</td>
<td align="center">当任意一个CompletableFuture完成的时候，fn会被执行，它的返回值会当作新的CompletableFuture<u>的计算结果。</u></td>
</tr>
<tr>
<td align="center">applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn)</td>
<td align="center">当任意一个CompletableFuture完成的时候，fn会被执行，它的返回值会当作新的CompletableFuture<u>的计算结果。使用ForkJoinPool</u></td>
</tr>
<tr>
<td align="center">applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn, Executor executor)</td>
<td align="center">当任意一个CompletableFuture完成的时候，fn会被执行，它的返回值会当作新的CompletableFuture<u>的计算结果。使用指定的线程池</u></td>
</tr>
<tr>
<td align="center">`Random random =  Random();</td>
<td align="center"></td>
</tr>
</tbody></table>
<pre><code>CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(()-&gt;{

     {
        Thread.sleep(random.nextInt());
    }  (InterruptedException e) {
        e.printStackTrace();
    }

     ;
});

CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(()-&gt;{

     {
        Thread.sleep(random.nextInt());
    }  (InterruptedException e) {
        e.printStackTrace();
    }

     ;
});

CompletableFuture&lt;String&gt; future =  future1.applyToEither(future2,str-&gt;+str);

 {
    System.out.println(future.get());
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>执行结果也跟上面的程序类似。</p>
<h2 id="3-7-其他方法"><a href="#3-7-其他方法" class="headerlink" title="3.7 其他方法"></a>3.7 其他方法</h2><p>allOf、anyOf是CompletableFuture的静态方法。</p>
<h3 id="3-7-1-allOf"><a href="#3-7-1-allOf" class="headerlink" title="3.7.1 allOf"></a>3.7.1 allOf</h3><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">allOf(CompletableFuture&lt;?&gt;… cfs)</td>
<td align="center">在所有Future对象完成后结束，并返回一个future。</td>
</tr>
</tbody></table>
<p>allOf()方法所返回的CompletableFuture，并不能组合前面多个CompletableFuture的计算结果。于是我们借助Java 8的Stream来组合多个future的结果。<br>`CompletableFuture<string> future1 = CompletableFuture.supplyAsync(() -&gt; );</string></p>
<pre><code>CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; );

CompletableFuture&lt;String&gt; future3 = CompletableFuture.supplyAsync(() -&gt; );

CompletableFuture.allOf(future1, future2, future3)
        .thenApply(v -&gt;
        Stream.of(future1, future2, future3)
                .map(CompletableFuture::join)
                .collect(Collectors.joining()))
        .thenAccept(System.out::print);`</code></pre><p>执行结果：</p>
<p><code>tony cafei aaron</code></p>
<h3 id="3-7-2-anyOf"><a href="#3-7-2-anyOf" class="headerlink" title="3.7.2 anyOf"></a>3.7.2 anyOf</h3><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">anyOf(CompletableFuture&lt;?&gt;… cfs)</td>
<td align="center">在任何一个Future对象结束后结束，并返回一个future。</td>
</tr>
<tr>
<td align="center">`Random rand =  Random();</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">CompletableFuture<string> future1 = CompletableFuture.supplyAsync(() -&gt; {</string></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">{</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Thread.sleep(rand.nextInt());</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">}  (InterruptedException e) {</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">e.printStackTrace();</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">}</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">});</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">CompletableFuture<string> future2 = CompletableFuture.supplyAsync(() -&gt; {</string></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">{</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Thread.sleep(rand.nextInt());</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">}  (InterruptedException e) {</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">e.printStackTrace();</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">}</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">});</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">CompletableFuture<string> future3 = CompletableFuture.supplyAsync(() -&gt; {</string></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">{</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Thread.sleep(rand.nextInt());</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">}  (InterruptedException e) {</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">e.printStackTrace();</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">}</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">});</td>
<td align="center"></td>
</tr>
</tbody></table>
<pre><code>CompletableFuture&lt;Object&gt; future =  CompletableFuture.anyOf(future1,future2,future3);

 {
    System.out.println(future.get());
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>使用anyOf()时，只要某一个future完成，就结束了。所以执行结果可能是”from future1”、”from future2”、”from future3”中的任意一个。</p>
<p>anyOf 和 acceptEither、applyToEither的区别在于，后两者只能使用在两个future中，而anyOf可以使用在多个future中。</p>
<h2 id="3-8-CompletableFuture异常处理"><a href="#3-8-CompletableFuture异常处理" class="headerlink" title="3.8 CompletableFuture异常处理"></a>3.8 CompletableFuture异常处理</h2><p>CompletableFuture在运行时如果遇到异常，可以使用get()并抛出异常进行处理，但这并不是一个最好的方法。CompletableFuture本身也提供了几种方式来处理异常。</p>
<h3 id="3-8-1-exceptionally"><a href="#3-8-1-exceptionally" class="headerlink" title="3.8.1 exceptionally"></a>3.8.1 exceptionally</h3><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">exceptionally(Function fn)</td>
<td align="center">只有当CompletableFuture抛出异常的时候，才会触发这个exceptionally的计算，调用function计算值。</td>
</tr>
<tr>
<td align="center">`CompletableFuture.supplyAsync(() -&gt; )</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">.thenApply(s -&gt; {</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">s = ;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">length = s.length();</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">length;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">}).thenAccept(i -&gt; System.out.println(i))</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">.exceptionally(t -&gt; {</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">System.out.println( + t);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">});`</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>执行结果：</p>
<p><code>Unexpected error:java.util.concurrent.CompletionException: java.lang.NullPointerException</code></p>
<p>对上面的代码稍微做了一下修改，修复了空指针的异常。</p>
<p>`CompletableFuture.supplyAsync(() -&gt; )<br>                .thenApply(s -&gt; {</p>
<pre><code>     length = s.length();
     length;
}).thenAccept(i -&gt; System.out.println(i))
.exceptionally(t -&gt; {
    System.out.println( + t);
     ;
});`</code></pre><p>执行结果：</p>
<p>``</p>
<h3 id="3-8-2-whenComplete"><a href="#3-8-2-whenComplete" class="headerlink" title="3.8.2 whenComplete"></a>3.8.2 whenComplete</h3><p>whenComplete 在上一篇文章其实已经介绍过了，在这里跟exceptionally的作用差不多，可以捕获任意阶段的异常。如果没有异常的话，就执行action。<br>`CompletableFuture.supplyAsync(() -&gt; )<br>                .thenApply(s -&gt; {<br>                    s = ;<br>                     length = s.length();<br>                     length;<br>                }).thenAccept(i -&gt; System.out.println(i))<br>                .whenComplete((result, throwable) -&gt; {</p>
<pre><code>     (throwable != ) {
       System.out.println(+throwable);
    }  {
        System.out.println(result);
    }

});`</code></pre><p>执行结果：</p>
<p><code>Unexpected error:java.util.concurrent.CompletionException: java.lang.NullPointerException</code></p>
<p>跟whenComplete相似的方法是handle，handle的用法在上一篇文章中也已经介绍过。</p>
<h1 id="四-CompletableFuture-VS-Java8-Stream-VS-RxJava1-amp-RxJava2"><a href="#四-CompletableFuture-VS-Java8-Stream-VS-RxJava1-amp-RxJava2" class="headerlink" title="四. CompletableFuture VS Java8 Stream VS RxJava1 &amp; RxJava2"></a>四. CompletableFuture VS Java8 Stream VS RxJava1 &amp; RxJava2</h1><p>CompletableFuture 有很多特性跟RxJava很像，所以将CompletableFuture、Java 8 Stream和RxJava做一个相互的比较。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">composable</th>
<th align="center">lazy</th>
<th align="center">resuable</th>
<th align="center">async</th>
<th align="center">cached</th>
<th align="center">push</th>
<th align="center">back pressure</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CompletableFuture</td>
<td align="center">支持</td>
<td align="center">不支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">Stream</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">Observable(RxJava1)</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">Observable(RxJava2)</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">Flowable(RxJava2)</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
</tbody></table>
<h1 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h1><p>Java 8提供了一种函数风格的异步和事件驱动编程模型CompletableFuture，它不会造成堵塞。CompletableFuture背后依靠的是fork/join框架来启动新的线程实现异步与并发。当然，我们也能通过指定线程池来做这些事情。</p>
<p>CompletableFuture特别是对微服务架构而言，会有很大的作为。举一个具体的场景，电商的商品页面可能会涉及到商品详情服务、商品评论服务、相关商品推荐服务等等。获取商品的信息时（/productdetails?productid=xxx），需要调用多个服务来处理这一个请求并返回结果。这里可能会涉及到并发编程，我们完全可以使用Java 8的CompletableFuture或者RxJava来实现。</p>
<p>先前的文章：<br><a href="https://juejin.im/post/59eae61b51882549fc512b34" target="_blank" rel="noopener">Java8新的异步编程方式 CompletableFuture(一)</a><br><a href="https://juejin.im/post/59eae6e4f265da430e4e4cb5" target="_blank" rel="noopener">Java8新的异步编程方式 CompletableFuture(二)</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/14/Java8新的异步编程方式CompletableFuture(3)/" data-id="cjwkcoow9002ln02aczvqhite" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RxJava/">RxJava</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java8新的异步编程方式CompletableFuture(2)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/14/Java8新的异步编程方式CompletableFuture(2)/" class="article-date">
  <time datetime="2019-05-14T03:46:06.006Z" itemprop="datePublished">2019-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/14/Java8新的异步编程方式CompletableFuture(2)/">Java8新的异步编程方式 CompletableFuture(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/59eae6e4f265da430e4e4cb5" target="_blank" rel="noopener">https://juejin.im/post/59eae6e4f265da430e4e4cb5</a> </p>
</blockquote>
<p><a href="https://juejin.im/post/59eae61b51882549fc512b34" target="_blank" rel="noopener">上一篇文章</a>，讲述了Future模式的机制、缺点，CompletableFuture产生的由来、静态工厂方法、complete()方法等等。</p>
<p>本文将继续整理CompletableFuture的特性。</p>
<h2 id="3-3-转换"><a href="#3-3-转换" class="headerlink" title="3.3 转换"></a>3.3 转换</h2><p>我们可以通过CompletableFuture来异步获取一组数据，并对数据进行一些转换，类似RxJava、Scala的map、flatMap操作。</p>
<h3 id="3-3-1-map"><a href="#3-3-1-map" class="headerlink" title="3.3.1 map"></a>3.3.1 map</h3><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">thenApply(Function&lt;? super T,? extends U&gt; fn)</td>
<td align="center">接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture</td>
</tr>
<tr>
<td align="center">thenApplyAsync(Function&lt;? super T,? extends U&gt; fn)</td>
<td align="center">接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture，使用ForkJoinPool</td>
</tr>
<tr>
<td align="center">thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor)</td>
<td align="center">接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture，使用指定的线程池</td>
</tr>
</tbody></table>
<p>thenApply的功能相当于将CompletableFuture<t>转换成CompletableFuture<u>。
`CompletableFuture<string> future = CompletableFuture.supplyAsync(() -&gt; );</string></u></t></p>
<pre><code>future = future.thenApply( Function&lt;String, String&gt;() {


    {

         s + ;
    }
}).thenApply( Function&lt;String, String&gt;() {

    {

         s.toUpperCase();
    }
});

 {
    System.out.println(future.get());
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>再用lambda表达式简化一下</p>
<p>`CompletableFuture<string> future = CompletableFuture.supplyAsync(() -&gt; )<br>                .thenApply(s -&gt; s + ).thenApply(String::toUpperCase);</string></p>
<pre><code> {
    System.out.println(future.get());
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>执行结果：</p>
<p><code>HELLO WORLD</code></p>
<p>下面的例子，展示了数据流的类型经历了如下的转换：String -&gt; Integer -&gt; Double。</p>
<p>`CompletableFuture<double> future = CompletableFuture.supplyAsync(() -&gt; )<br>                .thenApply(Integer::parseInt)<br>                .thenApply(i-&gt;i*);</double></p>
<pre><code> {
    System.out.println(future.get());
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>执行结果：</p>
<p>``</p>
<h3 id="3-3-2-flatMap"><a href="#3-3-2-flatMap" class="headerlink" title="3.3.2 flatMap"></a>3.3.2 flatMap</h3><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">thenCompose(Function&lt;? super T, ? extends CompletionStage<u>&gt; fn)</u></td>
<td align="center">在异步操作完成的时候对异步操作的结果进行一些操作，并且仍然返回CompletableFuture类型。</td>
</tr>
<tr>
<td align="center">thenComposeAsync(Function&lt;? super T, ? extends CompletionStage<u>&gt; fn)</u></td>
<td align="center">在异步操作完成的时候对异步操作的结果进行一些操作，并且仍然返回CompletableFuture类型。使用ForkJoinPool。</td>
</tr>
<tr>
<td align="center">thenComposeAsync(Function&lt;? super T, ? extends CompletionStage<u>&gt; fn,Executor executor)</u></td>
<td align="center">在异步操作完成的时候对异步操作的结果进行一些操作，并且仍然返回CompletableFuture类型。使用指定的线程池。</td>
</tr>
</tbody></table>
<p>thenCompose可以用于组合多个CompletableFuture，将前一个结果作为下一个计算的参数，它们之间存在着先后顺序。<br>`CompletableFuture<string> future = CompletableFuture.supplyAsync(() -&gt; )<br>                .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + ));</string></p>
<pre><code> {
    System.out.println(future.get());
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>执行结果：</p>
<p><code>Hello World</code></p>
<p>下面的例子展示了多次调用thenCompose()</p>
<p>`CompletableFuture<double> future = CompletableFuture.supplyAsync(() -&gt; )<br>                .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + ))<br>                .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; Double.parseDouble(s)));</double></p>
<pre><code> {
    System.out.println(future.get());
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>执行结果：</p>
<p>``</p>
<h2 id="3-4-组合"><a href="#3-4-组合" class="headerlink" title="3.4 组合"></a>3.4 组合</h2><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">thenCombine(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn)</td>
<td align="center">当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。</td>
</tr>
<tr>
<td align="center">thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn)</td>
<td align="center">当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。使用ForkJoinPool。</td>
</tr>
<tr>
<td align="center">thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn, Executor executor)</td>
<td align="center">当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。使用指定的线程池。</td>
</tr>
</tbody></table>
<p>现在有CompletableFuture<t>、CompletableFuture<u>和一个函数(T,U)-&gt;V，thenCompose就是将CompletableFuture<t>和CompletableFuture<u>变为CompletableFuture<v>。
`CompletableFuture<string> future1 = CompletableFuture.supplyAsync(() -&gt; );<br>        CompletableFuture<integer> future2 = CompletableFuture.supplyAsync(() -&gt; );</integer></string></v></u></t></u></t></p>
<pre><code>CompletableFuture&lt;Double&gt; future = future1.thenCombine(future2, (s, i) -&gt; Double.parseDouble(s + i));

 {
    System.out.println(future.get());
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>执行结果：</p>
<p>``
使用thenCombine()之后future1、future2之间是并行执行的，最后再将结果汇总。这一点跟thenCompose()不同。</p>
<p>thenAcceptBoth跟thenCombine类似，但是返回CompletableFuture类型。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">thenAcceptBoth(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action)</td>
<td align="center">当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。</td>
</tr>
<tr>
<td align="center">thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action)</td>
<td align="center">当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。使用ForkJoinPool。</td>
</tr>
<tr>
<td align="center">thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action, Executor executor)</td>
<td align="center">当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。使用指定的线程池。</td>
</tr>
<tr>
<td align="center">`CompletableFuture<string> future1 = CompletableFuture.supplyAsync(() -&gt; );</string></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">CompletableFuture<integer> future2 = CompletableFuture.supplyAsync(() -&gt; );</integer></td>
<td align="center"></td>
</tr>
</tbody></table>
<pre><code>CompletableFuture&lt;Void&gt; future = future1.thenAcceptBoth(future2, (s, i) -&gt; System.out.println(Double.parseDouble(s + i)));

 {
    future.get();
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>执行结果：</p>
<p>``</p>
<h2 id="3-5-计算结果完成时的处理"><a href="#3-5-计算结果完成时的处理" class="headerlink" title="3.5 计算结果完成时的处理"></a>3.5 计算结果完成时的处理</h2><p>当CompletableFuture完成计算结果后，我们可能需要对结果进行一些处理。</p>
<p>/#/#/#3.5.1 执行特定的Action</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">whenComplete(BiConsumer&lt;? super T,? super Throwable&gt; action)</td>
<td align="center">当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。</td>
</tr>
<tr>
<td align="center">whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action)</td>
<td align="center">当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。使用ForkJoinPool。</td>
</tr>
<tr>
<td align="center">whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action, Executor executor)</td>
<td align="center">当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。使用指定的线程池。</td>
</tr>
<tr>
<td align="center">`CompletableFuture.supplyAsync(() -&gt; )</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">.thenApply(s-&gt;s+)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">.thenApply(s-&gt;s+ )</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">.thenApply(String::toLowerCase)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">.whenComplete((result, throwable) -&gt; System.out.println(result));`</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>执行结果：</p>
<p><code>hello world
 is completablefuture demo</code></p>
<p>/#/#/#3.5.2 执行完Action可以做转换</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)</td>
<td align="center">当CompletableFuture完成计算结果或者抛出异常的时候，执行提供的fn</td>
</tr>
<tr>
<td align="center">handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)</td>
<td align="center">当CompletableFuture完成计算结果或者抛出异常的时候，执行提供的fn，使用ForkJoinPool。</td>
</tr>
<tr>
<td align="center">handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn, Executor executor)</td>
<td align="center">当CompletableFuture完成计算结果或者抛出异常的时候，执行提供的fn，使用指定的线程池。</td>
</tr>
<tr>
<td align="center">`CompletableFuture<double> future = CompletableFuture.supplyAsync(() -&gt; )</double></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">.thenApply(s-&gt;s+)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">.handle((s, t) -&gt; s !=  ? Double.parseDouble(s) : );</td>
<td align="center"></td>
</tr>
</tbody></table>
<pre><code> {
    System.out.println(future.get());
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>执行结果：</p>
<p>``</p>
<p>在这里，handle()的参数是BiFunction，apply()方法返回R，相当于转换的操作。</p>
<p>`{</p>
<pre><code>;


 &lt;V&gt; {
    Objects.requireNonNull(after);
     (T t, U u) -&gt; after.apply(apply(t, u));
}</code></pre><p>}`</p>
<p>而whenComplete()的参数是BiConsumer，accept()方法返回void。</p>
<p>`{</p>
<pre><code>;


{
    Objects.requireNonNull(after);

     (l, r) -&gt; {
        accept(l, r);
        after.accept(l, r);
    };
}</code></pre><p>}`
所以，handle()相当于whenComplete()+转换。</p>
<p>/#/#/#3.5.3 纯消费(执行Action)</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">thenAccept(Consumer&lt;? super T&gt; action)</td>
<td align="center">当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值</td>
</tr>
<tr>
<td align="center">thenAcceptAsync(Consumer&lt;? super T&gt; action)</td>
<td align="center">当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值，使用ForkJoinPool。</td>
</tr>
<tr>
<td align="center">thenAcceptAsync(Consumer&lt;? super T&gt; action, Executor executor)</td>
<td align="center">当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值</td>
</tr>
</tbody></table>
<p>thenAccept()是只会对计算结果进行消费而不会返回任何结果的方法。<br><code>CompletableFuture.supplyAsync(() -&gt; )
                .thenApply(s-&gt;s+)
                .thenApply(s-&gt;s+ )
                .thenApply(String::toLowerCase)
                .thenAccept(System.out::print);</code></p>
<p>执行结果：</p>
<p><code>hello world
 is completablefuture demo</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/14/Java8新的异步编程方式CompletableFuture(2)/" data-id="cjwkcoouq0002n02aw6ekcxvg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java8新的异步编程方式CompletableFuture(1)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/14/Java8新的异步编程方式CompletableFuture(1)/" class="article-date">
  <time datetime="2019-05-14T03:45:42.042Z" itemprop="datePublished">2019-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/14/Java8新的异步编程方式CompletableFuture(1)/">Java8新的异步编程方式 CompletableFuture(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/59eae61b51882549fc512b34" target="_blank" rel="noopener">https://juejin.im/post/59eae61b51882549fc512b34</a> </p>
</blockquote>
<h1 id="一-Future"><a href="#一-Future" class="headerlink" title="一. Future"></a>一. Future</h1><p>JDK 5引入了Future模式。Future接口是Java多线程Future模式的实现，在java.util.concurrent包中，可以来进行异步计算。</p>
<p>Future模式是多线程设计常用的一种设计模式。Future模式可以理解成：我有一个任务，提交给了Future，Future替我完成这个任务。期间我自己可以去做任何想做的事情。一段时间之后，我就便可以从Future那儿取出结果。</p>
<p>Future的接口很简单，只有五个方法。<br>`{</p>
<pre><code>;

;

;

;

;</code></pre><p>}`</p>
<p>Future接口的方法介绍如下：</p>
<pre><code>* boolean cancel (boolean mayInterruptIfRunning) 取消任务的执行。参数指定是否立即中断任务执行，或者等等任务结束
* boolean isCancelled () 任务是否已经取消，任务正常完成前将其取消，则返回 true
* boolean isDone () 任务是否已经完成。需要注意的是如果任务正常终止、异常或取消，都将返回true
* V get () throws InterruptedException, ExecutionException 等待任务执行结束，然后获得V类型的结果。InterruptedException 线程被中断异常， ExecutionException任务执行异常，如果任务被取消，还会抛出CancellationException
* V get (long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException 同上面的get功能一样，多了设置超时时间。参数timeout指定超时时间，uint指定时间的单位，在枚举类TimeUnit中有相关的定义。如果计 算超时，将抛出TimeoutException</code></pre><p>一般情况下，我们会结合Callable和Future一起使用，通过ExecutorService的submit方法执行Callable，并返回Future。<br>`ExecutorService executor = Executors.newCachedThreadPool();</p>
<pre><code>Future&lt;String&gt; future = executor.submit(() -&gt; { 
    System.out.println();
    Thread.sleep();
     ;
});

 {
    Thread.sleep();
}  (InterruptedException e) {
}

System.out.println();  

 {
    System.out.println(future.get());  
}  (InterruptedException e) {
}  (ExecutionException e) {

}  {
    executor.shutdown();
}`</code></pre><p>比起future.get()，其实更推荐使用get (long timeout, TimeUnit unit) 方法，设置了超时时间可以防止程序无限制的等待future的结果。</p>
<h1 id="二-CompletableFuture介绍"><a href="#二-CompletableFuture介绍" class="headerlink" title="二. CompletableFuture介绍"></a>二. CompletableFuture介绍</h1><h2 id="2-1-Future模式的缺点"><a href="#2-1-Future模式的缺点" class="headerlink" title="2.1 Future模式的缺点"></a>2.1 Future模式的缺点</h2><pre><code>* Future虽然可以实现获取异步执行结果的需求，但是它没有提供通知的机制，我们无法得知Future什么时候完成。
* 要么使用阻塞，在future.get()的地方等待future返回的结果，这时又变成同步操作。要么使用isDone()轮询地判断Future是否完成，这样会耗费CPU的资源。</code></pre><h2 id="2-2-CompletableFuture介绍"><a href="#2-2-CompletableFuture介绍" class="headerlink" title="2.2 CompletableFuture介绍"></a>2.2 CompletableFuture介绍</h2><p>Netty、Guava分别扩展了Java 的 Future 接口，方便异步编程。</p>
<p>Java 8新增的CompletableFuture类正是吸收了所有Google Guava中ListenableFuture和SettableFuture的特征，还提供了其它强大的功能，让Java拥有了完整的非阻塞编程模型：Future、Promise 和 Callback(在Java8之前，只有无Callback 的Future)。</p>
<p>CompletableFuture能够将回调放到与任务不同的线程中执行，也能将回调作为继续执行的同步函数，在与任务相同的线程中执行。它避免了传统回调最大的问题，那就是能够将控制流分离到不同的事件处理器中。</p>
<p>CompletableFuture弥补了Future模式的缺点。在异步的任务完成后，需要用其结果继续操作时，无需等待。可以直接通过thenAccept、thenApply、thenCompose等方式将前面异步处理的结果交给另外一个异步事件处理线程来处理。</p>
<h1 id="三-CompletableFuture特性"><a href="#三-CompletableFuture特性" class="headerlink" title="三. CompletableFuture特性"></a>三. CompletableFuture特性</h1><h2 id="3-1-CompletableFuture的静态工厂方法"><a href="#3-1-CompletableFuture的静态工厂方法" class="headerlink" title="3.1 CompletableFuture的静态工厂方法"></a>3.1 CompletableFuture的静态工厂方法</h2><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">runAsync(Runnable runnable)</td>
<td align="center">使用ForkJoinPool.commonPool()作为它的线程池执行异步代码。</td>
</tr>
<tr>
<td align="center">runAsync(Runnable runnable, Executor executor)</td>
<td align="center">使用指定的thread pool执行异步代码。</td>
</tr>
<tr>
<td align="center">supplyAsync(Supplier<u> supplier)</u></td>
<td align="center">使用ForkJoinPool.commonPool()作为它的线程池执行异步代码，异步操作有返回值</td>
</tr>
<tr>
<td align="center">supplyAsync(Supplier<u> supplier, Executor executor)</u></td>
<td align="center">使用指定的thread pool执行异步代码，异步操作有返回值</td>
</tr>
</tbody></table>
<p>runAsync 和 supplyAsync 方法的区别是runAsync返回的CompletableFuture是没有返回值的。<br>`CompletableFuture<void> future = CompletableFuture.runAsync(() -&gt; {<br>            System.out.println();<br>        });</void></p>
<pre><code> {
    future.get();
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}

System.out.println();`</code></pre><p>而supplyAsync返回的CompletableFuture是由返回值的，下面的代码打印了future的返回值。</p>
<p>`CompletableFuture<string> future = CompletableFuture.supplyAsync(() -&gt; );</string></p>
<pre><code> {
    System.out.println(future.get());
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}

System.out.println();`</code></pre><h2 id="3-2-Completable"><a href="#3-2-Completable" class="headerlink" title="3.2 Completable"></a>3.2 Completable</h2><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">complete(T t)</td>
<td align="center">完成异步执行，并返回future的结果</td>
</tr>
<tr>
<td align="center">completeExceptionally(Throwable ex)</td>
<td align="center">异步执行不正常的结束</td>
</tr>
</tbody></table>
<p>future.get()在等待执行结果时，程序会一直block，如果此时调用complete(T t)会立即执行。<br>`CompletableFuture<string> future  = CompletableFuture.supplyAsync(() -&gt; );</string></p>
<pre><code>future.complete();

 {
    System.out.println(future.get());
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>执行结果：</p>
<p><code>World</code></p>
<p>可以看到future调用complete(T t)会立即执行。但是complete(T t)只能调用一次，后续的重复调用会失效。</p>
<p>如果future已经执行完毕能够返回结果，此时再调用complete(T t)则会无效。<br>`CompletableFuture<string> future = CompletableFuture.supplyAsync(() -&gt; );</string></p>
<pre><code> {
    Thread.sleep();
}  (InterruptedException e) {
    e.printStackTrace();
}

future.complete();

 {
    System.out.println(future.get());
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>执行结果：</p>
<p><code>Hello</code></p>
<p>如果使用completeExceptionally(Throwable ex)则抛出一个异常，而不是一个成功的结果。</p>
<p>`CompletableFuture<string> future = CompletableFuture.supplyAsync(() -&gt; );</string></p>
<pre><code>future.completeExceptionally( Exception());

 {
    System.out.println(future.get());
}  (InterruptedException e) {
    e.printStackTrace();
}  (ExecutionException e) {
    e.printStackTrace();
}`</code></pre><p>执行结果：</p>
<p><code>java.util.concurrent.ExecutionException: java.lang.Exception
...</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/14/Java8新的异步编程方式CompletableFuture(1)/" data-id="cjwkcooun0001n02arash49kc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java8的CompletableFuture进阶之道" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/14/Java8的CompletableFuture进阶之道/" class="article-date">
  <time datetime="2019-05-14T03:26:08.008Z" itemprop="datePublished">2019-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/14/Java8的CompletableFuture进阶之道/">Java8的CompletableFuture进阶之道</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5ca47aa0e51d457131257269" target="_blank" rel="noopener">https://juejin.im/post/5ca47aa0e51d457131257269</a> </p>
</blockquote>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>作为Java 8 Concurrency API改进而引入，本文是CompletableFuture类的功能和用例的介绍。同时在Java 9 也有对CompletableFuture有一些改进，之后再进入讲解。</p>
<h1 id="Future计算"><a href="#Future计算" class="headerlink" title="Future计算"></a>Future计算</h1><p>Future异步计算很难操作，通常我们希望将任何计算逻辑视为一系列步骤。但是在异步计算的情况下，表示为回调的方法往往分散在代码中或者深深地嵌套在彼此内部。但是当我们需要处理其中一个步骤中可能发生的错误时，情况可能会变得更复杂。</p>
<p>Futrue接口是Java 5中作为异步计算而新增的，但它没有任何方法去进行计算组合或者处理可能出现的错误。</p>
<p>在Java 8中，引入了CompletableFuture类。与Future接口一起，它还实现了CompletionStage接口。此接口定义了可与其他Future组合成异步计算契约。</p>
<p>CompletableFuture同时是一个组合和一个框架，具有大约50种不同的构成，结合，执行异步计算步骤和处理错误。</p>
<p>如此庞大的API可能会令人难以招架，下文将调一些重要的做重点介绍。</p>
<h1 id="使用CompletableFuture作为Future实现"><a href="#使用CompletableFuture作为Future实现" class="headerlink" title="使用CompletableFuture作为Future实现"></a>使用CompletableFuture作为Future实现</h1><p>首先，CompletableFuture类实现Future接口，因此你可以将其用作Future实现，但需要额外的完成实现逻辑。</p>
<p>例如，你可以使用无构参构造函数创建此类的实例，然后使用<code>complete</code>方法完成。消费者可以使用get方法来阻塞当前线程，直到<code>get()</code>结果。</p>
<p>在下面的示例中，我们有一个创建CompletableFuture实例的方法，然后在另一个线程中计算并立即返回Future。</p>
<p>计算完成后，该方法通过将结果提供给完整方法来完成Future：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Future&lt;String&gt; calculateAsync() throws InterruptedException &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; completableFuture </span><br><span class="line">      = new CompletableFuture&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    Executors.newCachedThreadPool().submit(() -&gt; &#123;</span><br><span class="line">        Thread.sleep(500);</span><br><span class="line">        completableFuture.complete(&quot;Hello&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    return completableFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了分离计算，我们使用了<em>Executor</em> API ，这种创建和完成<em>CompletableFuture的方法</em>可以与任何并发包（包括原始线程）一起使用。</p>
<p>请注意，<strong>该<code>calculateAsync</code>方法返回一个<code>Future</code>实例。</strong></p>
<p>我们只是调用方法，接收<em>Future</em>实例并在我们准备阻塞结果时调用它的<em>get</em>方法。</p>
<p>另请注意，<em>get</em>方法抛出一些已检查的异常，即<em>ExecutionException</em>（封装计算期间发生的异常）和<em>InterruptedException</em>（表示执行方法的线程被中断的异常）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; completableFuture = calculateAsync();</span><br><span class="line"> </span><br><span class="line">// ... </span><br><span class="line"> </span><br><span class="line">String result = completableFuture.get();</span><br><span class="line">assertEquals(&quot;Hello&quot;, result);</span><br></pre></td></tr></table></figure>

<p>如果你已经知道计算的结果，也可以用变成同步的方式来返回结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; completableFuture = </span><br><span class="line">  CompletableFuture.completedFuture(&quot;Hello&quot;);</span><br><span class="line"> </span><br><span class="line">// ...</span><br><span class="line"> </span><br><span class="line">String result = completableFuture.get();</span><br><span class="line">assertEquals(&quot;Hello&quot;, result);</span><br></pre></td></tr></table></figure>

<p>作为在某些场景中，你可能希望取消Future任务的执行。</p>
<p>假设我们没有找到结果并决定完全取消异步执行任务。这可以通过Future的取消方法完成。此方法<code>mayInterruptIfRunning</code>，但在CompletableFuture的情况下，它没有任何效果，因为中断不用于控制CompletableFuture的处理。</p>
<p>这是异步方法的修改版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Future&lt;String&gt; calculateAsyncWithCancellation() throws InterruptedException &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; completableFuture = new CompletableFuture&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    Executors.newCachedThreadPool().submit(() -&gt; &#123;</span><br><span class="line">        Thread.sleep(500);</span><br><span class="line">        completableFuture.cancel(false);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    return completableFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们使用Future.get()方法阻塞结果时，<code>cancel()</code>表示取消执行，它将抛出CancellationException：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; future = calculateAsyncWithCancellation();</span><br><span class="line">future.get(); // CancellationException</span><br></pre></td></tr></table></figure>

<h1 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h1><h2 id="static方法说明"><a href="#static方法说明" class="headerlink" title="static方法说明"></a>static方法说明</h2><p>上面的代码很简单，下面介绍几个 <strong>static</strong> 方法，它们使用任务来实例化一个 CompletableFuture 实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(Runnable runnable);</span><br><span class="line">CompletableFuture.runAsync(Runnable runnable, Executor executor);</span><br><span class="line"></span><br><span class="line">CompletableFuture.supplyAsync(Supplier&lt;U&gt; supplier);</span><br><span class="line">CompletableFuture.supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</span><br></pre></td></tr></table></figure>

<pre><code>* runAsync 方法接收的是 Runnable 的实例，但是它没有返回值
* supplyAsync 方法是JDK8函数式接口，无参数，会返回一个结果
* 这两个方法是 executor 的升级，表示让任务在指定的线程池中执行，不指定的话，通常任务是在 ForkJoinPool.commonPool() 线程池中执行的。</code></pre><h2 id="supplyAsync-使用"><a href="#supplyAsync-使用" class="headerlink" title="supplyAsync()使用"></a>supplyAsync()使用</h2><p>静态方法<code>runAsync</code>和<code>supplyAsync</code>允许我们相应地从Runnable和Supplier功能类型中创建CompletableFuture实例。</p>
<p>该Runnable的接口是在线程使用旧的接口，它不允许返回值。</p>
<p>Supplier接口是一个不具有参数，并返回参数化类型的一个值的单个方法的通用功能接口。</p>
<p>这允许将Supplier的实例作为lambda表达式提供，该表达式执行计算并返回结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future</span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;);</span><br><span class="line"> </span><br><span class="line">// ...</span><br><span class="line"> </span><br><span class="line">assertEquals(&quot;Hello&quot;, future.get());</span><br></pre></td></tr></table></figure>

<h2 id="thenRun-使用"><a href="#thenRun-使用" class="headerlink" title="thenRun()使用"></a>thenRun()使用</h2><p>在两个任务任务A，任务B中，如果既不需要任务A的值也不想在任务B中引用，那么你可以将Runnable lambda 传递给<code>thenRun()</code>方法。在下面的示例中，在调用future.get()方法之后，我们只需在控制台中打印一行：</p>
<p>模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(() -&gt; &#123;&#125;).thenRun(() -&gt; &#123;&#125;); </span><br><span class="line">CompletableFuture.supplyAsync(() -&gt; &quot;resultA&quot;).thenRun(() -&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>

<pre><code>* 第一行用的是 `thenRun(Runnable runnable)`，任务 A 执行完执行 B，并且 B 不需要 A 的结果。
* 第二行用的是 `thenRun(Runnable runnable)`，任务 A 执行完执行 B，会返回`resultA`，但是 B 不需要 A 的结果。</code></pre><p>实战</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture </span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;);</span><br><span class="line"> </span><br><span class="line">CompletableFuture&lt;Void&gt; future = completableFuture</span><br><span class="line">  .thenRun(() -&gt; System.out.println(&quot;Computation finished.&quot;));</span><br><span class="line"> </span><br><span class="line">future.get();</span><br></pre></td></tr></table></figure>

<h2 id="thenAccept-使用"><a href="#thenAccept-使用" class="headerlink" title="thenAccept()使用"></a>thenAccept()使用</h2><p>在两个任务任务A，任务B中，如果你不需要在Future中有返回值，则可以用 <code>thenAccept</code>方法接收将计算结果传递给它。最后的future.get（）调用返回Void类型的实例。</p>
<p>模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(() -&gt; &#123;&#125;).thenAccept(resultA -&gt; &#123;&#125;); </span><br><span class="line"></span><br><span class="line">CompletableFuture.supplyAsync(() -&gt; &quot;resultA&quot;).thenAccept(resultA -&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>

<pre><code>* 第一行中，`runAsync`不会有返回值，第二个方法`thenAccept`，接收到的resultA值为null，同时任务B也不会有返回结果
* 第二行中，`supplyAsync`有返回值，同时任务B不会有返回结果。</code></pre><p>实战</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture</span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;);</span><br><span class="line"> </span><br><span class="line">CompletableFuture&lt;Void&gt; future = completableFuture</span><br><span class="line">  .thenAccept(s -&gt; System.out.println(&quot;Computation returned: &quot; + s));</span><br><span class="line"> </span><br><span class="line">future.get();</span><br></pre></td></tr></table></figure>

<h2 id="thenApply-使用"><a href="#thenApply-使用" class="headerlink" title="thenApply()使用"></a>thenApply()使用</h2><p>在两个任务任务A，任务B中，任务B想要任务A计算的结果，可以用<code>thenApply</code>方法来接受一个函数实例，用它来处理结果，并返回一个Future函数的返回值：</p>
<p>模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(() -&gt; &#123;&#125;).thenApply(resultA -&gt; &quot;resultB&quot;);</span><br><span class="line">CompletableFuture.supplyAsync(() -&gt; &quot;resultA&quot;).thenApply(resultA -&gt; resultA + &quot; resultB&quot;);</span><br></pre></td></tr></table></figure>

<pre><code>* 第二行用的是 thenApply(Function fn)，任务 A 执行完执行 B，B 需要 A 的结果，同时任务 B 有返回值。</code></pre><p>实战</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture</span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;);</span><br><span class="line"> </span><br><span class="line">CompletableFuture&lt;String&gt; future = completableFuture</span><br><span class="line">  .thenApply(s -&gt; s + &quot; World&quot;);</span><br><span class="line"> </span><br><span class="line">assertEquals(&quot;Hello World&quot;, future.get());</span><br></pre></td></tr></table></figure>

<p>当然，多个任务的情况下，如果任务 B 后面还有任务 C，往下继续调用 .thenXxx() 即可。</p>
<h2 id="thenCompose-使用"><a href="#thenCompose-使用" class="headerlink" title="thenCompose()使用"></a>thenCompose()使用</h2><p>接下来会有一个很有趣的设计模式；</p>
<p>CompletableFuture API 的最佳场景是能够在一系列计算步骤中组合CompletableFuture实例。</p>
<p>这种组合结果本身就是CompletableFuture，允许进一步再续组合。这种方法在函数式语言中无处不在，通常被称为<code>monadic设计模式</code>。</p>
<p>简单说，Monad就是一种设计模式，表示将一个运算过程，通过函数拆解成互相连接的多个步骤。你只要提供下一步运算所需的函数，整个运算就会自动进行下去。</p>
<p>在下面的示例中，我们使用thenCompose方法按顺序组合两个Futures。</p>
<p>请注意，此方法采用返回CompletableFuture实例的函数。该函数的参数是先前计算步骤的结果。这允许我们在下一个CompletableFuture的lambda中使用这个值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture </span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;)</span><br><span class="line">    .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + &quot; World&quot;));</span><br><span class="line"> </span><br><span class="line">assertEquals(&quot;Hello World&quot;, completableFuture.get());</span><br></pre></td></tr></table></figure>

<p>该thenCompose方法连同thenApply一样实现了结果的合并计算。但是他们的内部形式是不一样的，它们与Java 8中可用的Stream和Optional类的map和flatMap方法是有着类似的设计思路在里面的。</p>
<p>两个方法都接收一个CompletableFuture并将其应用于计算结果，但thenCompose（flatMap）方法接收一个函数，该函数返回相同类型的另一个CompletableFuture对象。此功能结构允许将这些类的实例继续进行组合计算。</p>
<h2 id="thenCombine"><a href="#thenCombine" class="headerlink" title="thenCombine()"></a>thenCombine()</h2><p>取两个任务的结果</p>
<p>如果要执行两个独立的任务，并对其结果执行某些操作，可以用Future的thenCombine方法：</p>
<p>模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; cfA = CompletableFuture.supplyAsync(() -&gt; &quot;resultA&quot;);</span><br><span class="line">CompletableFuture&lt;String&gt; cfB = CompletableFuture.supplyAsync(() -&gt; &quot;resultB&quot;);</span><br><span class="line"></span><br><span class="line">cfA.thenAcceptBoth(cfB, (resultA, resultB) -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">cfA.thenCombine(cfB, (resultA, resultB) -&gt; &quot;result A + B&quot;);</span><br></pre></td></tr></table></figure>

<p>实战</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture </span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;)</span><br><span class="line">    .thenCombine(CompletableFuture.supplyAsync(</span><br><span class="line">      () -&gt; &quot; World&quot;), (s1, s2) -&gt; s1 + s2));</span><br><span class="line"> </span><br><span class="line">assertEquals(&quot;Hello World&quot;, completableFuture.get());</span><br></pre></td></tr></table></figure>

<p>更简单的情况是，当你想要使用两个Future结果时，但不需要将任何结果值进行返回时，可以用<code>thenAcceptBoth</code>，它表示后续的处理不需要返回值，而 thenCombine 表示需要返回值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture future = CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;)</span><br><span class="line">  .thenAcceptBoth(CompletableFuture.supplyAsync(() -&gt; &quot; World&quot;),</span><br><span class="line">    (s1, s2) -&gt; System.out.println(s1 + s2));</span><br></pre></td></tr></table></figure>

<h1 id="thenApply-和thenCompose-之间的区别"><a href="#thenApply-和thenCompose-之间的区别" class="headerlink" title="thenApply()和thenCompose()之间的区别"></a>thenApply()和thenCompose()之间的区别</h1><p>在前面的部分中，我们展示了关于thenApply()和thenCompose()的示例。这两个API都是使用的CompletableFuture调用，但这两个API的使用是不同的。</p>
<h2 id="thenApply"><a href="#thenApply" class="headerlink" title="thenApply()"></a>thenApply()</h2><p>此方法用于处理先前调用的<strong>结果</strong>。但是，要记住的一个关键点是返回类型是转换泛型中的类型，是同一个CompletableFuture。</p>
<p>因此，当我们想要转换CompletableFuture 调用的结果时，效果是这样的 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; finalResult = compute().thenApply(s-&gt; s + 1);</span><br></pre></td></tr></table></figure>

<h2 id="thenCompose"><a href="#thenCompose" class="headerlink" title="thenCompose()"></a>thenCompose()</h2><p>该thenCompose()方法类似于thenApply()在都返回一个新的计算结果。但是，thenCompose()使用前一个Future作为参数。它会直接使结果变新的Future，而不是我们在thenApply()中到的嵌套Future，而是用来连接两个CompletableFuture，是生成一个新的CompletableFuture：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; computeAnother(Integer i)&#123;</span><br><span class="line">    return CompletableFuture.supplyAsync(() -&gt; 10 + i);</span><br><span class="line">&#125;</span><br><span class="line">CompletableFuture&lt;Integer&gt; finalResult = compute().thenCompose(this::computeAnother);</span><br></pre></td></tr></table></figure>

<p>因此，如果想要继续嵌套链接<em>CompletableFuture</em> 方法，那么最好使用<em>thenCompose()</em>。</p>
<h1 id="并行运行多个任务"><a href="#并行运行多个任务" class="headerlink" title="并行运行多个任务"></a>并行运行多个任务</h1><p>当我们需要并行执行多个任务时，我们通常希望等待所有它们执行，然后处理它们的组合结果。</p>
<p>该<code>CompletableFuture.allOf</code>静态方法允许等待所有的完成任务：</p>
<p>API</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs)&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>实战</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future1  </span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;);</span><br><span class="line">CompletableFuture&lt;String&gt; future2  </span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; &quot;Beautiful&quot;);</span><br><span class="line">CompletableFuture&lt;String&gt; future3  </span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; &quot;World&quot;);</span><br><span class="line"> </span><br><span class="line">CompletableFuture&lt;Void&gt; combinedFuture </span><br><span class="line">  = CompletableFuture.allOf(future1, future2, future3);</span><br><span class="line"> </span><br><span class="line">// ...</span><br><span class="line"> </span><br><span class="line">combinedFuture.get();</span><br><span class="line"> </span><br><span class="line">assertTrue(future1.isDone());</span><br><span class="line">assertTrue(future2.isDone());</span><br><span class="line">assertTrue(future3.isDone());</span><br></pre></td></tr></table></figure>

<p>请注意，CompletableFuture.allOf()的返回类型是CompletableFuture 。这种方法的局限性在于它不会返回所有任务的综合结果。相反，你必须手动从Futures获取结果。幸运的是，CompletableFuture.join()方法和Java 8 Streams API可以解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String combined = Stream.of(future1, future2, future3)</span><br><span class="line">  .map(CompletableFuture::join)</span><br><span class="line">  .collect(Collectors.joining(&quot; &quot;));</span><br><span class="line"> </span><br><span class="line">assertEquals(&quot;Hello Beautiful World&quot;, combined);</span><br></pre></td></tr></table></figure>

<p>CompletableFuture 提供了 join() 方法，它的功能和 get() 方法是一样的，都是阻塞获取值，它们的区别在于 join() 抛出的是 unchecked Exception。这使得它可以在Stream.map（）方法中用作方法引用。</p>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>说到这里，我们顺便来说下 CompletableFuture 的异常处理。这里我们要介绍两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;T&gt; exceptionally(Function&lt;Throwable, ? extends T&gt; fn);</span><br><span class="line">public &lt;U&gt; CompletionStage&lt;U&gt; handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn);</span><br></pre></td></tr></table></figure>

<p>看下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; &quot;resultA&quot;)</span><br><span class="line">    .thenApply(resultA -&gt; resultA + &quot; resultB&quot;)</span><br><span class="line">    .thenApply(resultB -&gt; resultB + &quot; resultC&quot;)</span><br><span class="line">    .thenApply(resultC -&gt; resultC + &quot; resultD&quot;);</span><br></pre></td></tr></table></figure>

<p>上面的代码中，任务 A、B、C、D 依次执行，如果任务 A 抛出异常（当然上面的代码不会抛出异常），那么后面的任务都得不到执行。如果任务 C 抛出异常，那么任务 D 得不到执行。</p>
<p>那么我们怎么处理异常呢？看下面的代码，我们在任务 A 中抛出异常，并对其进行处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">&#125;)</span><br><span class="line">        .exceptionally(ex -&gt; &quot;errorResultA&quot;)</span><br><span class="line">        .thenApply(resultA -&gt; resultA + &quot; resultB&quot;)</span><br><span class="line">        .thenApply(resultB -&gt; resultB + &quot; resultC&quot;)</span><br><span class="line">        .thenApply(resultC -&gt; resultC + &quot; resultD&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(future.join());</span><br></pre></td></tr></table></figure>

<p>上面的代码中，任务 A 抛出异常，然后通过<code>.exceptionally()</code> 方法处理了异常，并返回新的结果，这个新的结果将传递给任务 B。所以最终的输出结果是：</p>
<p>errorResultA resultB resultC resultD<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String name = null;</span><br><span class="line"> </span><br><span class="line">// ...</span><br><span class="line"> </span><br><span class="line">CompletableFuture&lt;String&gt; completableFuture  </span><br><span class="line">  =  CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">      if (name == null) &#123;</span><br><span class="line">          throw new RuntimeException(&quot;Computation error!&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      return &quot;Hello, &quot; + name;</span><br><span class="line">  &#125;)&#125;).handle((s, t) -&gt; s != null ? s : &quot;Hello, Stranger!&quot;);</span><br><span class="line"> </span><br><span class="line">assertEquals(&quot;Hello, Stranger!&quot;, completableFuture.get());</span><br></pre></td></tr></table></figure></p>
<p>当然，它们也可以都为 null，因为如果它作用的那个 CompletableFuture 实例没有返回值的时候，s 就是 null。</p>
<h1 id="Async后缀方法"><a href="#Async后缀方法" class="headerlink" title="Async后缀方法"></a>Async后缀方法</h1><p><em>CompletableFuture</em>类中的API的大多数方法都有两个带有<em>Async</em>后缀的附加修饰。这些方法表示用于异步线程。</p>
<p>没有<em>Async</em>后缀的方法使用调用线程运行下一个执行线程阶段。不带<em>Async</em>方法使用<em>ForkJoinPool.commonPool()</em>线程池的<em>fork / join</em>实现运算任务。带有<em>Async</em>方法使用传递式的<em>Executor</em>任务去运行。</p>
<p>下面附带一个案例，可以看到有<em>thenApplyAsync</em>方法。在程序内部，线程被包装到<em>ForkJoinTask</em>实例中。这样可以进一步并行化你的计算并更有效地使用系统资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture  </span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;);</span><br><span class="line"> </span><br><span class="line">CompletableFuture&lt;String&gt; future = completableFuture</span><br><span class="line">  .thenApplyAsync(s -&gt; s + &quot; World&quot;);</span><br><span class="line"> </span><br><span class="line">assertEquals(&quot;Hello World&quot;, future.get());</span><br></pre></td></tr></table></figure>

<h1 id="JDK-9-CompletableFuture-API"><a href="#JDK-9-CompletableFuture-API" class="headerlink" title="JDK 9 CompletableFuture API"></a>JDK 9 CompletableFuture API</h1><p>在Java 9中， CompletableFuture API通过以下更改得到了进一步增强：</p>
<pre><code>* 新工厂方法增加了
* 支持延迟和超时
* 改进了对子类化的支持。</code></pre><p>引入了新的实例API：</p>
<pre><code>* Executor defaultExecutor()
* CompletableFuturenewIncompleteFuture()
* CompletableFuture copy()
* CompletionStage minimalCompletionStage()
* CompletableFuture completeAsync(Supplier&lt;? extends T&gt; supplier, Executor executor)
* CompletableFuture completeAsync(Supplier&lt;? extends T&gt; supplier)
* CompletableFuture orTimeout(long timeout, TimeUnit unit)
* CompletableFuture completeOnTimeout(T value, long timeout, TimeUnit unit)</code></pre><p>还有一些静态实用方法：</p>
<pre><code>* Executor delayedExecutor(long delay, TimeUnit unit, Executor executor)
* Executor delayedExecutor(long delay, TimeUnit unit)
* CompletionStagecompletedStage(U value)    * CompletionStagefailedStage(Throwable ex)    * CompletableFuturefailedFuture(Throwable ex)</code></pre><p>最后，为了解决超时问题，Java 9又引入了两个新功能：</p>
<pre><code>* orTimeout()
* completeOnTimeout()</code></pre><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在本文中，我们描述了CompletableFuture类的方法和典型用例。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/14/Java8的CompletableFuture进阶之道/" data-id="cjwkcoouu0005n02ayjbljvyr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-杂谈什么是伪共享（falsesharing）？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/13/杂谈什么是伪共享（falsesharing）？/" class="article-date">
  <time datetime="2019-05-13T07:18:06.006Z" itemprop="datePublished">2019-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/13/杂谈什么是伪共享（falsesharing）？/">杂谈 什么是伪共享（false sharing）？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5cd644886fb9a032136fe6d7" target="_blank" rel="noopener">https://juejin.im/post/5cd644886fb9a032136fe6d7</a> </p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>（1）什么是 CPU 缓存行？</p>
<p>（2）什么是内存屏障？</p>
<p>（3）什么是伪共享？</p>
<p>（4）如何避免伪共享？</p>
<h2 id="CPU缓存架构"><a href="#CPU缓存架构" class="headerlink" title="CPU缓存架构"></a>CPU缓存架构</h2><p>CPU 是计算机的心脏，所有运算和程序最终都要由它来执行。</p>
<p>主内存（RAM）是数据存放的地方，CPU 和主内存之间有好几级缓存，因为即使直接访问主内存也是非常慢的。</p>
<p>如果对一块数据做相同的运算多次，那么在执行运算的时候把它加载到离 CPU 很近的地方就有意义了，比如一个循环计数，你不想每次循环都跑到主内存去取这个数据来增长它吧。</p>
<p><img src="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/false-sharing1.png" alt="ABA"></p>
<p>越靠近 CPU 的缓存越快也越小。</p>
<p>所以 L1 缓存很小但很快，并且紧靠着在使用它的 CPU 内核。</p>
<p>L2 大一些，也慢一些，并且仍然只能被一个单独的 CPU 核使用。</p>
<p>L3 在现代多核机器中更普遍，仍然更大，更慢，并且被单个插槽上的所有 CPU 核共享。</p>
<p>最后，主存保存着程序运行的所有数据，它更大，更慢，由全部插槽上的所有 CPU 核共享。</p>
<p>当 CPU 执行运算的时候，它先去 L1 查找所需的数据，再去 L2，然后是 L3，最后如果这些缓存中都没有，所需的数据就要去主内存拿。</p>
<p>走得越远，运算耗费的时间就越长。</p>
<p>所以如果进行一些很频繁的运算，要确保数据在 L1 缓存中。</p>
<h2 id="CPU缓存行"><a href="#CPU缓存行" class="headerlink" title="CPU缓存行"></a>CPU缓存行</h2><p>缓存是由缓存行组成的，通常是 64 字节（常用处理器的缓存行是 64 字节的，比较旧的处理器缓存行是 32 字节），并且它有效地引用主内存中的一块地址。</p>
<p>一个 Java 的 long 类型是 8 字节，因此在一个缓存行中可以存 8 个 long 类型的变量。</p>
<p><img src="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/false-sharing2.png" alt="ABA"></p>
<p>在程序运行的过程中，缓存每次更新都从主内存中加载连续的 64 个字节。因此，如果访问一个 long 类型的数组时，当数组中的一个值被加载到缓存中时，另外 7 个元素也会被加载到缓存中。</p>
<p>但是，如果使用的数据结构中的项在内存中不是彼此相邻的，比如链表，那么将得不到免费缓存加载带来的好处。</p>
<p>不过，这种免费加载也有一个坏处。设想如果我们有个 long 类型的变量 a，它不是数组的一部分，而是一个单独的变量，并且还有另外一个 long 类型的变量 b 紧挨着它，那么当加载 a 的时候将免费加载 b。</p>
<p>看起来似乎没有什么毛病，但是如果一个 CPU 核心的线程在对 a 进行修改，另一个 CPU 核心的线程却在对 b 进行读取。</p>
<p>当前者修改 a 时，会把 a 和 b 同时加载到前者核心的缓存行中，更新完 a 后其它所有包含 a 的缓存行都将失效，因为其它缓存中的 a 不是最新值了。</p>
<p>而当后者读取 b 时，发现这个缓存行已经失效了，需要从主内存中重新加载。</p>
<p>请记住，我们的缓存都是以缓存行作为一个单位来处理的，所以失效 a 的缓存的同时，也会把 b 失效，反之亦然。</p>
<p><img src="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/false-sharing3.png" alt="ABA"></p>
<p>这样就出现了一个问题，b 和 a 完全不相干，每次却要因为 a 的更新需要从主内存重新读取，它被缓存未命中给拖慢了。</p>
<p>这就是传说中的伪共享。</p>
<h2 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h2><p>好了，上面介绍完CPU的缓存架构及缓存行机制，下面进入我们的正题——伪共享。</p>
<p>当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</p>
<p>我们来看看下面这个例子，充分说明了伪共享是怎么回事。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class FalseSharingTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        testPointer(new Pointer());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void testPointer(Pointer pointer) throws InterruptedException &#123;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">                pointer.x++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">                pointer.y++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">        System.out.println(pointer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Pointer &#123;</span><br><span class="line">    volatile long x;</span><br><span class="line">    volatile long y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，我们声明了一个 Pointer 的类，它包含 x 和 y 两个变量（必须声明为volatile，保证可见性，关于内存屏障的东西我们后面再讲），一个线程对 x 进行自增1亿次，一个线程对 y 进行自增1亿次。</p>
<p>可以看到，x 和 y 完全没有任何关系，但是更新 x 的时候会把其它包含 x 的缓存行失效，同时也就失效了 y，运行这段程序输出的时间为<code>3890ms</code>。</p>
<h2 id="避免伪共享"><a href="#避免伪共享" class="headerlink" title="避免伪共享"></a>避免伪共享</h2><p>伪共享的原理我们知道了，一个缓存行是 64 个字节，一个 long 类型是 8 个字节，所以避免伪共享也很简单，笔者总结了下大概有以下三种方式：</p>
<p>（1）在两个 long 类型的变量之间再加 7 个 long 类型</p>
<p>我们把上面的Pointer改成下面这个结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Pointer &#123;</span><br><span class="line">    volatile long x;</span><br><span class="line">    long p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">    volatile long y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次运行程序，会发现输出时间神奇的缩短为了<code>695ms</code>。</p>
<p>（2）重新创建自己的 long 类型，而不是 java 自带的 long</p>
<p>修改Pointer如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Pointer &#123;</span><br><span class="line">    MyLong x = new MyLong();</span><br><span class="line">    MyLong y = new MyLong();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyLong &#123;</span><br><span class="line">    volatile long value;</span><br><span class="line">    long p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时把 <code>pointer.x++;</code> 修改为 <code>pointer.x.value++;</code>，把 <code>pointer.y++;</code> 修改为 <code>pointer.y.value++;</code>，再次运行程序发现时间是<code>724ms</code>。</p>
<p>（3）使用 @sun.misc.Contended 注解（java8）</p>
<p>修改 MyLong 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@sun.misc.Contended</span><br><span class="line">class MyLong &#123;</span><br><span class="line">    volatile long value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认使用这个注解是无效的，需要在JVM启动参数加上<code>-XX:-RestrictContended</code>才会生效，，再次运行程序发现时间是<code>718ms</code>。</p>
<p>注意，以上三种方式中的前两种是通过加字段的形式实现的，加的字段又没有地方使用，可能会被jvm优化掉，所以建议使用第三种方式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>（1）CPU具有多级缓存，越接近CPU的缓存越小也越快；</p>
<p>（2）CPU缓存中的数据是以缓存行为单位处理的；</p>
<p>（3）CPU缓存行能带来免费加载数据的好处，所以处理数组性能非常高；</p>
<p>（4）CPU缓存行也带来了弊端，多线程处理不相干的变量时会相互影响，也就是伪共享；</p>
<p>（5）避免伪共享的主要思路就是让不相干的变量不要出现在同一个缓存行中；</p>
<p>（6）一是每两个变量之间加七个 long 类型；</p>
<p>（7）二是创建自己的 long 类型，而不是用原生的；</p>
<p>（8）三是使用 java8 提供的注解；</p>
<h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>java中有哪些类避免了伪共享的干扰呢？</p>
<p>还记得我们前面介绍过的 ConcurrentHashMap 的源码解析吗？</p>
<p>里面的 size() 方法使用的是分段的思想来构造的，每个段使用的类是 CounterCell，它的类上就有 @sun.misc.Contended 注解。</p>
<p>不知道的可以关注我的公众号“彤哥读源码”查看历史消息找到这篇文章看看。</p>
<p>除了这个类，java中还有个 LongAdder 也使用了这个注解避免伪共享，下一章我们将一起学习 LongAdder 的源码分析，敬请期待。</p>
<p>你还知道哪些避免伪共享的应用呢？</p>
<hr>
<p>欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。</p>
<p><img src="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode_ss.jpg" alt="qrcode"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/13/杂谈什么是伪共享（falsesharing）？/" data-id="cjwkcoovf001an02azgca2d2v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-死磕java并发包之LongAdder源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/13/死磕java并发包之LongAdder源码分析/" class="article-date">
  <time datetime="2019-05-13T03:14:06.006Z" itemprop="datePublished">2019-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/13/死磕java并发包之LongAdder源码分析/">死磕 java并发包之LongAdder源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5cd842aa6fb9a032332b4bb8" target="_blank" rel="noopener">https://juejin.im/post/5cd842aa6fb9a032332b4bb8</a> </p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>（1）java8中为什么要新增LongAdder？</p>
<p>（2）LongAdder的实现方式？</p>
<p>（3）LongAdder与AtomicLong的对比？</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LongAdder是java8中新增的原子类，在多线程环境中，它比AtomicLong性能要高出不少，特别是写多的场景。</p>
<p>它是怎么实现的呢？让我们一起来学习吧。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>LongAdder的原理是，在最初无竞争时，只更新base的值，当有多线程竞争时通过分段的思想，让不同的线程更新不同的段，最后把这些段相加就得到了完整的LongAdder存储的值。</p>
<p><img src="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/LongAdder1.png" alt="LongAdder"></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>LongAdder继承自Striped64抽象类，Striped64中定义了Cell内部类和各重要属性。</p>
<h3 id="主要内部类"><a href="#主要内部类" class="headerlink" title="主要内部类"></a>主要内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Striped64中的内部类，使用@sun.misc.Contended注解，说明里面的值消除伪共享</span><br><span class="line">@sun.misc.Contended static final class Cell &#123;</span><br><span class="line">    // 存储元素的值，使用volatile修饰保证可见性</span><br><span class="line">    volatile long value;</span><br><span class="line">    Cell(long x) &#123; value = x; &#125;</span><br><span class="line">    // CAS更新value的值</span><br><span class="line">    final boolean cas(long cmp, long val) &#123;</span><br><span class="line">        return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Unsafe实例</span><br><span class="line">    private static final sun.misc.Unsafe UNSAFE;</span><br><span class="line">    // value字段的偏移量</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; ak = Cell.class;</span><br><span class="line">            valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (ak.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cell类使用@sun.misc.Contended注解，说明是要避免伪共享的。</p>
<p>使用Unsafe的CAS更新value的值，其中value的值使用volatile修饰，保证可见性。</p>
<p>关于Unsafe的介绍请查看【<a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F0s-u-MysppIaIHVrshp9fA" target="_blank" rel="noopener">死磕 java魔法类之Unsafe解析</a>】。</p>
<p>关于伪共享的介绍请查看【<a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Frd13SOSxhLA6TT13N9ni8Q" target="_blank" rel="noopener">杂谈 什么是伪共享（false sharing）？</a>】。</p>
<h3 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 这三个属性都在Striped64中</span><br><span class="line">// cells数组，存储各个段的值</span><br><span class="line">transient volatile Cell[] cells;</span><br><span class="line">// 最初无竞争时使用的，也算一个特殊的段</span><br><span class="line">transient volatile long base;</span><br><span class="line">// 标记当前是否有线程在创建或扩容cells，或者在创建Cell</span><br><span class="line">// 通过CAS更新该值，相当于是一个锁</span><br><span class="line">transient volatile int cellsBusy;</span><br></pre></td></tr></table></figure>

<p>最初无竞争或有其它线程在创建cells数组时使用base更新值，有过竞争时使用cells更新值。</p>
<p>最初无竞争是指一开始没有线程之间的竞争，但也有可能是多线程在操作，只是这些线程没有同时去更新base的值。</p>
<p>有过竞争是指只要出现过竞争不管后面有没有竞争都使用cells更新值，规则是不同的线程hash到不同的cell上去更新，减少竞争。</p>
<h3 id="add-x-方法"><a href="#add-x-方法" class="headerlink" title="add(x)方法"></a>add(x)方法</h3><p>add(x)方法是LongAdder的主要方法，使用它可以使LongAdder中存储的值增加x，x可为正可为负。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void add(long x) &#123;</span><br><span class="line">    // as是Striped64中的cells属性</span><br><span class="line">    // b是Striped64中的base属性</span><br><span class="line">    // v是当前线程hash到的Cell中存储的值</span><br><span class="line">    // m是cells的长度减1，hash时作为掩码使用</span><br><span class="line">    // a是当前线程hash到的Cell</span><br><span class="line">    Cell[] as; long b, v; int m; Cell a;</span><br><span class="line">    // 条件1：cells不为空，说明出现过竞争，cells已经创建</span><br><span class="line">    // 条件2：cas操作base失败，说明其它线程先一步修改了base，正在出现竞争</span><br><span class="line">    if ((as = cells) != null || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        // true表示当前竞争还不激烈</span><br><span class="line">        // false表示竞争激烈，多个线程hash到同一个Cell，可能要扩容</span><br><span class="line">        boolean uncontended = true;</span><br><span class="line">        // 条件1：cells为空，说明正在出现竞争，上面是从条件2过来的</span><br><span class="line">        // 条件2：应该不会出现</span><br><span class="line">        // 条件3：当前线程所在的Cell为空，说明当前线程还没有更新过Cell，应初始化一个Cell</span><br><span class="line">        // 条件4：更新当前线程所在的Cell失败，说明现在竞争很激烈，多个线程hash到了同一个Cell，应扩容</span><br><span class="line">        if (as == null || (m = as.length - 1) &lt; 0 ||</span><br><span class="line">            // getProbe()方法返回的是线程中的threadLocalRandomProbe字段</span><br><span class="line">            // 它是通过随机数生成的一个值，对于一个确定的线程这个值是固定的</span><br><span class="line">            // 除非刻意修改它</span><br><span class="line">            (a = as[getProbe() &amp;amp; m]) == null ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            // 调用Striped64中的方法处理</span><br><span class="line">            longAccumulate(x, null, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）最初无竞争时只更新base；</p>
<p>（2）直到更新base失败时，创建cells数组；</p>
<p>（3）当多个线程竞争同一个Cell比较激烈时，可能要扩容；</p>
<h2 id="longAccumulate-方法"><a href="#longAccumulate-方法" class="headerlink" title="longAccumulate()方法"></a>longAccumulate()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">final void longAccumulate(long x, LongBinaryOperator fn,</span><br><span class="line">                              boolean wasUncontended) &#123;</span><br><span class="line">    // 存储线程的probe值</span><br><span class="line">    int h;</span><br><span class="line">    // 如果getProbe()方法返回0，说明随机数未初始化</span><br><span class="line">    if ((h = getProbe()) == 0) &#123;</span><br><span class="line">        // 强制初始化</span><br><span class="line">        ThreadLocalRandom.current(); // force initialization</span><br><span class="line">        // 重新获取probe值</span><br><span class="line">        h = getProbe();</span><br><span class="line">        // 都未初始化，肯定还不存在竞争激烈</span><br><span class="line">        wasUncontended = true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 是否发生碰撞</span><br><span class="line">    boolean collide = false;                // True if last slot nonempty</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Cell[] as; Cell a; int n; long v;</span><br><span class="line">        // cells已经初始化过</span><br><span class="line">        if ((as = cells) != null &amp;amp;&amp;amp; (n = as.length) &gt; 0) &#123;</span><br><span class="line">            // 当前线程所在的Cell未初始化</span><br><span class="line">            if ((a = as[(n - 1) &amp;amp; h]) == null) &#123;</span><br><span class="line">                // 当前无其它线程在创建或扩容cells，也没有线程在创建Cell</span><br><span class="line">                if (cellsBusy == 0) &#123;       // Try to attach new Cell</span><br><span class="line">                    // 新建一个Cell，值为当前需要增加的值</span><br><span class="line">                    Cell r = new Cell(x);   // Optimistically create</span><br><span class="line">                    // 再次检测cellsBusy，并尝试更新它为1</span><br><span class="line">                    // 相当于当前线程加锁</span><br><span class="line">                    if (cellsBusy == 0 &amp;amp;&amp;amp; casCellsBusy()) &#123;</span><br><span class="line">                        // 是否创建成功</span><br><span class="line">                        boolean created = false;</span><br><span class="line">                        try &#123;               // Recheck under lock</span><br><span class="line">                            Cell[] rs; int m, j;</span><br><span class="line">                            // 重新获取cells，并找到当前线程hash到cells数组中的位置</span><br><span class="line">                            // 这里一定要重新获取cells，因为as并不在锁定范围内</span><br><span class="line">                            // 有可能已经扩容了，这里要重新获取</span><br><span class="line">                            if ((rs = cells) != null &amp;amp;&amp;amp;</span><br><span class="line">                                (m = rs.length) &gt; 0 &amp;amp;&amp;amp;</span><br><span class="line">                                rs[j = (m - 1) &amp;amp; h] == null) &#123;</span><br><span class="line">                                // 把上面新建的Cell放在cells的j位置处</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                // 创建成功</span><br><span class="line">                                created = true;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            // 相当于释放锁</span><br><span class="line">                            cellsBusy = 0;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 创建成功了就返回</span><br><span class="line">                        // 值已经放在新建的Cell里面了</span><br><span class="line">                        if (created)</span><br><span class="line">                            break;</span><br><span class="line">                        continue;           // Slot is now non-empty</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 标记当前未出现冲突</span><br><span class="line">                collide = false;</span><br><span class="line">            &#125;</span><br><span class="line">            // 当前线程所在的Cell不为空，且更新失败了</span><br><span class="line">            // 这里简单地设为true，相当于简单地自旋一次</span><br><span class="line">            // 通过下面的语句修改线程的probe再重新尝试</span><br><span class="line">            else if (!wasUncontended)       // CAS already known to fail</span><br><span class="line">                wasUncontended = true;      // Continue after rehash</span><br><span class="line">            // 再次尝试CAS更新当前线程所在Cell的值，如果成功了就返回</span><br><span class="line">            else if (a.cas(v = a.value, ((fn == null) ? v + x :</span><br><span class="line">                                         fn.applyAsLong(v, x))))</span><br><span class="line">                break;</span><br><span class="line">            // 如果cells数组的长度达到了CPU核心数，或者cells扩容了</span><br><span class="line">            // 设置collide为false并通过下面的语句修改线程的probe再重新尝试</span><br><span class="line">            else if (n &gt;= NCPU || cells != as)</span><br><span class="line">                collide = false;            // At max size or stale</span><br><span class="line">            // 上上个elseif都更新失败了，且上个条件不成立，说明出现冲突了</span><br><span class="line">            else if (!collide)</span><br><span class="line">                collide = true;</span><br><span class="line">            // 明确出现冲突了，尝试占有锁，并扩容</span><br><span class="line">            else if (cellsBusy == 0 &amp;amp;&amp;amp; casCellsBusy()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 检查是否有其它线程已经扩容过了</span><br><span class="line">                    if (cells == as) &#123;      // Expand table unless stale</span><br><span class="line">                        // 新数组为原数组的两倍</span><br><span class="line">                        Cell[] rs = new Cell[n &lt;&lt; 1];</span><br><span class="line">                        // 把旧数组元素拷贝到新数组中</span><br><span class="line">                        for (int i = 0; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        // 重新赋值cells为新数组</span><br><span class="line">                        cells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    // 释放锁</span><br><span class="line">                    cellsBusy = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                // 已解决冲突</span><br><span class="line">                collide = false;</span><br><span class="line">                // 使用扩容后的新数组重新尝试</span><br><span class="line">                continue;                   // Retry with expanded table</span><br><span class="line">            &#125;</span><br><span class="line">            // 更新失败或者达到了CPU核心数，重新生成probe，并重试</span><br><span class="line">            h = advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        // 未初始化过cells数组，尝试占有锁并初始化cells数组</span><br><span class="line">        else if (cellsBusy == 0 &amp;amp;&amp;amp; cells == as &amp;amp;&amp;amp; casCellsBusy()) &#123;</span><br><span class="line">            // 是否初始化成功</span><br><span class="line">            boolean init = false;</span><br><span class="line">            try &#123;                           // Initialize table</span><br><span class="line">                // 检测是否有其它线程初始化过</span><br><span class="line">                if (cells == as) &#123;</span><br><span class="line">                    // 新建一个大小为2的Cell数组</span><br><span class="line">                    Cell[] rs = new Cell[2];</span><br><span class="line">                    // 找到当前线程hash到数组中的位置并创建其对应的Cell</span><br><span class="line">                    rs[h &amp;amp; 1] = new Cell(x);</span><br><span class="line">                    // 赋值给cells数组</span><br><span class="line">                    cells = rs;</span><br><span class="line">                    // 初始化成功</span><br><span class="line">                    init = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // 释放锁</span><br><span class="line">                cellsBusy = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            // 初始化成功直接返回</span><br><span class="line">            // 因为增加的值已经同时创建到Cell中了</span><br><span class="line">            if (init)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果有其它线程在初始化cells数组中，就尝试更新base</span><br><span class="line">        // 如果成功了就返回</span><br><span class="line">        else if (casBase(v = base, ((fn == null) ? v + x :</span><br><span class="line">                                    fn.applyAsLong(v, x))))</span><br><span class="line">            break;                          // Fall back on using base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）如果cells数组未初始化，当前线程会尝试占有cellsBusy锁并创建cells数组；</p>
<p>（2）如果当前线程尝试创建cells数组时，发现有其它线程已经在创建了，就尝试更新base，如果成功就返回；</p>
<p>（3）通过线程的probe值找到当前线程应该更新cells数组中的哪个Cell；</p>
<p>（4）如果当前线程所在的Cell未初始化，就占有占有cellsBusy锁并在相应的位置创建一个Cell；</p>
<p>（5）尝试CAS更新当前线程所在的Cell，如果成功就返回，如果失败说明出现冲突；</p>
<p>（5）当前线程更新Cell失败后并不是立即扩容，而是尝试更新probe值后再重试一次；</p>
<p>（6）如果在重试的时候还是更新失败，就扩容；</p>
<p>（7）扩容时当前线程占有cellsBusy锁，并把数组容量扩大到两倍，再迁移原cells数组中元素到新数组中；</p>
<p>（8）cellsBusy在创建cells数组、创建Cell、扩容cells数组三个地方用到；</p>
<h2 id="sum-方法"><a href="#sum-方法" class="headerlink" title="sum()方法"></a>sum()方法</h2><p>sum()方法是获取LongAdder中真正存储的值的大小，通过把base和所有段相加得到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public long sum() &#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    // sum初始等于base</span><br><span class="line">    long sum = base;</span><br><span class="line">    // 如果cells不为空</span><br><span class="line">    if (as != null) &#123;</span><br><span class="line">        // 遍历所有的Cell</span><br><span class="line">        for (int i = 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">            // 如果所在的Cell不为空，就把它的value累加到sum中</span><br><span class="line">            if ((a = as[i]) != null)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回sum</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到sum()方法是把base和所有段的值相加得到，那么，这里有一个问题，如果前面已经累加到sum上的Cell的value有修改，不是就没法计算到了么？</p>
<p>答案确实如此，所以LongAdder可以说不是强一致性的，它是最终一致性的。</p>
<h2 id="LongAdder-VS-AtomicLong"><a href="#LongAdder-VS-AtomicLong" class="headerlink" title="LongAdder VS AtomicLong"></a>LongAdder VS AtomicLong</h2><p>直接上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public class LongAdderVSAtomicLongTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        testAtomicLongVSLongAdder(1, 10000000);</span><br><span class="line">        testAtomicLongVSLongAdder(10, 10000000);</span><br><span class="line">        testAtomicLongVSLongAdder(20, 10000000);</span><br><span class="line">        testAtomicLongVSLongAdder(40, 10000000);</span><br><span class="line">        testAtomicLongVSLongAdder(80, 10000000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void testAtomicLongVSLongAdder(final int threadCount, final int times)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;threadCount：&quot; + threadCount + &quot;, times：&quot; + times);</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            testLongAdder(threadCount, times);</span><br><span class="line">            System.out.println(&quot;LongAdder elapse：&quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;);</span><br><span class="line"></span><br><span class="line">            long start2 = System.currentTimeMillis();</span><br><span class="line">            testAtomicLong(threadCount, times);</span><br><span class="line">            System.out.println(&quot;AtomicLong elapse：&quot; + (System.currentTimeMillis() - start2) + &quot;ms&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void testAtomicLong(final int threadCount, final int times) throws InterruptedException &#123;</span><br><span class="line">        AtomicLong atomicLong = new AtomicLong();</span><br><span class="line">        List&lt;Thread&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i=0;i&lt;threadCount;i++)&#123;</span><br><span class="line">            list.add(new Thread(() -&gt; &#123;</span><br><span class="line">                for (int j = 0; j&lt;times; j++)&#123;</span><br><span class="line">                    atomicLong.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (Thread thread : list)&#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (Thread thread : list)&#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void testLongAdder(final int threadCount, final int times) throws InterruptedException &#123;</span><br><span class="line">        LongAdder longAdder = new LongAdder();</span><br><span class="line">        List&lt;Thread&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i=0;i&lt;threadCount;i++)&#123;</span><br><span class="line">            list.add(new Thread(() -&gt; &#123;</span><br><span class="line">                for (int j = 0; j&lt;times; j++)&#123;</span><br><span class="line">                    longAdder.add(1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (Thread thread : list)&#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (Thread thread : list)&#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">threadCount：1, times：10000000</span><br><span class="line">LongAdder elapse：158ms</span><br><span class="line">AtomicLong elapse：64ms</span><br><span class="line">threadCount：10, times：10000000</span><br><span class="line">LongAdder elapse：206ms</span><br><span class="line">AtomicLong elapse：2449ms</span><br><span class="line">threadCount：20, times：10000000</span><br><span class="line">LongAdder elapse：429ms</span><br><span class="line">AtomicLong elapse：5142ms</span><br><span class="line">threadCount：40, times：10000000</span><br><span class="line">LongAdder elapse：840ms</span><br><span class="line">AtomicLong elapse：10506ms</span><br><span class="line">threadCount：80, times：10000000</span><br><span class="line">LongAdder elapse：1369ms</span><br><span class="line">AtomicLong elapse：20482ms</span><br></pre></td></tr></table></figure>

<p>可以看到当只有一个线程的时候，AtomicLong反而性能更高，随着线程越来越多，AtomicLong的性能急剧下降，而LongAdder的性能影响很小。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>（1）LongAdder通过base和cells数组来存储值；</p>
<p>（2）不同的线程会hash到不同的cell上去更新，减少了竞争；</p>
<p>（3）LongAdder的性能非常高，最终会达到一种无竞争的状态；</p>
<h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>在longAccumulate()方法中有个条件是<code>n &gt;= NCPU</code>就不会走到扩容逻辑了，而n是2的倍数，那是不是代表cells数组最大只能达到大于等于NCPU的最小2次方？</p>
<p>答案是明确的。因为同一个CPU核心同时只会运行一个线程，而更新失败了说明有两个不同的核心更新了同一个Cell，这时会重新设置更新失败的那个线程的probe值，这样下一次它所在的Cell很大概率会发生改变，如果运行的时间足够长，最终会出现同一个核心的所有线程都会hash到同一个Cell（大概率，但不一定全在一个Cell上）上去更新，所以，这里cells数组中长度并不需要太长，达到CPU核心数足够了。</p>
<p>比如，笔者的电脑是8核的，所以这里cells的数组最大只会到8，达到8就不会扩容了。</p>
<p><img src="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/LongAdder2.png" alt="LongAdder"></p>
<hr>
<p>欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。</p>
<p><img src="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode_ss.jpg" alt="qrcode"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/13/死磕java并发包之LongAdder源码分析/" data-id="cjwkcoovj001kn02a210aknyt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-深入了解Synchronized原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/12/深入了解Synchronized原理/" class="article-date">
  <time datetime="2019-05-12T14:57:08.008Z" itemprop="datePublished">2019-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/12/深入了解Synchronized原理/">深入了解Synchronized原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5ccd84dee51d456e3428c1af" target="_blank" rel="noopener">https://juejin.im/post/5ccd84dee51d456e3428c1af</a> </p>
</blockquote>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><h3 id="互斥性"><a href="#互斥性" class="headerlink" title="互斥性"></a>互斥性</h3><p>同一个时间只允许一个线程拥有一个对象锁，这样在同一时间只有一个线程对需要同步的代码块进行访问</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>必须确保在某个线程的某个对象锁在释放之前，对某个共享变量所做的改变，对于下一个拥有在这个对象锁的线程是可见的，否则另外线程读取的是本地的副本从而进行操作，导致结果不一致。</p>
<h3 id="重入性"><a href="#重入性" class="headerlink" title="重入性"></a>重入性</h3><p>从互斥锁的设计上来说，一个线程试图操作一个由其他线程持有的临界资源的时候，这个线程会处于堵塞状态。</p>
<p>如果一个线程再次请求自己持有对象锁的临界资源的时候，这就属于重入锁。</p>
<p>因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性。</p>
<h3 id="获取对象锁的方式"><a href="#获取对象锁的方式" class="headerlink" title="获取对象锁的方式"></a>获取对象锁的方式</h3><h3 id="获取对象锁的方式-1"><a href="#获取对象锁的方式-1" class="headerlink" title="获取对象锁的方式"></a>获取对象锁的方式</h3><pre><code>1. 修饰实例方法，作用于当前实例加锁，进行同步代码块之前需要获得当前实例的锁（Synchronized method）
1. 修饰代码块，指定加锁对象，作用于给定对象加锁，进入同步代码快之前要获得给定对象的锁（Synchronized instance）
1. 修饰静态方法，作用于当前类对象加锁，进入同步代码块之前要获得当前类对象的锁（Synchronized static method）
1. 修饰类对象，作用于类对象加锁，进入同步代码块之前要获得指定类对象的锁（Synchronized /*/*.class）</code></pre><h3 id="对象锁和类锁的区别"><a href="#对象锁和类锁的区别" class="headerlink" title="对象锁和类锁的区别"></a>对象锁和类锁的区别</h3><pre><code>1. 一个线程可以访问对象的同步代码块时，另外一个线程也可以访问同一个对象的非同步代码块
1. 若锁住的是同一个对象，其他线程访问对象的同步代码块或者同步方法的时候会被阻塞
1. 同一个类的不同对象的对象锁互不干扰
1. 类锁是一种特殊的锁，因为类就是Class的实例，所以只要不同对象都是属于同一个类，那么他们的类锁都是一样的
1. 类锁和对象锁互不干扰</code></pre><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><img src="https://user-gold-cdn.xitu.io/2019/5/4/16a82cef40900b6b?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p><strong>锁对象</strong>存储在Java对象头里面</p>
<table>
<thead>
<tr>
<th align="center">位数</th>
<th align="center">头对象结构</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">32</td>
<td align="center">Mark word</td>
<td align="center">存储对象的HashCode,GC分代年龄，锁类型，锁标记</td>
</tr>
<tr>
<td align="center">32</td>
<td align="center">Class MeteDataAddress</td>
<td align="center">类型指针：指向实例对象所属的类</td>
</tr>
</tbody></table>
<p>MarkWord被设定为一个非固定的数据结构，用来存储更多的数据，结构如下（这里不是很懂）</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/4/16a82cef40c43f45?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>Monitor（内部锁，Monitor锁，管程，监视器锁，也就是和对象锁对应的对象）</p>
<p>每个对象都存在这一个Monitor与之关联</p>
<p>每个Java对象天生带有这把看不见的锁，在MarkWord的结构中，重量级锁的标记为是10，也就是指针就是指向Monitor对象的起始地址，在这里也就说明了Synchronized的默认锁是重量级锁。monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当<strong>一个 monitor 被某个线程持有后，它便处于锁定状态</strong>。</p>
<p>在Java虚拟机中，Monitor是有MonitorObject所实现的，部分结构如下</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/4/16a82cef411d31aa?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>_owner：指向持有ObjectMonitor对象的线程</p>
<p>_WaitSet：存放处于wait状态的线程队列</p>
<p>_EntryList：存放处于等待锁block状态的线程队列</p>
<p>_count：用来记录该线程获取锁的次数</p>
<p>ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向<strong>持有</strong>ObjectMonitor对象的线程，当有多个线程访问同一块同步代码块的时候，线程会线程会进入_EntryList，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1，若线程调用 wait() 方法，<strong>将释放当前持有的monitor，owner变量恢复为null</strong>，count自减1，同时该线程进入 WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。</p>
<p><strong>Monitorenter和Monitorexit</strong></p>
<p><strong>Synchronized代码块执行原理</strong></p>
<p>字节码中可知同步语句块的实现使用的是<strong>monitorenter</strong> 和 <strong>monitorexit</strong> 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置 。当执行monitorenter指令时，如果当前线程获取<strong>对象锁所对应的monitor的特权</strong>的时候</p>
<p>1 会去检查monitor的对象的count是否为0</p>
<p>2 如果为0的话就获取成功，并且将count置为1</p>
<p>3 倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。</p>
<p>编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。一般字节码文件中都会多出一条monitorexit指令。</p>
<p><strong>Synchronized方法执行原理</strong></p>
<p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从<strong>ACC_SYNCHRONIZED</strong> 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会检查方法的 <strong>ACC_SYNCHRONIZED</strong> 访问标志是否被设置，如果设置了，执行线程将先持有monitor，然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。</p>
<p>如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放</p>
<h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><p><strong>自旋锁</strong></p>
<p>synchronized在jdk1.6之前的锁是重量级锁，对于互斥同步的性能来说，阻塞挂起的是影响最大的。因为挂起线程和恢复线程都是要让操作系统从<strong>用户态</strong>转化到<strong>内核态</strong>中完成，而这两个状态的转换是比较影响性能的。</p>
<p>大多数情况下，线程拥有锁的时间不会太长，如果直接挂起的话，会影响系统的性能。因为前面说过，线程切换是需要在操作系统的用户态和内核态之间转换的。所以为了解决这个问题，引进了自旋锁。</p>
<p>自旋锁假设在不久，当前线程可以获得这个锁，因此JVM就让这个想要获得锁的线程，先做几个空循环先，让这个线程先不要放弃占有CPU资源的机会，经过若干次空循环之后，如果获得锁，那么就顺利的进入临界区。否则，你也不能让这个线程一直占有CPU资源呀，所以经过大概10次空循环之后，就只能老老实实地挂起了。</p>
<p><strong>自旋适应锁</strong></p>
<p>自旋适应锁就是从自旋锁改进而来的。在自旋锁的基础上，假如A线程通过自旋一定的时间之后获得了锁，然后释放锁。这时B线程也获得了这个锁，如果此时A线程再次想得到这个锁，那么JVM就会根据之前A线程曾经获得过这个锁，那么我就给你适当地增加一点空循环的次数，比如说从10次空循环到100次。假如有个C线程，他也想获得这个锁，也得自旋等待，可是很少轮到他或者没得到过这个锁（可能是被A抢了机会或者其他的），那么JVM就会认为C线程以后可能没什么机会获得了，就适当地减少C线程的空循坏次数甚至不让他做空循环。</p>
<p><strong>偏向锁</strong></p>
<p>如果A线程第一次获得锁，那么锁就进入偏向模式（虚拟机把对象头中的标志位设为“01”），MarkWord的结构也变成偏向锁结构，如果没有其他线程和A线程竞争，A线程再次请求该锁时，无需任何同步操作</p>
<p><strong>只需要检查MarkWord的锁标记位是否为偏向锁和当前线程的Id是否为ThreadId即可。</strong></p>
<p>也就是说当一个线程访问同步块并且获取锁的时候，会通过<strong>CAS操作</strong>在对象头的偏向锁结构里记录线程的ID，如果记录成功，线程在进入和退出同步块时，<strong>不需要进行CAS操作来加锁和解锁</strong>，从而提高程序的性能。</p>
<p>TIPS:偏向锁只能被第一个获取它的线程进行 CAS 操作，一旦出现线程竞争锁对象，其它线程无论何时进行 CAS 操作都会失败。</p>
<p>加锁具体步骤如下</p>
<pre><code>1. </code></pre><p>先检查Mark Word是否为可偏向状态，也就是说是否 是偏向锁1，锁标识位为01<br>    1.<br>如果是<strong>可偏向状态</strong>，那么就测试Mark Word结构的线程ID是不是和当前线程的ID一致，</p>
<p>如果是就直接执行同步代码块。</p>
<p>如果不是就通过CAS操作竞争锁，</p>
<p>如果操作成功，就把Mark Word的线程ID设置为线程的ID</p>
<p>如果操作失败，那么就说明此时有<strong>多线程竞争</strong>的状态，等到安全点，获得偏向锁的线程就挂起，进行解锁操作。偏向锁升级为轻量锁，被阻塞在安全点的线程继续往下执行同步代码块。</p>
<p>解锁</p>
<p>当获得偏向锁的<strong>线程挂起</strong>之后，就会进行解锁操作。</p>
<p>在解锁成功之后，JVM判断此时线程的状态，</p>
<p>如果还没有执行完同步代码，则直接将偏向锁升级为轻量级锁，然后继续执行剩下的代码块。</p>
<p>如果此时已经执行完同步代码，则撤销锁为<strong>无锁状态</strong>，以后执行同步代码的时候JVM则会直接升级为轻量锁。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/4/16a82cef41476b9a?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p><strong>轻量锁</strong>（加锁解锁操作是需要依赖多次CAS原子指令的）</p>
<p>偏向锁一旦受到多线程竞争，就会膨胀为轻量锁</p>
<p>获取锁</p>
<pre><code>1. 先判断当前对象是否处于无锁状态，如果是，JVM就首先在想要获取这个锁的线程的栈帧中建立一个锁记录（Lock Record）的空间，其中header部分用来存储Mark Word的备份，否则执行3。
1. JVM利用CAS操作尝试将对象的Mark Word更新为指向锁记录的指针，如果成功，那么就获得轻量锁，就将标志位设置为00，执行同步代码块，否则执行3。
1. 判断当前对象的Mark Word是否指向当前想要竞争的线程的锁记录，如果是表示则该线程拥有这个轻量锁，继续执行同步代码块，也就是重入。否则，说明这个轻量锁已经被其他线程拥有，那么这个先进行**自旋**获取锁，如果一直没有得到锁，那么轻量锁则要膨胀为重量锁（也就是将标记为设置为10），锁标记设置为10，后面等待的线程则会进入阻塞状态，如果通过自旋成功获取了锁，那么轻量锁不会膨胀为重量锁。</code></pre><p>释放锁</p>
<pre><code>1. 取出线程锁记录之前保存的轻量锁的Mark Word记录，通过CAS操作将取出的记录替换当前对象的Mark Word中
1. 判断当前对象的Mark Word是否指向当前线程的锁记录
1. 如果1,2都成功，那么就成功释放锁
1. 如果1失败，那么就是之前有过线程对当前对象的锁竞争过，但是失败了，由轻量级锁变为重量级锁，导致Mark Word的结够发生了改变。那么后面就释放锁，唤醒等待的线程，进行新一轮的竞争。</code></pre><p><img src="https://user-gold-cdn.xitu.io/2019/5/4/16a82cef42898e7d?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p><strong>重量级锁</strong></p>
<p>重量级锁通过对象内部的监视器（monitor）实现</p>
<p>其中monitor的本质是依赖于底层操作系统的Mutex Lock实现</p>
<p>操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p>
<h3 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h3><p>锁主要存在四种状态，无状态锁，偏向锁，轻量锁，重量锁，会随着线程竞争的程度逐渐增大。锁只可以单向升级，不可以降级。</p>
<p>主要是为了提高获得锁和解锁的效率。</p>
<h3 id="各个状态锁的优缺点对比"><a href="#各个状态锁的优缺点对比" class="headerlink" title="各个状态锁的优缺点对比"></a>各个状态锁的优缺点对比</h3><table>
<thead>
<tr>
<th align="center">锁类型</th>
<th align="center">特征</th>
<th align="center">优点</th>
<th align="center">缺点</th>
<th align="center">使用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">偏向锁</td>
<td align="center">只需要比较ThreadId</td>
<td align="center">加锁和解锁不需要额外的消耗，和执行非同步代码块时间相差无几</td>
<td align="center">如果线程之间有竞争，会增加锁撤销的消耗</td>
<td align="center">当程序大部分只有一个线程操作的时候</td>
</tr>
<tr>
<td align="center">轻量锁</td>
<td align="center">自旋</td>
<td align="center">竞争线程不会阻塞，提高了程序的响应速度</td>
<td align="center">始终得不到锁的线程使用自旋会消耗CPU</td>
<td align="center">追求响应时间，同步执行代码比较快的时候</td>
</tr>
<tr>
<td align="center">重量锁</td>
<td align="center">依赖Mutex（操作系统的互斥）</td>
<td align="center">线程竞争不使用自旋，不怎么会消耗CPU</td>
<td align="center">线程阻塞，响应缓慢</td>
<td align="center">同步代码执行比较慢的情况</td>
</tr>
</tbody></table>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这里有一张原理图（盗用别人的图），把上述的文字都进行了一个总结</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/4/16a82cef42a0936d?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.im/entry/589981fc1b69e60059a2156a" target="_blank" rel="noopener">juejin.im/entry/58998…</a></p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fchampionhengyi%2Farticle%2Fdetails%2F80105718" target="_blank" rel="noopener">blog.csdn.net/championhen…</a></p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fjavazejian%2Farticle%2Fdetails%2F72828483" target="_blank" rel="noopener">blog.csdn.net/javazejian/…</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/12/深入了解Synchronized原理/" data-id="cjwkcoovk001mn02azgkgwmw4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HDFS/">HDFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactor/">Reactor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/">RxJava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue-js/">Vue.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端/">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微服务/">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/HDFS/" style="font-size: 10px;">HDFS</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Reactor/" style="font-size: 10px;">Reactor</a> <a href="/tags/RxJava/" style="font-size: 10px;">RxJava</a> <a href="/tags/Spring/" style="font-size: 13.33px;">Spring</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP/IP</a> <a href="/tags/Vue-js/" style="font-size: 10px;">Vue.js</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/后端/" style="font-size: 10px;">后端</a> <a href="/tags/微服务/" style="font-size: 10px;">微服务</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/服务器/" style="font-size: 10px;">服务器</a> <a href="/tags/架构/" style="font-size: 16.67px;">架构</a> <a href="/tags/源码/" style="font-size: 10px;">源码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/06/面试那点小事，你从未见过的springboot面试集锦（附详细答案）/">面试那点小事，你从未见过的spring boot面试集锦（附详细答案）</a>
          </li>
        
          <li>
            <a href="/2019/06/01/SpringBoot实现动态控制定时任务-支持多参数/">SpringBoot实现动态控制定时任务-支持多参数</a>
          </li>
        
          <li>
            <a href="/2019/05/31/感受lambda之美，推荐收藏，需要时查阅/">感受lambda之美，推荐收藏，需要时查阅</a>
          </li>
        
          <li>
            <a href="/2019/05/30/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/05/30/Effective Java/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 huan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>