<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>HUAN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="HUAN">
<meta property="og:url" content="http://sillyfan.top/index.html">
<meta property="og:site_name" content="HUAN">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HUAN">
  
    <link rel="alternate" href="/atom.xml" title="HUAN" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HUAN</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://sillyfan.top"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-SpringBoot实现动态控制定时任务-支持多参数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/01/SpringBoot实现动态控制定时任务-支持多参数/" class="article-date">
  <time datetime="2019-06-01T15:51:17.017Z" itemprop="datePublished">2019-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/01/SpringBoot实现动态控制定时任务-支持多参数/">SpringBoot实现动态控制定时任务-支持多参数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5cf099556fb9a07ef2010716" target="_blank" rel="noopener">https://juejin.im/post/5cf099556fb9a07ef2010716</a><br>由于工作上的原因，需要进行定时任务的动态增删改查，网上大部分资料都是整合quertz框架实现的。本人查阅了一些资料，发现springBoot本身就支持实现定时任务的动态控制。并进行改进，现支持任意多参数定时任务配置</p>
</blockquote>
<p>实现结果如下图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/31/16b0be286b6a031a?imageView2/0/w/1280/h/960/ignore-error/1" alt> 后台测试显示如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/31/16b0bf1a0e118b4b?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>github 简单demo地址如下： <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fcaotinging%2Fsimple-demo%2Ftree%2Fmaster%2Fspringboot-dynamic-task" target="_blank" rel="noopener">springboot-dynamic-task</a></p>
<h3 id="1-定时任务的配置类：SchedulingConfig"><a href="#1-定时任务的配置类：SchedulingConfig" class="headerlink" title="1.定时任务的配置类：SchedulingConfig"></a>1.定时任务的配置类：SchedulingConfig</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.scheduling.TaskScheduler;</span><br><span class="line">import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @program: simple-demo</span><br><span class="line"> * @description: 定时任务配置类</span><br><span class="line"> * @author: CaoTing</span><br><span class="line"> * @date: 2019/5/23</span><br><span class="line"> **/</span><br><span class="line">@Configuration</span><br><span class="line">public class SchedulingConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public TaskScheduler taskScheduler() &#123;</span><br><span class="line">        ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();</span><br><span class="line">        // 定时任务执行线程池核心线程数</span><br><span class="line">        taskScheduler.setPoolSize(4);</span><br><span class="line">        taskScheduler.setRemoveOnCancelPolicy(true);</span><br><span class="line">        taskScheduler.setThreadNamePrefix(&quot;TaskSchedulerThreadPool-&quot;);</span><br><span class="line">        return taskScheduler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-定时任务注册类：CronTaskRegistrar"><a href="#2-定时任务注册类：CronTaskRegistrar" class="headerlink" title="2.定时任务注册类：CronTaskRegistrar"></a>2.定时任务注册类：CronTaskRegistrar</h3><p>这个类包含了新增定时任务，移除定时任务等等核心功能方法<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">import com.caotinging.demo.task.ScheduledTask;</span><br><span class="line">import org.springframework.beans.factory.DisposableBean;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.scheduling.TaskScheduler;</span><br><span class="line">import org.springframework.scheduling.config.CronTask;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @program: simple-demo</span><br><span class="line"> * @description: 添加定时任务注册类，用来增加、删除定时任务。</span><br><span class="line"> * @author: CaoTing</span><br><span class="line"> * @date: 2019/5/23</span><br><span class="line"> **/</span><br><span class="line">@Component</span><br><span class="line">public class CronTaskRegistrar implements DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    private final Map&lt;Runnable, ScheduledTask&gt; scheduledTasks = new ConcurrentHashMap&lt;&gt;(16);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private TaskScheduler taskScheduler;</span><br><span class="line"></span><br><span class="line">    public TaskScheduler getScheduler() &#123;</span><br><span class="line">        return this.taskScheduler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增定时任务</span><br><span class="line">     * @param task</span><br><span class="line">     * @param cronExpression</span><br><span class="line">     */</span><br><span class="line">    public void addCronTask(Runnable task, String cronExpression) &#123;</span><br><span class="line">        addCronTask(new CronTask(task, cronExpression));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addCronTask(CronTask cronTask) &#123;</span><br><span class="line">        if (cronTask != null) &#123;</span><br><span class="line">            Runnable task = cronTask.getRunnable();</span><br><span class="line">            if (this.scheduledTasks.containsKey(task)) &#123;</span><br><span class="line">                removeCronTask(task);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.scheduledTasks.put(task, scheduleCronTask(cronTask));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除定时任务</span><br><span class="line">     * @param task</span><br><span class="line">     */</span><br><span class="line">    public void removeCronTask(Runnable task) &#123;</span><br><span class="line">        ScheduledTask scheduledTask = this.scheduledTasks.remove(task);</span><br><span class="line">        if (scheduledTask != null)</span><br><span class="line">            scheduledTask.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ScheduledTask scheduleCronTask(CronTask cronTask) &#123;</span><br><span class="line">        ScheduledTask scheduledTask = new ScheduledTask();</span><br><span class="line">        scheduledTask.future = this.taskScheduler.schedule(cronTask.getRunnable(), cronTask.getTrigger());</span><br><span class="line"></span><br><span class="line">        return scheduledTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        for (ScheduledTask task : this.scheduledTasks.values()) &#123;</span><br><span class="line">            task.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        this.scheduledTasks.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-定时任务执行类：SchedulingRunnable"><a href="#3-定时任务执行类：SchedulingRunnable" class="headerlink" title="3.定时任务执行类：SchedulingRunnable"></a>3.定时任务执行类：SchedulingRunnable</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">import com.caotinging.demo.utils.SpringContextUtils;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.util.ReflectionUtils;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.Objects;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @program: simple-demo</span><br><span class="line"> * @description: 定时任务运行类</span><br><span class="line"> * @author: CaoTing</span><br><span class="line"> * @date: 2019/5/23</span><br><span class="line"> **/</span><br><span class="line">public class SchedulingRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(SchedulingRunnable.class);</span><br><span class="line"></span><br><span class="line">    private String beanName;</span><br><span class="line"></span><br><span class="line">    private String methodName;</span><br><span class="line"></span><br><span class="line">    private Object[] params;</span><br><span class="line"></span><br><span class="line">    public SchedulingRunnable(String beanName, String methodName) &#123;</span><br><span class="line">        this(beanName, methodName, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SchedulingRunnable(String beanName, String methodName, Object...params ) &#123;</span><br><span class="line">        this.beanName = beanName;</span><br><span class="line">        this.methodName = methodName;</span><br><span class="line">        this.params = params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        logger.info(&quot;定时任务开始执行 - bean：&#123;&#125;，方法：&#123;&#125;，参数：&#123;&#125;&quot;, beanName, methodName, params);</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Object target = SpringContextUtils.getBean(beanName);</span><br><span class="line"></span><br><span class="line">            Method method = null;</span><br><span class="line">            if (null != params &amp;amp;&amp;amp; params.length &gt; 0) &#123;</span><br><span class="line">                Class&lt;?&gt;[] paramCls = new Class[params.length];</span><br><span class="line">                for (int i = 0; i &lt; params.length; i++) &#123;</span><br><span class="line">                    paramCls[i] = params[i].getClass();</span><br><span class="line">                &#125;</span><br><span class="line">                method = target.getClass().getDeclaredMethod(methodName, paramCls);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                method = target.getClass().getDeclaredMethod(methodName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ReflectionUtils.makeAccessible(method);</span><br><span class="line">            if (null != params &amp;amp;&amp;amp; params.length &gt; 0) &#123;</span><br><span class="line">                method.invoke(target, params);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                method.invoke(target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            logger.error(String.format(&quot;定时任务执行异常 - bean：%s，方法：%s，参数：%s &quot;, beanName, methodName, params), ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long times = System.currentTimeMillis() - startTime;</span><br><span class="line">        logger.info(&quot;定时任务执行结束 - bean：&#123;&#125;，方法：&#123;&#125;，参数：&#123;&#125;，耗时：&#123;&#125; 毫秒&quot;, beanName, methodName, params, times);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass()) return false;</span><br><span class="line">        SchedulingRunnable that = (SchedulingRunnable) o;</span><br><span class="line">        if (params == null) &#123;</span><br><span class="line">            return beanName.equals(that.beanName) &amp;amp;&amp;amp;</span><br><span class="line">                    methodName.equals(that.methodName) &amp;amp;&amp;amp;</span><br><span class="line">                    that.params == null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return beanName.equals(that.beanName) &amp;amp;&amp;amp;</span><br><span class="line">                methodName.equals(that.methodName) &amp;amp;&amp;amp;</span><br><span class="line">                params.equals(that.params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        if (params == null) &#123;</span><br><span class="line">            return Objects.hash(beanName, methodName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return Objects.hash(beanName, methodName, params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-定时任务控制类：ScheduledTask"><a href="#4-定时任务控制类：ScheduledTask" class="headerlink" title="4.定时任务控制类：ScheduledTask"></a>4.定时任务控制类：ScheduledTask</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ScheduledFuture;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @program: simple-demo</span><br><span class="line"> * @description: 定时任务控制类</span><br><span class="line"> * @author: CaoTing</span><br><span class="line"> * @date: 2019/5/23</span><br><span class="line"> **/</span><br><span class="line">public final class ScheduledTask &#123;</span><br><span class="line"></span><br><span class="line">    public volatile ScheduledFuture&lt;?&gt; future;</span><br><span class="line">    /**</span><br><span class="line">     * 取消定时任务</span><br><span class="line">     */</span><br><span class="line">    public void cancel() &#123;</span><br><span class="line">        ScheduledFuture&lt;?&gt; future = this.future;</span><br><span class="line">        if (future != null) &#123;</span><br><span class="line">            future.cancel(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-定时任务的测试"><a href="#5-定时任务的测试" class="headerlink" title="5.定时任务的测试"></a>5.定时任务的测试</h3><p>编写一个需要用于测试的任务类<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @program: simple-demo</span><br><span class="line"> * @description:</span><br><span class="line"> * @author: CaoTing</span><br><span class="line"> * @date: 2019/5/23</span><br><span class="line"> **/</span><br><span class="line">@Component(&quot;demoTask&quot;)</span><br><span class="line">public class DemoTask &#123;</span><br><span class="line"></span><br><span class="line">    public void taskWithParams(String param1, Integer param2) &#123;</span><br><span class="line">        System.out.println(&quot;这是有参示例任务：&quot; + param1 + param2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void taskNoParams() &#123;</span><br><span class="line">        System.out.println(&quot;这是无参示例任务&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>进行单元测试<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import com.caotinging.demo.application.DynamicTaskApplication;</span><br><span class="line">import com.caotinging.demo.application.SchedulingRunnable;</span><br><span class="line">import com.caotinging.demo.config.CronTaskRegistrar;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @program: simple-demo</span><br><span class="line"> * @description: 测试定时任务</span><br><span class="line"> * @author: CaoTing</span><br><span class="line"> * @date: 2019/5/23</span><br><span class="line"> **/</span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringBootTest(classes = DynamicTaskApplication.class)</span><br><span class="line">public class TaskTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    CronTaskRegistrar cronTaskRegistrar;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testTask() throws InterruptedException &#123;</span><br><span class="line">        SchedulingRunnable task = new SchedulingRunnable(&quot;demoTask&quot;, &quot;taskNoParams&quot;, null);</span><br><span class="line">        cronTaskRegistrar.addCronTask(task, &quot;0/10 * * * * ?&quot;);</span><br><span class="line"></span><br><span class="line">        // 便于观察</span><br><span class="line">        Thread.sleep(3000000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testHaveParamsTask() throws InterruptedException &#123;</span><br><span class="line">        SchedulingRunnable task = new SchedulingRunnable(&quot;demoTask&quot;, &quot;taskWithParams&quot;, &quot;haha&quot;, 23);</span><br><span class="line">        cronTaskRegistrar.addCronTask(task, &quot;0/10 * * * * ?&quot;);</span><br><span class="line"></span><br><span class="line">        // 便于观察</span><br><span class="line">        Thread.sleep(3000000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="6-工具类：SpringContextUtils"><a href="#6-工具类：SpringContextUtils" class="headerlink" title="6.工具类：SpringContextUtils"></a>6.工具类：SpringContextUtils</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.ApplicationContextAware;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @program: simple-demo</span><br><span class="line"> * @description: spring获取bean工具类</span><br><span class="line"> * @author: CaoTing</span><br><span class="line"> * @date: 2019/5/23</span><br><span class="line"> **/</span><br><span class="line">@Component</span><br><span class="line">public class SpringContextUtils implements ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    private static ApplicationContext applicationContext = null;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        if (SpringContextUtils.applicationContext == null) &#123;</span><br><span class="line">            SpringContextUtils.applicationContext = applicationContext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取applicationContext</span><br><span class="line">    public static ApplicationContext getApplicationContext() &#123;</span><br><span class="line">        return applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //通过name获取 Bean.</span><br><span class="line">    public static Object getBean(String name) &#123;</span><br><span class="line">        return getApplicationContext().getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //通过class获取Bean.</span><br><span class="line">    public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        return getApplicationContext().getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //通过name,以及Clazz返回指定的Bean</span><br><span class="line">    public static &lt;T&gt; T getBean(String name, Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        return getApplicationContext().getBean(name, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-我的pom依赖"><a href="#7-我的pom依赖" class="headerlink" title="7.我的pom依赖"></a>7.我的pom依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatisplus-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0.5&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.1.9&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.9&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 数据库--&gt;</span><br><span class="line">        &lt;!--&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;--&gt;</span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/com.hynnet/oracle-driver-ojdbc --&gt;</span><br><span class="line">        &lt;!--&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.oracle&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;11.2.0.1.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 单元测试 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--redisTemplate --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- http连接 restTemplate --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;httpclient-cache&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 工具--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.31&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-lang&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.6&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/com.google/guava --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;10.0.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- pinyin4j --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.belerweb&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;pinyin4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.5.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h3><p>建议移步github获取简单demo上手实践哦，在本文文首哦。有帮助的话点个赞吧，笔芯。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/06/01/SpringBoot实现动态控制定时任务-支持多参数/" data-id="cjwdp2rdi000icm2a9n2dxir8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-感受lambda之美，推荐收藏，需要时查阅" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/31/感受lambda之美，推荐收藏，需要时查阅/" class="article-date">
  <time datetime="2019-05-31T08:43:37.037Z" itemprop="datePublished">2019-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/31/感受lambda之美，推荐收藏，需要时查阅/">感受lambda之美，推荐收藏，需要时查阅</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5ce66801e51d455d850d3a4a" target="_blank" rel="noopener">https://juejin.im/post/5ce66801e51d455d850d3a4a</a><br><a href="#h">一、引言</a><a href="#hjava">二、java重要的函数式接口</a><a href="#h1">1、什么是函数式接口</a><a href="#h11java8">1.1 java8自带的常用函数式接口。</a><a href="#h12">1.2 惰性求值与及早求值</a><a href="#h2">2、常用的流</a><a href="#h21collectcollectorstolist">2.1 collect(Collectors.toList())</a><a href="#h22filter">2.2 filter</a><a href="#h23map">2.3 map</a><a href="#h24flatmap">2.4 flatMap</a><a href="#h25maxmin">2.5 max和min</a><a href="#h26count">2.6 count</a><a href="#h27reduce">2.7 reduce</a><a href="#h-1">三、高级集合类及收集器</a><a href="#h31">3.1 转换成值</a><a href="#h32">3.2 转换成块</a><a href="#h33">3.3 数据分组</a><a href="#h34">3.4 字符串拼接</a><a href="#h-2">四、总结</a></p>
</blockquote>
<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>java8最大的特性就是引入Lambda表达式，即函数式编程，可以将行为进行传递。<strong>总结就是：使用不可变值与函数，函数对不可变值进行处理，映射成另一个值。</strong></p>
<h3 id="二、java重要的函数式接口"><a href="#二、java重要的函数式接口" class="headerlink" title="二、java重要的函数式接口"></a>二、java重要的函数式接口</h3><h3 id="1、什么是函数式接口"><a href="#1、什么是函数式接口" class="headerlink" title="1、什么是函数式接口"></a>1、什么是函数式接口</h3><p><strong>函数接口是只有一个抽象方法的接口，用作 Lambda 表达式的类型。使用@FunctionalInterface注解修饰的类，编译器会检测该类是否只有一个抽象方法或接口，否则，会报错。可以有多个默认方法，静态方法。</strong></p>
<h3 id="1-1-java8自带的常用函数式接口。"><a href="#1-1-java8自带的常用函数式接口。" class="headerlink" title="1.1 java8自带的常用函数式接口。"></a>1.1 java8自带的常用函数式接口。</h3><table>
<thead>
<tr>
<th align="center">函数接口</th>
<th align="center">抽象方法</th>
<th align="center">功能</th>
<th align="center">参数</th>
<th align="center">返回类型</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Predicate</td>
<td align="center">test(T t)</td>
<td align="center">判断真假</td>
<td align="center">T</td>
<td align="center">boolean</td>
<td align="center">9龙的身高大于185cm吗？</td>
</tr>
<tr>
<td align="center">Consumer</td>
<td align="center">accept(T t)</td>
<td align="center">消费消息</td>
<td align="center">T</td>
<td align="center">void</td>
<td align="center">输出一个值</td>
</tr>
<tr>
<td align="center">Function</td>
<td align="center">R apply(T t)</td>
<td align="center">将T映射为R（转换功能）</td>
<td align="center">T</td>
<td align="center">R</td>
<td align="center">获得student对象的名字</td>
</tr>
<tr>
<td align="center">Supplier</td>
<td align="center">T get()</td>
<td align="center">生产消息</td>
<td align="center">None</td>
<td align="center">T</td>
<td align="center">工厂方法</td>
</tr>
<tr>
<td align="center">UnaryOperator</td>
<td align="center">T apply(T t)</td>
<td align="center">一元操作</td>
<td align="center">T</td>
<td align="center">T</td>
<td align="center">逻辑非（!）</td>
</tr>
<tr>
<td align="center">BinaryOperator</td>
<td align="center">apply(T t, U u)</td>
<td align="center">二元操作</td>
<td align="center">(T，T)</td>
<td align="center">(T)</td>
<td align="center">求两个数的乘积（*）</td>
</tr>
<tr>
<td align="center"><code>{     {         Predicate&lt;Integer&gt; predicate = x -&gt; x &gt; ;         Student student =  Student(, , );         System.out.println(              + predicate.test(student.getStature()));         Consumer&lt;String&gt; consumer = System.out::println;         consumer.accept();         Function&lt;Student, String&gt; function = Student::getName;         String name = function.apply(student);         System.out.println(name);         Supplier&lt;Integer&gt; supplier =              () -&gt; Integer.valueOf(BigDecimal.TEN.toString());         System.out.println(supplier.get());         UnaryOperator&lt;Boolean&gt; unaryOperator = uglily -&gt; !uglily;         Boolean apply2 = unaryOperator.apply();         System.out.println(apply2);         BinaryOperator&lt;Integer&gt; operator = (x, y) -&gt; x * y;         Integer integer = operator.apply(, );         System.out.println(integer);         test(() -&gt; );     }          {         String work = worker.work();         System.out.println(work);     }      {         ;     } }</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>以上演示了lambda接口的使用及自定义一个函数式接口并使用。下面，我们看看java8将函数式接口封装到流中如何高效的帮助我们处理集合。</p>
<p><strong>注意：Student::getName</strong>例子中这种编写lambda表达式的方式称为<strong>方法引用。</strong>格式为<strong>ClassNmae::methodName</strong>。是不是很神奇，java8就是这么迷人。</p>
<p><strong>示例：本篇所有示例都基于以下三个类。OutstandingClass：班级；Student：学生；SpecialityEnum：特长。</strong><br><img src="https://user-gold-cdn.xitu.io/2019/5/23/16ae40638d420acd?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<h3 id="1-2-惰性求值与及早求值"><a href="#1-2-惰性求值与及早求值" class="headerlink" title="1.2 惰性求值与及早求值"></a>1.2 惰性求值与及早求值</h3><p><strong>惰性求值：只描述Stream，操作的结果也是Stream，这样的操作称为惰性求值。</strong>惰性求值可以像建造者模式一样链式使用，最后再使用及早求值得到最终结果。</p>
<p><strong>及早求值：得到最终的结果而不是Stream，这样的操作称为及早求值。</strong></p>
<h3 id="2、常用的流"><a href="#2、常用的流" class="headerlink" title="2、常用的流"></a>2、常用的流</h3><h3 id="2-1-collect-Collectors-toList"><a href="#2-1-collect-Collectors-toList" class="headerlink" title="2.1 collect(Collectors.toList())"></a>2.1 collect(Collectors.toList())</h3><p><strong>将流转换为list。还有toSet()，toMap()等。及早求值</strong>。
<code>{     {         List&lt;Student&gt; studentList = Stream.of( Student(, , ),                  Student(, , ),                  Student(, , )).collect(Collectors.toList());         System.out.println(studentList);     } }</code></p>
<h3 id="2-2-filter"><a href="#2-2-filter" class="headerlink" title="2.2 filter"></a>2.2 filter</h3><p>顾名思义，起<strong>过滤筛选</strong>的作用。<strong>内部就是Predicate接口。惰性求值。</strong><br><img src="https://user-gold-cdn.xitu.io/2019/5/23/16ae40638d2c0a51?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>比如我们筛选出出身高小于180的同学。</p>
<p><code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));         List&lt;Student&gt; list = students.stream()             .filter(stu -&gt; stu.getStature() &lt; )             .collect(Collectors.toList());         System.out.println(list);     } }</code></p>
<h3 id="2-3-map"><a href="#2-3-map" class="headerlink" title="2.3 map"></a>2.3 map</h3><p><strong>转换功能，内部就是Function接口。惰性求值</strong><br><img src="https://user-gold-cdn.xitu.io/2019/5/23/16ae40638d1c6610?imageView2/0/w/1280/h/960/ignore-error/1" alt> <code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));         List&lt;String&gt; names = students.stream().map(student -&gt; student.getName())                 .collect(Collectors.toList());         System.out.println(names);     } }</code></p>
<p>例子中将student对象转换为String对象，获取student的名字。</p>
<h3 id="2-4-flatMap"><a href="#2-4-flatMap" class="headerlink" title="2.4 flatMap"></a>2.4 flatMap</h3><p><strong>将多个Stream合并为一个Stream。惰性求值</strong><br><img src="https://user-gold-cdn.xitu.io/2019/5/23/16ae40638c4cca86?imageView2/0/w/1280/h/960/ignore-error/1" alt> <code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));         List&lt;Student&gt; studentList = Stream.of(students,                 asList( Student(, , ),                          Student(, , )))                 .flatMap(students1 -&gt; students1.stream()).collect(Collectors.toList());         System.out.println(studentList);     } }</code></p>
<p>调用Stream.of的静态方法将两个list转换为Stream，再通过flatMap将两个流合并为一个。</p>
<h3 id="2-5-max和min"><a href="#2-5-max和min" class="headerlink" title="2.5 max和min"></a>2.5 max和min</h3><p>我们经常会在集合中<strong>求最大或最小值</strong>，使用流就很方便。<strong>及早求值。</strong><br><code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));         Optional&lt;Student&gt; max = students.stream()             .max(Comparator.comparing(stu -&gt; stu.getAge()));         Optional&lt;Student&gt; min = students.stream()             .min(Comparator.comparing(stu -&gt; stu.getAge()));                   (max.isPresent()) {             System.out.println(max.get());         }          (min.isPresent()) {             System.out.println(min.get());         }     } }</code></p>
<p><strong>max、min接收一个Comparator</strong>（例子中使用java8自带的静态函数，只需要传进需要比较值即可。）并且返回一个Optional对象，该对象是java8新增的类，专门为了防止null引发的空指针异常。可以使用max.isPresent()判断是否有值；可以使用max.orElse(new Student())，当值为null时就使用给定值；也可以使用max.orElseGet(() -&gt; new Student());这需要传入一个Supplier的lambda表达式。</p>
<h3 id="2-6-count"><a href="#2-6-count" class="headerlink" title="2.6 count"></a>2.6 count</h3><p><strong>统计功能，一般都是结合filter使用，因为先筛选出我们需要的再统计即可。及早求值</strong><br><code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));          count = students.stream().filter(s1 -&gt; s1.getAge() &lt; ).count();         System.out.println( + count);     } }</code></p>
<h3 id="2-7-reduce"><a href="#2-7-reduce" class="headerlink" title="2.7 reduce"></a>2.7 reduce</h3><p><strong>reduce 操作可以实现从一组值中生成一个值</strong>。在上述例子中用到的 count 、 min 和 max 方<br>法，因为常用而被纳入标准库中。事实上，这些方法都是 reduce 操作。<strong>及早求值。</strong><br><img src="https://user-gold-cdn.xitu.io/2019/5/23/16ae40638c52397b?imageView2/0/w/1280/h/960/ignore-error/1" alt> <code>{     {         Integer reduce = Stream.of(, , , ).reduce(, (acc, x) -&gt; acc+ x);         System.out.println(reduce);     } }</code></p>
<p>我们看得reduce接收了一个初始值为0的累加器，依次取出值与累加器相加，最后累加器的值就是最终的结果。</p>
<h3 id="三、高级集合类及收集器"><a href="#三、高级集合类及收集器" class="headerlink" title="三、高级集合类及收集器"></a>三、高级集合类及收集器</h3><h3 id="3-1-转换成值"><a href="#3-1-转换成值" class="headerlink" title="3.1 转换成值"></a>3.1 转换成值</h3><p><strong>收集器，一种通用的、从流生成复杂值的结构。</strong>只要将它传给 collect 方法，所有<br>的流就都可以使用它了。标准类库已经提供了一些有用的收集器，<strong>以下示例代码中的收集器都是从 java.util.stream.Collectors 类中静态导入的。</strong><br><code>{     {         List&lt;Student&gt; students1 =  ArrayList&lt;&gt;();         students1.add( Student(, , ));         students1.add( Student(, , ));         students1.add( Student(, , ));         OutstandingClass ostClass1 =  OutstandingClass(, students1);                  List&lt;Student&gt; students2 =  ArrayList&lt;&gt;(students1);         students2.remove();         OutstandingClass ostClass2 =  OutstandingClass(, students2);                  Stream&lt;OutstandingClass&gt; classStream = Stream.of(ostClass1, ostClass2);         OutstandingClass outstandingClass = biggestGroup(classStream);         System.out.println( + outstandingClass.getName());         System.out.println( + averageNumberOfStudent(students1));     }          {          outstandingClasses.collect(                 maxBy(comparing(ostClass -&gt; ostClass.getStudents().size())))                 .orElseGet(OutstandingClass::);     }          {          students.stream().collect(averagingInt(Student::getAge));     } }</code></p>
<p>maxBy或者minBy就是求最大值与最小值。</p>
<h3 id="3-2-转换成块"><a href="#3-2-转换成块" class="headerlink" title="3.2 转换成块"></a>3.2 转换成块</h3><p><strong>常用的流操作是将其分解成两个集合，Collectors.partitioningBy帮我们实现了，接收一个Predicate函数式接口。</strong><br><img src="https://user-gold-cdn.xitu.io/2019/5/23/16ae4063943b9487?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>将示例学生分为会唱歌与不会唱歌的两个集合。</p>
<p><code>{     {                  Map&lt;Boolean, List&lt;Student&gt;&gt; listMap = students.stream().collect(             Collectors.partitioningBy(student -&gt; student.getSpecialities().                                       contains(SpecialityEnum.SING)));     } }</code></p>
<h3 id="3-3-数据分组"><a href="#3-3-数据分组" class="headerlink" title="3.3 数据分组"></a>3.3 数据分组</h3><p>数据分组是一种更自然的分割数据操作，与将数据分成 ture 和 false 两部分不同，<strong>可以使</strong><br><strong>用任意值对数据分组。Collectors.groupingBy接收一个Function做转换。</strong><br><img src="https://user-gold-cdn.xitu.io/2019/5/23/16ae4063f5d78c78?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p><strong>如图，我们使用groupingBy将根据进行分组为圆形一组，三角形一组，正方形一组。</strong></p>
<p>例子：根据学生第一个特长进行分组<br><code>{     {                   Map&lt;SpecialityEnum, List&lt;Student&gt;&gt; listMap =               students.stream().collect(              Collectors.groupingBy(student -&gt; student.getSpecialities().get()));     } }</code></p>
<p><strong>Collectors.groupingBy与SQL 中的 group by 操作是一样的。</strong></p>
<h3 id="3-4-字符串拼接"><a href="#3-4-字符串拼接" class="headerlink" title="3.4 字符串拼接"></a>3.4 字符串拼接</h3><p>如果将所有学生的名字拼接起来，怎么做呢？通常只能创建一个StringBuilder，循环拼接。使用Stream，使用Collectors.joining()简单容易。<br><code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));          String names = students.stream()              .map(Student::getName).collect(Collectors.joining(,,));         System.out.println(names);     } }</code></p>
<p><strong>joining接收三个参数，第一个是分界符，第二个是前缀符，第三个是结束符。也可以不传入参数Collectors.joining()，这样就是直接拼接。</strong></p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>本篇主要从实际使用讲述了常用的方法及流，使用java8可以很清晰表达你要做什么，代码也很简洁。本篇例子主要是为了讲解较为简单，大家可以去使用java8重构自己现有的代码，自行领会lambda的奥妙。本文说的Stream要组合使用才会发挥更大的功能，链式调用很迷人，根据自己的业务去做吧。</p>
<p><strong>整理不易，希望点赞支持支持。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/31/感受lambda之美，推荐收藏，需要时查阅/" data-id="cjwdp2re0001hcm2aij5z16vo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-README" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/30/README/" class="article-date">
  <time datetime="2019-05-30T00:52:25.412Z" itemprop="datePublished">2019-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="My-Reading-Notes"><a href="#My-Reading-Notes" class="headerlink" title="My Reading Notes"></a>My Reading Notes</h1><blockquote>
<p><a href="mailto:huan.dreamer@gmail.com" target="_blank" rel="noopener">huan.dreamer@gmail.com</a></p>
</blockquote>
<h2 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h2><ol>
<li>《Docker技术入门与实践》 杨保华  等</li>
<li>《腾讯传1998-2016：中国互联网公司计划论》 吴晓波</li>
<li>《史蒂芬·乔布斯传》 沃尔特·艾萨克森</li>
<li>《激荡十年，水大鱼大：中国企业2008-2018》 吴晓波</li>
<li>《Spring Cloud微服务实战》 翟永超</li>
<li>《人月神话（40周年中文纪念版）》 布鲁克斯</li>
<li>《乔布斯离开了，马斯克来了》 竹内一正</li>
<li>《深入理解Java虚拟机》 周志明</li>
<li>《产品的视角：从热闹到门道》 后显慧</li>
<li>《大型网站技术架构 核心原理与案例分析》 李智慧</li>
<li>《Effective Java中文版 第二版》Joshua Bloch</li>
<li>《操作系统之哲学原理》 邹恒明</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/30/README/" data-id="cjwdp2rdd000bcm2ai8ey996r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Effective Java" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/30/Effective Java/" class="article-date">
  <time datetime="2019-05-30T00:52:25.400Z" itemprop="datePublished">2019-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="对象的创建和销毁"><a href="#对象的创建和销毁" class="headerlink" title="对象的创建和销毁"></a>对象的创建和销毁</h1><h3 id="一、使用静态工厂方法代替构造器"><a href="#一、使用静态工厂方法代替构造器" class="headerlink" title="一、使用静态工厂方法代替构造器"></a>一、使用静态工厂方法代替构造器</h3><ol>
<li>静态工厂优势一：有名称。当一个类需要多个带有相同签名的构造器时，可以通过名称突出它们之间的区别</li>
<li>静态工程优势二：不必每次都创建新的对象。可以将创建的实例缓存，或者是返回预先构建好的实例(工厂模式)。例如 <code>Boolean.valueOf(boolean)</code>。如果确保了每次返回的都是同一对象的话，可以使用<code>==</code>进行判断，提升效率</li>
<li>静态工厂优势三：可以返回原返回类型的任何子类的对象，可以返回受保护的类的对象。例如<code>Collections.singletonList(T)</code>、<code>EnumSet</code>。</li>
</ol>
<h3 id="二、遇到多个构造器参数时要考虑用构造器"><a href="#二、遇到多个构造器参数时要考虑用构造器" class="headerlink" title="二、遇到多个构造器参数时要考虑用构造器"></a>二、遇到多个构造器参数时要考虑用构造器</h3><p>​    Builder 模式。这个就不必多少了，当构造器参数很多，并且都是可选时，推荐使用builder。也可以提供一个<code>DefaultInstance</code>，返回具有默认参数的对象。推荐一个工具 <a href="https://www.projectlombok.org/" target="_blank" rel="noopener">lombok</a> ,使用注解生成样板代码。</p>
<h3 id="三、使用私有构造器或者枚举类型强化-Singleton-属性"><a href="#三、使用私有构造器或者枚举类型强化-Singleton-属性" class="headerlink" title="三、使用私有构造器或者枚举类型强化 Singleton 属性"></a>三、使用私有构造器或者枚举类型强化 Singleton 属性</h3><p>​    使构造器私有，通过创建<code>getInstance</code>方法，返回该类的唯一<code>private static final</code>的实例。好处在于，在不改变API的前提下，可以改变方法实现，从而对类是否为<code>Singleton</code>。但是客户端可以使用<code>AccessibleObject.setAccessible</code>方法，通过反射调用私有构造器。</p>
<p>​    实现<code>Singleton</code>还可以使用<code>Enum</code>。</p>
<h3 id="四、通过私有构造器强化不可变实例化的能力"><a href="#四、通过私有构造器强化不可变实例化的能力" class="headerlink" title="四、通过私有构造器强化不可变实例化的能力"></a>四、通过私有构造器强化不可变实例化的能力</h3><p>​    例如工具类，不希望客户端对它进行实例化（实例化没有任何意义），可以创建私有的无参构造函数进行屏蔽对象的创建。NERVER：企图通过做成抽象类来强制该类不能被实例化，这样会引起误解。</p>
<h3 id="五、避免创建不必要的对象"><a href="#五、避免创建不必要的对象" class="headerlink" title="五、避免创建不必要的对象"></a>五、避免创建不必要的对象</h3><ol>
<li><p>避免 <code>String s = new String(&quot;***&quot;)</code>的操作</p>
</li>
<li><p>需要重复使用的对象，应该将实例进行缓存，而不是每次都创建。例如判断一个人是否为2000年后出生，应该将<code>2000-1-1</code>进行缓存，再和他的出生日期进行比较</p>
</li>
<li><p><code>适配器模式</code>中，没有必要创建多个适配器对象。例如<code>Map.keySet()</code>方法，就会将<code>ks</code>对象进行缓存。每次都返回同一个对象</p>
</li>
<li><p>避免大量的<code>自动装箱</code>操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Long sum = <span class="number">0L</span>; 	<span class="comment">// 使用 long sum = 0L 可以避免自动装箱，节省大量资源</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span>  i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i ++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/30/Effective Java/" data-id="cjwdp2rcz0000cm2au5414cf6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/30/hello-world/" class="article-date">
  <time datetime="2019-05-30T00:45:32.658Z" itemprop="datePublished">2019-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/30/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/30/hello-world/" data-id="cjwdp2rdl000pcm2aujs4f5t7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-熟练掌握各种MQ？那面试官很可能用这道题目先摸摸你的老底！" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/28/熟练掌握各种MQ？那面试官很可能用这道题目先摸摸你的老底！/" class="article-date">
  <time datetime="2019-05-28T07:38:06.006Z" itemprop="datePublished">2019-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/28/熟练掌握各种MQ？那面试官很可能用这道题目先摸摸你的老底！/">熟练掌握各种MQ？那面试官很可能用这道题目先摸摸你的老底！</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5ceb79fef265da1bb47d4222" target="_blank" rel="noopener">https://juejin.im/post/5ceb79fef265da1bb47d4222</a><br><strong>公众号：狸猫技术窝</strong></p>
</blockquote>
<p><strong>作者：爱钓鱼的桌子哥，资深架构师</strong></p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h3><p>1.有Broker的暴力路由：<strong>Kafka</strong></p>
<p>2.有Broker的复杂路由：<strong>RabbitMQ</strong></p>
<p>3.无Broker的通信流派：<strong>ZeroMQ</strong></p>
<p>4.总结</p>
<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a><strong>写在前面</strong></h3><p>我们知道，目前市面上的MQ包括Kafka、RabbitMQ、ZeroMQ、RocketMQ等等。</p>
<p>那么他们之间究竟有什么本质区别，分别适用于什么场景呢？</p>
<p>上述抛出的问题，同样在不少公司的Java工程师面试中出现，特别是当你简历上的技术栈包含了这些技术，面试官往往喜欢用这个问题，对你进行摸底考察。</p>
<p>本文我们就一起来探讨一下。</p>
<h3 id="（1）有Broker的暴力路由"><a href="#（1）有Broker的暴力路由" class="headerlink" title="（1）有Broker的暴力路由"></a><strong>（1）有Broker的暴力路由</strong></h3><p>这个流派最典型的就是<strong>Kafka</strong>，Kafka实际上为了提升性能，简化了MQ功能模型，仅仅提供了一些最基础的MQ相关的功能，但是大幅度优化和提升了吞吐量。</p>
<p>首先，这个流派一定是有一个Broker角色的，也就是说，Kafka需要部署一套服务器集群，每台机器上都有一个Kafka Broker进程，这个进程就负责接收请求，存储数据，发送数据。</p>
<p>Kafka的生产消费模型做的相对是比较暴力简单的，就是简单的数据流模型。</p>
<p>简单来说，他有一个概念，叫做“<strong>Topic</strong>”，你可以往这个“Topic”里写数据，然后让别人从这里来消费。</p>
<p>这个Topic可以划分为多个Partition，每个Partition放一台机器上，存储一部分数据。</p>
<p>在写消息到Topic的时候，会自动把你这个消息给分发到某一个Partition上去。</p>
<p>然后消费消息的时候，有一个<strong>Consumer Group</strong>的概念，你部署在多台机器上的Consumer可以组成一个Group，一个Partition只能给一个Consumer消费，一个Cosumer可以消费多个Partition，这是最最核心的一点。</p>
<p>通过这个模型，保证一个Topic里的每条消息，只会交给Consumer Group里的一个Consumer来消费，形成了一个Queue（队列）的效果。</p>
<p>假如你想要有一个Queue的效果，也就是希望不停的往Queue里写数据，然后多个消费者消费，每条消息就只能给一个消费者，那么通过Kafka来实现，其实就是生产者写多个Partition，每个Partition只能给Consumer Group中的一个Consumer来消费。如下图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/27/16af7d5d9e1690c5?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>如果要实现Publish/Subscribe的模型呢？就是说生产者发送的每条消息，都要让所有消费都消费到，怎么实现？</p>
<p>那就让每个消费者都是一个独立的消费组，这样每条消息都会发送给所有的消费组，每个消费组里那唯一的一个消费者一定会消费到所有的消息。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/27/16af7d5d918ca40f?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>但是除此之外，Kafka就没有任何其他的消费功能了，就是如此简单，所以属于一种比较暴力直接的流派。</p>
<p>它就是简单的消费模型，实现最基础的Queue和Pub/Sub两种消费模型，但是内核中大幅度优化和提升了性能以及吞吐量。</p>
<p>所以Kafka天生适合的场景，就是大数据领域的实时数据计算的场景。</p>
<p>因为在大数据的场景下，通常是弱业务的场景，没有太多复杂的业务系统交互，而主要是大量的数据流入Kafka，然后进行实时计算。</p>
<p>所以就是需要简单的消费模型，但是必须在内核中对吞吐量和性能进行大幅度的优化。</p>
<p>因此Kafka技术通常是在大数据的实时数据计算领域中使用的，比如说每秒处理几十万条消息，甚至每秒处理上百万条消息。</p>
<h3 id="（2）有Broker的复杂路由"><a href="#（2）有Broker的复杂路由" class="headerlink" title="（2）有Broker的复杂路由"></a>（2）有Broker的复杂路由</h3><p>第二个流派，就是<strong>RabbitMQ</strong>为代表的流派，他强调的不是说如何提升性能和吞吐量，关注的是说要提供非常强大、复杂而且完善的消息路由功能。</p>
<p>所以对于RabbitMQ而言，他就不是那么简单的Topic-Partition的消费模型了。</p>
<p>在RabbitMQ中引入了一个非常核心的概念，叫做<strong>Exchange</strong>，这个Exchange就是负责根据复杂的业务规则把消息路由到内部的不同的Queue里去。</p>
<p>举个例子，如果要实现最简单的队列功能，就是让exchange往一个queue里写数据，然后多个消费者来消费这个queue里的数据，每条消息只能给一个消费者，那么可以是类似下面的方式。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/27/16af7d5d91903b11?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>如果想要实现Pub/Sub的模型，就是一条消息要被所有的消费者给消费到，那么就可以让每个消费者都有一个自己的Queue，然后绑定到一个Exchange上去。</p>
<p>接着，这个Exchange就设定把消息路由给所有的Queue即可，如下面这样。</p>
<p>此时Exchange可以把每条消息都路由给所有的Queue，每个Consumer都可以从自己的Queue里拿到所有的消息。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/27/16af7d5d91efcb5b?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>RabbitMQ这种流派，其实最核心的是，基于Exchange这个概念，他可以做很多复杂的事情。</p>
<p>比如：如果你想要某个Consumer只能消费到<strong>某一类数据</strong>，那么Exchange可以把消息里比如带“XXX”前缀的消息路由给某个Queue。或者你可以限定某个Consumer就只能消费<strong>某一部分数据</strong>。总之在这里你可以做很多的限制，设置复杂的路由规则。</p>
<p>但是也正是因为引入了这种复杂的消费模型，支持复杂的路由功能，导致RabbitMQ在内核以及架构设计上没法像Kafka做的那么的轻量级、高性能、可扩展、高吞吐，所以RabbitMQ在吞吐量上要比Kafka低一个数量级。</p>
<p>所以这种流派的MQ，往往适合用在Java业务系统中，不同的业务系统需要进行复杂的消息路由。</p>
<p>比如说业务系统A发送了10条消息，其中3条消息是给业务系统B的，7条消息是给业务系统C的，要实现这种复杂的路由模型，就必须依靠RabbitMQ来实现。</p>
<p>当然，对于这种业务系统之间的消息流转而言，可能不需要那么高的吞吐量，可能每秒业务系统之间也就转发几十条或者几百条消息，那么就完全适合采用RabbitMQ来实现。</p>
<h3 id="（3）无Broker的通信流派"><a href="#（3）无Broker的通信流派" class="headerlink" title="（3）无Broker的通信流派"></a>（3）无Broker的通信流派</h3><p><strong>ZeroMQ</strong>代表的是第三种MQ。说白了，他是不需要在服务器上部署的，就是一个客户端的库而已。</p>
<p>也就是说，他主要是封装了底层的Socket网络通讯，然后一个系统要发送一条消息给另外一个消息消费 。</p>
<p>通过ZeroMQ，本质就是底层ZeroMQ发送一条消息到另外一个系统上去。</p>
<p>所以ZeroMQ是<strong>去中心化</strong>的，不需要跟Kafka、RabbitMQ一样在服务器上部署的。</p>
<p>他主要是用来进行业务系统之间的网络通信的，有点类似于比如你是一个分布式系统架构，那么此时分布式架构中的各个子系统互相之间要通信，你是基于Dubbo RPC？还是Spring Cloud HTTP？</p>
<p>可能上述两种你都不想要，就是要基于原始的Socket进行网络通信，简单的收发消息而已。</p>
<p>此时就可以使用ZeroMQ作为分布式系统之间的消息通信，如下面那样。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/27/16af7d5d91f778d7?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<h3 id="（4）总结"><a href="#（4）总结" class="headerlink" title="（4）总结"></a>（4）总结</h3><p>其实现在基本上MQ主要就是这三个流派，很多小众的MQ一般很少有人会用。</p>
<p>而且用MQ的场景主要就是两大类：</p>
<pre><code>1. </code></pre><p><strong>业务系统之间异步通信</strong><br>    1.<br><strong>大数据领域的实时数据计算</strong></p>
<p>所以一般业务系统之间通信就是会采用RabbitMQ/RocketMQ，需要复杂的消息路由功能的支撑。</p>
<p>大数据的实时计算场景会采用Kafka，需要简单的消费模型，但是超高的吞吐量。</p>
<p>至于ZeroMQ，一般来说，少数分布式系统中子系统之间的分布式通信时会采用，作为轻量级的异步化的通信组件。</p>
<p><strong>END</strong></p>
<p><strong>作者简介：</strong></p>
<p><strong>爱钓鱼的桌子哥，资深架构师</strong></p>
<p>作者先后工作于滴滴、百度、字节跳动等国内一线互联网大厂，从事基础架构相关工作。带领团队设计与构建了大规模的分布式存储系统、分布式消息中间件、分布式数据库，对分布式架构设计、系统高可用体系构建、基础中间件架构都有丰富的经验。</p>
<p><strong>END</strong></p>
<p>长按下图二维码，即刻关注【狸猫技术窝】 阿里、京东、美团、字节跳动 顶尖技术专家坐镇 为IT人打造一个 “有温度” 的技术窝！</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/23/16a4aea4c6855bb5?imageView2/0/w/1280/h/960/ignore-error/1" alt><br>作者：狸猫技术窝<br>链接：<a href="https://juejin.im/post/5ce1975af265da1bd42450b5" target="_blank" rel="noopener">https://juejin.im/post/5ce1975af265da1bd42450b5</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/28/熟练掌握各种MQ？那面试官很可能用这道题目先摸摸你的老底！/" data-id="cjwdp2re7001qcm2a7e0jj7k7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-从模板方法模式到JDBCTemplate" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/22/从模板方法模式到JDBCTemplate/" class="article-date">
  <time datetime="2019-05-22T14:33:24.024Z" itemprop="datePublished">2019-05-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/22/从模板方法模式到JDBCTemplate/">从模板方法模式到JDBCTemplate</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5cdb7f4af265da037371aa1f" target="_blank" rel="noopener">https://juejin.im/post/5cdb7f4af265da037371aa1f</a><br>将大象装进冰箱需要三步，那么老虎了？如何优雅的将大象装进冰箱？</p>
</blockquote>
<h3 id="把大象装进冰箱"><a href="#把大象装进冰箱" class="headerlink" title="把大象装进冰箱"></a>把大象装进冰箱</h3><table>
<thead>
<tr>
<th align="center">Step</th>
<th align="center">大象</th>
<th align="center">老虎</th>
<th align="center">…</th>
</tr>
</thead>
<tbody><tr>
<td align="center">First</td>
<td align="center">打开冰箱门</td>
<td align="center">打开冰箱门</td>
<td align="center">打开冰箱门</td>
</tr>
<tr>
<td align="center">Second</td>
<td align="center">把大象放进去</td>
<td align="center">把老虎放进去</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">Third</td>
<td align="center">关闭冰箱门</td>
<td align="center">关闭冰箱门</td>
<td align="center">关闭冰箱门</td>
</tr>
</tbody></table>
<p><strong><em>大象类</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Elephant &#123;</span><br><span class="line">        public void putRefrigerator() &#123;</span><br><span class="line">            openDoor();</span><br><span class="line">            putElephant();</span><br><span class="line">            closeDoor();</span><br><span class="line">        &#125;</span><br><span class="line">        public void openDoor() &#123;</span><br><span class="line">            System.out.println(&quot;open the door&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public void putElephant() &#123;</span><br><span class="line">            System.out.println(&quot;put in the Elephant&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public void closeDoor() &#123;</span><br><span class="line">            System.out.println(&quot;close the door&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>老虎类</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Tiger &#123;</span><br><span class="line">        public void putRefrigerator() &#123;</span><br><span class="line">            openDoor();</span><br><span class="line">            putTiger();</span><br><span class="line">            closeDoor();</span><br><span class="line">        &#125;</span><br><span class="line">        public void openDoor() &#123;</span><br><span class="line">            System.out.println(&quot;open the door&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public void putTiger() &#123;</span><br><span class="line">            System.out.println(&quot;put in the Tiger&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public void closeDoor() &#123;</span><br><span class="line">            System.out.println(&quot;close the door&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出我们将大象和老虎放进冰箱的过程中出现了大量的重复代码，这显然不是一个好的设计，如果我们在以后的系统升级过程中需要再放入长颈鹿怎么办，我们应该如何从我们的设计中删除这些重复代码？通过观察我们发现放大象和放老虎之间有很多共同点，都需要进行开关门的操作，只是放的过程不尽相同，我们是否可以将共同点抽离？我们一起试试看</p>
<p><strong><em>抽象超类</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractPutAnyAnimal &#123;</span><br><span class="line">        //这是一个模板方法，它是一个算法的模板，描述我们将动物放进冰箱的步骤，每一个方法代表了一个步骤</span><br><span class="line">        public void putRefrigerator() &#123;</span><br><span class="line">            openDoor();</span><br><span class="line">            putAnyAnimal();</span><br><span class="line">            closeDoor();</span><br><span class="line">        &#125;</span><br><span class="line">        //在超类中实现共同的方法，由超类来处理</span><br><span class="line">        public void openDoor() &#123;</span><br><span class="line">            System.out.println(&quot;open the door&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public void closeDoor() &#123;</span><br><span class="line">            System.out.println(&quot;close the door&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //每个子类可能有不同的方法,我们定义成抽象方法让子类去实现</span><br><span class="line">        abstract void putAnyAnimal();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>大象类</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Elephant extends AbstractPutAnyAnimal &#123;</span><br><span class="line">        //子类实现自己的业务逻辑</span><br><span class="line">        @Override</span><br><span class="line">        void putAnyAnimal() &#123;</span><br><span class="line">            System.out.println(&quot;put in the Elephant&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>老虎类</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Tiger extends AbstractPutAnyAnimal &#123;</span><br><span class="line">        //子类实现自己的业务逻辑</span><br><span class="line">        @Override</span><br><span class="line">        void putAnyAnimal() &#123;</span><br><span class="line">            System.out.println(&quot;put in the Tiger&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过将相同的方法抽离到超类中，并定义一个抽象方法供子类提供不同的实现，事实上我们刚刚实现了一个模板方法模式。</p>
<h3 id="模板方法模式定义？"><a href="#模板方法模式定义？" class="headerlink" title="模板方法模式定义？"></a>模板方法模式定义？</h3><p><strong>模板方法模式定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现</strong>，putRefrigerator 方法定义了我们将大象装进冰箱的步骤它就是一个模板方法。<strong>模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不在改变算法结构的情况下，重新定义算法的某些步骤</strong>（子类提供自己的实现）</p>
<h3 id="模板方法模式中的钩子"><a href="#模板方法模式中的钩子" class="headerlink" title="模板方法模式中的钩子"></a>模板方法模式中的钩子</h3><p>我们可以在超类中定义一个空方法，我们称这种方法为钩子（hook）。子类可以依据情况选择覆盖，钩子的存在可以让子类有能力对算法的不同点进行挂载；<strong>钩子可以让子类实现算法中的可选部分，钩子也可以让子类为抽象类做一些决定</strong>我们将大象装进冰箱后可能会想调整冰箱温度，也可能什么都不做使用默认温度，我们可以通过定义一个钩子，让子类来选择是否调整温度，如下：</p>
<p><strong><em>抽象父类</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractPutAnyAnimal &#123;</span><br><span class="line">        public void putRefrigerator() &#123;</span><br><span class="line">            openDoor();</span><br><span class="line">            putAnyAnimal();</span><br><span class="line">            closeDoor();</span><br><span class="line">            //默认为false,重新这个方法决定是否执行addTemperature();方法</span><br><span class="line">            if (isAdd()) &#123;</span><br><span class="line">                addTemperature();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public void openDoor() &#123;</span><br><span class="line">            System.out.println(&quot;open the door&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public void closeDoor() &#123;</span><br><span class="line">            System.out.println(&quot;close the door&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        abstract void putAnyAnimal();</span><br><span class="line">        void addTemperature()&#123;</span><br><span class="line">            System.out.println(&quot;plus one&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        //定义一个空实现，由子类决定是否对其进行实现</span><br><span class="line">        boolean isAdd()&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>大象类</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Elephant extends AbstractPutAnyAnimal &#123;</span><br><span class="line">        @Override</span><br><span class="line">        void putAnyAnimal() &#123;</span><br><span class="line">            System.out.println(&quot;put in the Elephant&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //子类实现钩子方法</span><br><span class="line">        @Override</span><br><span class="line">        boolean isAdd() &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们通过定义一个钩子方法，子类选择是否实现这个钩子方法，来决定是否调整温度；当然钩子方法的用途不止如此，<strong>它还能让子类有机会对模板中即将发生或刚刚发生的步骤做出反应</strong>，这在JDK中有很多的例子，甚至在前端开发领域也有很多例子，我就不具体展开代码演示了，后面在模板方法模式的更多应用中展开。</p>
<p>JDK以及Spring中使用了很多的设计模式，下面我们通过比较传统JDBC编程和JDBCTemplate来看看模板方法模式是如何帮我们消除样板代码的</p>
<h3 id="传统JDBC编程"><a href="#传统JDBC编程" class="headerlink" title="传统JDBC编程"></a>传统JDBC编程</h3><p><strong><em>JDBC编程之新增</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">String driver = &quot;com.mysql.jdbc.Driver&quot;;</span><br><span class="line">        String url = &quot;jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8&amp;amp;useSSL=true&quot;;</span><br><span class="line">        String username = &quot;root&quot;;</span><br><span class="line">        String password = &quot;1234&quot;;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        Statement statement = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(driver);</span><br><span class="line">            connection = DriverManager.getConnection(url, username, password);</span><br><span class="line">            String sql = &quot;insert into users(nickname,comment,age) values(&apos;小小谭&apos;,&apos;I love three thousand times&apos;, &apos;21&apos;)&quot;;</span><br><span class="line">            statement = connection.createStatement();</span><br><span class="line">            int i = statement.executeUpdate(sql);</span><br><span class="line">            return i;</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (null != statement) &#123;</span><br><span class="line">                    statement.close();</span><br><span class="line">                &#125;</span><br><span class="line">                if (null != connection) &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br></pre></td></tr></table></figure>

<p><strong><em>JDBC编程之查询</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">String driver = &quot;com.mysql.jdbc.Driver&quot;;</span><br><span class="line">        String url = &quot;jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8&amp;amp;useSSL=true&quot;;</span><br><span class="line">        String username = &quot;root&quot;;</span><br><span class="line">        String password = &quot;1234&quot;;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        Statement statement = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            Class.forName(driver);</span><br><span class="line">            connection = DriverManager.getConnection(url, username, password);</span><br><span class="line">            String sql = &quot;select nickname,comment,age from users&quot;;</span><br><span class="line">            statement = connection.createStatement();</span><br><span class="line">            ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line">            List&lt;Users&gt; usersList = new ArrayList&lt;&gt;();</span><br><span class="line">            while (resultSet.next()) &#123;</span><br><span class="line">                Users users = new Users();</span><br><span class="line">                users.setNickname(resultSet.getString(1));</span><br><span class="line">                users.setComment(resultSet.getString(2));</span><br><span class="line">                users.setAge(resultSet.getInt(3));</span><br><span class="line">                usersList.add(users);</span><br><span class="line">            &#125;</span><br><span class="line">            return usersList;</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (null != statement) &#123;</span><br><span class="line">                    statement.close();</span><br><span class="line">                &#125;</span><br><span class="line">                if (null != connection) &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br></pre></td></tr></table></figure>

<p>上面给出了我们在传统JDBC编程中的两个案例，可以看到传统JDBC的很多缺点，当然在实际项目中我们可能不会这么原始的进行数据库开发，可能会对JDBC进行一定的封装，方便我们的使用。Spring 官方为了简化JDBC的开发也发布了JDBCTemplate，下面我们就看一下它是如何简化开发的，以及模板方法模式在其中的应用</p>
<h3 id="JDBCTemplate是个啥，它到底简化了什么？"><a href="#JDBCTemplate是个啥，它到底简化了什么？" class="headerlink" title="JDBCTemplate是个啥，它到底简化了什么？"></a>JDBCTemplate是个啥，它到底简化了什么？</h3><p>从JDBCTemplate的名字我们就不难看出，它简化了我们JDBC的开发，而且很可能大量应用了模板方法模式，它到底为我们提供了什么？<strong>它提供了与平台无光的异常处理机制</strong>。使用过原生JDBC开发的同学可能有经历，几乎所有的操作代码都需要我们强制捕获异常，但是在出现异常时我们往往无法通过异常读懂错误。Spring解决了我们的问题它<strong>提供了多个数据访问异常，并且分别描述了他们抛出时对应的问题，同时对异常进行了包装不强制要求我们进行捕获，同时它为我们提供了数据访问的模板化</strong>，从上面的传统JDBC编程我们可以发现，很多操作其实是重复的不变得比如事务控制、资源的获取关闭以及异常处理等，同时结果集的处理实体的绑定，参数的绑定这些东西都是特有的。因此<strong>Spring将数据访问过程中固定部分和可变部分划分为了两个不同的类(Template)和回调(Callback),模板处理过程中不变得部分，回调处理自定义的访问代码</strong>；下面我们具体通过源码来学学习一下</p>
<h3 id="模板方法模式在JDBCTemplate中的应用"><a href="#模板方法模式在JDBCTemplate中的应用" class="headerlink" title="模板方法模式在JDBCTemplate中的应用"></a>模板方法模式在JDBCTemplate中的应用</h3><p>我所使用的版本是5.1.5.RELEASE</p>
<p>打开JdbcTemplate类(我这里就不截图了，截图可能不清晰我直接将代码copy出来)：</p>
<p><strong><em>JdbcTemplate</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcTemplate extends JdbcAccessor implements JdbcOperations &#123;</span><br><span class="line">        //查询前缀</span><br><span class="line">        private static final String RETURN_RESULT_SET_PREFIX = &quot;#result-set-&quot;;</span><br><span class="line">        //计数前缀</span><br><span class="line">        private static final String RETURN_UPDATE_COUNT_PREFIX = &quot;#update-count-&quot;;</span><br><span class="line">        //是否跳过警告</span><br><span class="line">        private boolean ignoreWarnings = true;</span><br><span class="line">        //查询大小</span><br><span class="line">        private int fetchSize = -1;</span><br><span class="line">        //最大行</span><br><span class="line">        private int maxRows = -1;</span><br><span class="line">        //查询超时</span><br><span class="line">        private int queryTimeout = -1;</span><br><span class="line">        //是否跳过结果集处理</span><br><span class="line">        private boolean skipResultsProcessing = false;</span><br><span class="line">        //是否跳过非公共结果集处理</span><br><span class="line">        private boolean skipUndeclaredResults = false;</span><br><span class="line">        //map结果集是否大小写敏感</span><br><span class="line">        private boolean resultsMapCaseInsensitive = false;</span><br><span class="line">    </span><br><span class="line">        public JdbcTemplate() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        //调用父类方法设置数据源和其他参数</span><br><span class="line">        public JdbcTemplate(DataSource dataSource) &#123;</span><br><span class="line">            this.setDataSource(dataSource);</span><br><span class="line">            this.afterPropertiesSet();</span><br><span class="line">        &#125;</span><br><span class="line">        //调用父类方法设置数据源，懒加载策略和其他参数</span><br><span class="line">        public JdbcTemplate(DataSource dataSource, boolean lazyInit) &#123;</span><br><span class="line">            this.setDataSource(dataSource);</span><br><span class="line">            this.setLazyInit(lazyInit);</span><br><span class="line">            this.afterPropertiesSet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>JdbcTemplate 继承了JdbcAccessor实现了JdbcOperations，JdbcAccessor主要封装了数据源的操作，JdbcOperations主要定义了一些操作接口。我们一起看一下JdbcOperations类；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public abstract class JdbcAccessor implements InitializingBean &#123;</span><br><span class="line">        protected final Log logger = LogFactory.getLog(this.getClass());</span><br><span class="line">        //数据源</span><br><span class="line">        @Nullable</span><br><span class="line">        private DataSource dataSource;</span><br><span class="line">        //异常翻译</span><br><span class="line">        @Nullable</span><br><span class="line">        private volatile SQLExceptionTranslator exceptionTranslator;</span><br><span class="line">        //懒加载策略</span><br><span class="line">        private boolean lazyInit = true;</span><br><span class="line">        public JdbcAccessor() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        public void setDataSource(@Nullable DataSource dataSource) &#123;</span><br><span class="line">            this.dataSource = dataSource;</span><br><span class="line">        &#125;</span><br><span class="line">        @Nullable</span><br><span class="line">        public DataSource getDataSource() &#123;</span><br><span class="line">            return this.dataSource;</span><br><span class="line">        &#125;</span><br><span class="line">        protected DataSource obtainDataSource() &#123;</span><br><span class="line">            DataSource dataSource = this.getDataSource();</span><br><span class="line">            Assert.state(dataSource != null, &quot;No DataSource set&quot;);</span><br><span class="line">            return dataSource;</span><br><span class="line">        &#125;</span><br><span class="line">        public void setDatabaseProductName(String dbName) &#123;</span><br><span class="line">            this.exceptionTranslator = new SQLErrorCodeSQLExceptionTranslator(dbName);</span><br><span class="line">        &#125;</span><br><span class="line">        public void setExceptionTranslator(SQLExceptionTranslator exceptionTranslator) &#123;</span><br><span class="line">            this.exceptionTranslator = exceptionTranslator;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>之所以<strong>前面提到spring让我们更方便的处理异常就是这里他包装了一个SQLExceptionTranslator</strong>，其他的代码都是做数据源的检查之类的设置数据源，我们看一下其中getExceptionTranslator()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public SQLExceptionTranslator getExceptionTranslator() &#123;</span><br><span class="line">        SQLExceptionTranslator exceptionTranslator = this.exceptionTranslator;</span><br><span class="line">        if (exceptionTranslator != null) &#123;</span><br><span class="line">            return exceptionTranslator;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            synchronized(this) &#123;</span><br><span class="line">                SQLExceptionTranslator exceptionTranslator = this.exceptionTranslator;</span><br><span class="line">                if (exceptionTranslator == null) &#123;</span><br><span class="line">                    DataSource dataSource = this.getDataSource();</span><br><span class="line">                    if (dataSource != null) &#123;</span><br><span class="line">                        exceptionTranslator = new SQLErrorCodeSQLExceptionTranslator(dataSource);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        exceptionTranslator = new SQLStateSQLExceptionTranslator();</span><br><span class="line">                    &#125;</span><br><span class="line">                    this.exceptionTranslator = (SQLExceptionTranslator)exceptionTranslator;</span><br><span class="line">                &#125;</span><br><span class="line">                return (SQLExceptionTranslator)exceptionTranslator;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这是一个标准的单例模式，我们在学习模板方法模式的路途中有捕获了一个野生的单例；我们继续看JdbcOperations接口我们调其中一个接口进行解析；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">    &lt;T&gt; T execute(StatementCallback&lt;T&gt; var1) throws DataAccessException;</span><br></pre></td></tr></table></figure>

<p><strong><em>StatementCallback 接口</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">    public interface StatementCallback&lt;T&gt; &#123;</span><br><span class="line">        @Nullable</span><br><span class="line">        T doInStatement(Statement var1) throws SQLException, DataAccessException;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>execute实现</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">    public &lt;T&gt; T execute(StatementCallback&lt;T&gt; action) throws DataAccessException &#123;</span><br><span class="line">        //参数检查</span><br><span class="line">        Assert.notNull(action, &quot;Callback object must not be null&quot;);</span><br><span class="line">        //获取连接</span><br><span class="line">        Connection con = DataSourceUtils.getConnection(this.obtainDataSource());</span><br><span class="line">        Statement stmt = null;</span><br><span class="line">        Object var11;</span><br><span class="line">        try &#123;</span><br><span class="line">            //创建一个Statement</span><br><span class="line">            stmt = con.createStatement();</span><br><span class="line">            //设置查询超时时间，最大行等参数（就是一开始那些成员变量）</span><br><span class="line">            this.applyStatementSettings(stmt);</span><br><span class="line">            //执行回调方法获取结果集</span><br><span class="line">            T result = action.doInStatement(stmt);</span><br><span class="line">            //处理警告</span><br><span class="line">            this.handleWarnings(stmt);</span><br><span class="line">            var11 = result;</span><br><span class="line">        &#125; catch (SQLException var9) &#123;</span><br><span class="line">            //出现错误优雅退出</span><br><span class="line">            String sql = getSql(action);</span><br><span class="line">            JdbcUtils.closeStatement(stmt);</span><br><span class="line">            stmt = null;</span><br><span class="line">            DataSourceUtils.releaseConnection(con, this.getDataSource());</span><br><span class="line">            con = null;</span><br><span class="line">            throw this.translateException(&quot;StatementCallback&quot;, sql, var9);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JdbcUtils.closeStatement(stmt);</span><br><span class="line">            DataSourceUtils.releaseConnection(con, this.getDataSource());</span><br><span class="line">        &#125;</span><br><span class="line">        return var11;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这一个方法可谓是展现的淋漓尽致，这是一个典型的模板方法+回调模式，我们不需要再写过多的重复代码只需要实现自己获取result的方法就好（StatementCallback）事实上我们自己也不需要实现这个方法，继续向上看，我们是如何调用execute方法的，以查询为例,我们看他是如何一步步调用的：</p>
<p><strong><em>查询方法</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Users&gt; findAll() &#123;</span><br><span class="line">        JdbcTemplate jdbcTemplate = DataSourceConfig.getTemplate();</span><br><span class="line">        String sql = &quot;select nickname,comment,age from users&quot;;</span><br><span class="line">        return jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;Users&gt;(Users.class));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>query实现</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper) throws DataAccessException &#123;</span><br><span class="line">        return (List)result(this.query((String)sql, (ResultSetExtractor)(new RowMapperResultSetExtractor(rowMapper))));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的RowMapper是负责将结果集中一行的数据映射成实体返回，用到了反射技术，这里就不展开了，有兴趣的同学可以自己打开源码阅读，继续向下：</p>
<p><strong><em>query实现</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">    public &lt;T&gt; T query(final String sql, final ResultSetExtractor&lt;T&gt; rse) throws DataAccessException &#123;</span><br><span class="line">        Assert.notNull(sql, &quot;SQL must not be null&quot;);</span><br><span class="line">        Assert.notNull(rse, &quot;ResultSetExtractor must not be null&quot;);</span><br><span class="line">        if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">            this.logger.debug(&quot;Executing SQL query [&quot; + sql + &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //实现回调接口</span><br><span class="line">        class QueryStatementCallback implements StatementCallback&lt;T&gt;, SqlProvider &#123;</span><br><span class="line">            QueryStatementCallback() &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            @Nullable</span><br><span class="line">            public T doInStatement(Statement stmt) throws SQLException &#123;</span><br><span class="line">                ResultSet rs = null;</span><br><span class="line">                Object var3;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //这里真正的执行我们的sql语句</span><br><span class="line">                    rs = stmt.executeQuery(sql);</span><br><span class="line">                    //处理对象映射</span><br><span class="line">                    var3 = rse.extractData(rs);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    JdbcUtils.closeResultSet(rs);</span><br><span class="line">                &#125;</span><br><span class="line">                return var3;</span><br><span class="line">            &#125;</span><br><span class="line">            public String getSql() &#123;</span><br><span class="line">                return sql;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //调用execute接口</span><br><span class="line">        return this.execute((StatementCallback)(new QueryStatementCallback()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看到这里相信你也不得拍手称奇，Spring处理的非常巧妙，请继续向下看：</p>
<p><strong><em>update详解</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected int update(PreparedStatementCreator psc, @Nullable PreparedStatementSetter pss) throws DataAccessException &#123;</span><br><span class="line">        this.logger.debug(&quot;Executing prepared SQL update&quot;);</span><br><span class="line">        return updateCount((Integer)this.execute(psc, (ps) -&gt; &#123;</span><br><span class="line">            Integer var4;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (pss != null) &#123;</span><br><span class="line">                    pss.setValues(ps);</span><br><span class="line">                &#125;</span><br><span class="line">                int rows = ps.executeUpdate();</span><br><span class="line">                if (this.logger.isTraceEnabled()) &#123;</span><br><span class="line">                    this.logger.trace(&quot;SQL update affected &quot; + rows + &quot; rows&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                var4 = rows;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (pss instanceof ParameterDisposer) &#123;</span><br><span class="line">                    ((ParameterDisposer)pss).cleanupParameters();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return var4;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>为什么我要把update函数拎出来讲了，因为update这里使用了lambda函数,回想我们StatementCallback定义只有一个方法的接口，他就是一个函数是接口，所以他是一个函数式接口，所以这里直接使用lambda语法，<strong>lambda函数允许你直接内连，为函数接口的抽象方法提供实现，并且整个表达式作为函数接口的一个实例</strong>。我们在平时学习中可能知道了lambda语法但是可能使用的较少，或者不知道如何用于实战，那么多阅读源码一定可以提升你的实战能力。 我们可以看到JDBCTemplate使用了很多回调。为什么要用回调（Callback)?<strong>如果父类有多个抽象方法，子类需要全部实现这样特别麻烦，而有时候某个子类只需要定制父类中的某一个方法该怎么办呢？这个时候就要用到Callback回调了就可以完美解决这个问题</strong>，可以发现JDBCTemplate并没有完全拘泥于模板方法，非常灵活。我们在实际开发中也可以借鉴这种方法。</p>
<h3 id="模板方法模式的更多应用"><a href="#模板方法模式的更多应用" class="headerlink" title="模板方法模式的更多应用"></a>模板方法模式的更多应用</h3><p>事实上很多有关生命周期的类都用到了模板方法模式，最典型的也是可能我们最熟悉的莫过于Servlet了，废话不多说上源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class HttpServlet extends GenericServlet</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2019/5/21/16ad9448cb69de5e?imageView2/0/w/1280/h/960/ignore-error/1" alt> HttpServlet的所有方法，我们看到HttpServlet继承了GenericServlet，我们继续看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">public abstract class GenericServlet </span><br><span class="line">    implements Servlet, ServletConfig, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    private static final String LSTRING_FILE = &quot;javax.servlet.LocalStrings&quot;;</span><br><span class="line">    private static ResourceBundle lStrings =</span><br><span class="line">        ResourceBundle.getBundle(LSTRING_FILE);</span><br><span class="line"></span><br><span class="line">    private transient ServletConfig config;</span><br><span class="line">    </span><br><span class="line">    public GenericServlet() &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    //没有实现钩子</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getInitParameter(String name) &#123;</span><br><span class="line">        ServletConfig sc = getServletConfig();</span><br><span class="line">        if (sc == null) &#123;</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sc.getInitParameter(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Enumeration&lt;String&gt; getInitParameterNames() &#123;</span><br><span class="line">        ServletConfig sc = getServletConfig();</span><br><span class="line">        if (sc == null) &#123;</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sc.getInitParameterNames();</span><br><span class="line">    &#125;   </span><br><span class="line">     </span><br><span class="line">    public ServletConfig getServletConfig() &#123;</span><br><span class="line">	return config;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public ServletContext getServletContext() &#123;</span><br><span class="line">        ServletConfig sc = getServletConfig();</span><br><span class="line">        if (sc == null) &#123;</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sc.getServletContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getServletInfo() &#123;</span><br><span class="line">	return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init(ServletConfig config) throws ServletException &#123;</span><br><span class="line">	this.config = config;</span><br><span class="line">	this.init();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void init() throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void log(String msg) &#123;</span><br><span class="line">	getServletContext().log(getServletName() + &quot;: &quot;+ msg);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public void log(String message, Throwable t) &#123;</span><br><span class="line">	getServletContext().log(getServletName() + &quot;: &quot; + message, t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public abstract void service(ServletRequest req, ServletResponse res)</span><br><span class="line">	throws ServletException, IOException;</span><br><span class="line">    </span><br><span class="line">    public String getServletName() &#123;</span><br><span class="line">        ServletConfig sc = getServletConfig();</span><br><span class="line">        if (sc == null) &#123;</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sc.getServletName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这就是个典型的模板方法类蛮，而且钩子函数也在这里展现的淋漓尽致，如init、destroy方法等，JDK中很多类都是用了模板方法等着你发现哦。</p>
<h3 id="模板方法模式在Vue-js中的应用"><a href="#模板方法模式在Vue-js中的应用" class="headerlink" title="模板方法模式在Vue.js中的应用"></a>模板方法模式在Vue.js中的应用</h3><p>模板方法模式在其他语言中也有实现比如Vue.js、React中；比如Vue生命周期肯定使用了模板方法，我就不对源码展开分析了。<br><img src="https://user-gold-cdn.xitu.io/2019/5/21/16ad94b7aa8bb518?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>设计模式在Spring中得到了大量的应用，感兴趣的同学可以看看Spring源码加以学习，如果你觉得我写的还不错的话点个赞吧，如果你发现了错误，或者不好的地方也可以及时告诉我加以改正，谢谢！您的赞赏和批评是进步路上的好伙伴。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/22/从模板方法模式到JDBCTemplate/" data-id="cjwdp2rdt0015cm2a1bhb872m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-拜托！面试请不要再问我SpringCloud底层原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/21/拜托！面试请不要再问我SpringCloud底层原理/" class="article-date">
  <time datetime="2019-05-21T02:50:09.009Z" itemprop="datePublished">2019-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/21/拜托！面试请不要再问我SpringCloud底层原理/">拜托！面试请不要再问我Spring Cloud底层原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5be13b83f265da6116393fc7" target="_blank" rel="noopener">https://juejin.im/post/5be13b83f265da6116393fc7</a><br>欢迎关注微信公众号：<strong>石杉的架构笔记（id：shishan100）</strong></p>
</blockquote>
<p>每周一至五早8点半，精品技术文章准时送上！</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><strong>一、业务场景介绍</strong></p>
<p><strong>二、Spring Cloud核心组件：Eureka</strong></p>
<p><strong>三、Spring Cloud核心组件：Feign</strong></p>
<p><strong>四、Spring Cloud核心组件：Ribbon</strong></p>
<p><strong>五、Spring Cloud核心组件：Hystrix</strong></p>
<p><strong>六、Spring Cloud核心组件：Zuul</strong></p>
<p><strong>七、总结</strong></p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>毫无疑问，Spring Cloud是目前微服务架构领域的翘楚，无数的书籍博客都在讲解这个技术。不过大多数讲解还停留在对Spring Cloud功能使用的层面，其底层的很多原理，很多人可能并不知晓。<strong>因此本文将通过大量的手绘图</strong>，给大家谈谈Spring Cloud微服务架构的底层原理。</p>
<p>实际上，Spring Cloud是一个全家桶式的技术栈，包含了很多组件。本文先从其最核心的几个组件入手，来剖析一下其底层的工作原理。<strong>也就是Eureka、Ribbon、Feign、Hystrix、Zuul这几个组件。</strong></p>
<hr>
<h2 id="一、业务场景介绍"><a href="#一、业务场景介绍" class="headerlink" title="一、业务场景介绍"></a>一、业务场景介绍</h2><p>先来给大家说一个业务场景，假设咱们现在开发一个电商网站，要实现支付订单的功能，流程如下：</p>
<pre><code>* 创建一个订单后，如果用户立刻支付了这个订单，我们需要将订单状态更新为“已支付”
* 扣减相应的商品库存
* 通知仓储中心，进行发货
* 给用户的这次购物增加相应的积分</code></pre><p>针对上述流程，<strong>我们需要有订单服务、库存服务、仓储服务、积分服务</strong>。整个流程的大体思路如下：</p>
<pre><code>* 用户针对一个订单完成支付之后，就会去找订单服务，更新订单状态
* 订单服务调用库存服务，完成相应功能
* 订单服务调用仓储服务，完成相应功能
* 订单服务调用积分服务，完成相应功能</code></pre><p><strong>至此，整个支付订单的业务流程结束</strong></p>
<hr>
<p>下图这张图，清晰表明了各服务间的调用过程：<br><img src="https://user-gold-cdn.xitu.io/2018/11/7/166ebffb48c481a3?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>好！有了业务场景之后，咱们就一起来看看Spring Cloud微服务架构中，这几个组件如何相互协作，各自发挥的作用以及其背后的原理。</p>
<h2 id="二、Spring-Cloud核心组件：Eureka"><a href="#二、Spring-Cloud核心组件：Eureka" class="headerlink" title="二、Spring Cloud核心组件：Eureka"></a>二、Spring Cloud核心组件：Eureka</h2><p><strong>咱们来考虑第一个问题</strong>：订单服务想要调用库存服务、仓储服务，或者积分服务，怎么调用？</p>
<pre><code>* 订单服务压根儿就不知道人家库存服务在哪台机器上啊！他就算想要发起一个请求，都不知道发送给谁，有心无力！
* 这时候，就轮到Spring Cloud Eureka出场了。Eureka是微服务架构中的注册中心，专门负责服务的注册与发现。</code></pre><p>咱们来看看下面的这张图，结合图来仔细剖析一下整个流程：<br><img src="https://user-gold-cdn.xitu.io/2018/11/7/166ebffcb7ce31b8?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>如上图所示，库存服务、仓储服务、积分服务中都有一个<strong>Eureka Client组件，这个组件专门负责将这个服务的信息注册到Eureka Server中</strong>。说白了，就是告诉Eureka Server，自己在哪台机器上，监听着哪个端口。而<strong>Eureka Server是一个注册中心，里面有一个注册表，保存了各服务所在的机器和端口号</strong></p>
<p>订单服务里也有一个Eureka Client组件，这个Eureka Client组件会找Eureka Server问一下：库存服务在哪台机器啊？监听着哪个端口啊？仓储服务呢？积分服务呢？然后就可以把这些相关信息从Eureka Server的注册表中拉取到自己本地缓存起来。</p>
<p>这时如果订单服务想要调用库存服务，不就可以找自己本地的Eureka Client问一下库存服务在哪台机器？监听哪个端口吗？收到响应后，紧接着就可以发送一个请求过去，调用库存服务扣减库存的那个接口！同理，如果订单服务要调用仓储服务、积分服务，也是如法炮制。</p>
<p>总结一下：</p>
<pre><code>* **Eureka Client：**负责将这个服务的信息注册到Eureka Server中
* **Eureka Server：**注册中心，里面有一个注册表，保存了各个服务所在的机器和端口号</code></pre><h2 id="三、Spring-Cloud核心组件：Feign"><a href="#三、Spring-Cloud核心组件：Feign" class="headerlink" title="三、Spring Cloud核心组件：Feign"></a>三、Spring Cloud核心组件：Feign</h2><p>现在订单服务确实知道库存服务、积分服务、仓库服务在哪里了，同时也监听着哪些端口号了。<strong>但是新问题又来了：难道订单服务要自己写一大堆代码，跟其他服务建立网络连接，然后构造一个复杂的请求，接着发送请求过去，最后对返回的响应结果再写一大堆代码来处理吗？</strong></p>
<hr>
<p>这是上述流程翻译的代码片段，咱们一起来看看，体会一下这种绝望而无助的感受！！！</p>
<p><strong>友情提示，前方高能：</strong><br><img src="https://user-gold-cdn.xitu.io/2018/11/7/166ebced960f2024?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<p>看完上面那一大段代码，有没有感到后背发凉、一身冷汗？实际上你进行服务间调用时，如果每次都手写代码，代码量比上面那段要多至少几倍，所以这个事压根儿就不是地球人能干的。</p>
<p>既然如此，那怎么办呢？别急，Feign早已为我们提供好了优雅的解决方案。来看看如果用Feign的话，你的订单服务调用库存服务的代码会变成啥样？<br><img src="https://user-gold-cdn.xitu.io/2018/11/7/166ebcf01b773dd4?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<p>看完上面的代码什么感觉？是不是感觉整个世界都干净了，又找到了活下去的勇气！没有底层的建立连接、构造请求、解析响应的代码，直接就是用注解定义一个 FeignClient接口，然后调用那个接口就可以了。人家Feign Client会在底层根据你的注解，跟你指定的服务建立连接、构造请求、发起靕求、获取响应、解析响应，等等。这一系列脏活累活，人家Feign全给你干了。</p>
<p>那么问题来了，Feign是如何做到这么神奇的呢？很简单，<strong>Feign的一个关键机制就是使用了动态代理</strong>。咱们一起来看看下面的图，结合图来分析：</p>
<pre><code>* 首先，如果你对某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理
* 接着你要是调用那个接口，本质就是会调用 Feign创建的动态代理，这是核心中的核心
* Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务的地址
* 最后针对这个地址，发起请求、解析响应</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/11/7/166ebfff505b2a20?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<h2 id="四、Spring-Cloud核心组件：Ribbon"><a href="#四、Spring-Cloud核心组件：Ribbon" class="headerlink" title="四、Spring Cloud核心组件：Ribbon"></a>四、Spring Cloud核心组件：Ribbon</h2><p>说完了Feign，还没完。现在新的问题又来了，如果人家库存服务部署在了5台机器上，如下所示：</p>
<pre><code>* 192.168.169:9000
* 192.168.170:9000
* 192.168.171:9000
* 192.168.172:9000
* 192.168.173:9000</code></pre><p><strong>这下麻烦了！人家Feign怎么知道该请求哪台机器呢？</strong></p>
<pre><code>* 这时Spring Cloud Ribbon就派上用场了。Ribbon就是专门解决这个问题的。它的作用是**负载均衡**，会帮你在每次请求时选择一台机器，均匀的把请求分发到各个机器上
* Ribbon的负载均衡默认使用的最经典的**Round Robin轮询算法**。这是啥？简单来说，就是如果订单服务对库存服务发起10次请求，那就先让你请求第1台机器、然后是第2台机器、第3台机器、第4台机器、第5台机器，接着再来—个循环，第1台机器、第2台机器。。。以此类推。</code></pre><p><strong>此外，Ribbon是和Feign以及Eureka紧密协作，完成工作的，具体如下：</strong></p>
<pre><code>* 首先Ribbon会从 Eureka Client里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口号。
* 然后Ribbon就可以使用默认的Round Robin算法，从中选择一台机器
* Feign就会针对这台机器，构造并发起请求。</code></pre><p>对上述整个过程，再来一张图，帮助大家更深刻的理解：<br><img src="https://user-gold-cdn.xitu.io/2018/11/7/166ec001dc155e98?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<hr>
<h2 id="五、Spring-Cloud核心组件：Hystrix"><a href="#五、Spring-Cloud核心组件：Hystrix" class="headerlink" title="五、Spring Cloud核心组件：Hystrix"></a>五、Spring Cloud核心组件：Hystrix</h2><p>在微服务架构里，一个系统会有很多的服务。<strong>以本文的业务场景为例</strong>：订单服务在一个业务流程里需要调用三个服务。现在假设订单服务自己最多只有100个线程可以处理请求，然后呢，积分服务不幸的挂了，每次订单服务调用积分服务的时候，都会卡住几秒钟，然后抛出—个超时异常。</p>
<p><strong>咱们一起来分析一下，这样会导致什么问题？</strong></p>
<pre><code>1. 如果系统处于高并发的场景下，大量请求涌过来的时候，订单服务的100个线程都会卡在请求积分服务这块。导致订单服务没有一个线程可以处理请求
1. 然后就会导致别人请求订单服务的时候，发现订单服务也挂了，不响应任何请求了</code></pre><p>上面这个，就是<strong>微服务架构中恐怖的服务雪崩问题</strong>，如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/11/7/166ec0033f64a0a7?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>如上图，这么多服务互相调用，要是不做任何保护的话，某一个服务挂了，就会引起连锁反应，导致别的服务也挂。比如积分服务挂了，会导致订单服务的线程全部卡在请求积分服务这里，没有一个线程可以工作，瞬间导致订单服务也挂了，别人请求订单服务全部会卡住，无法响应。</p>
<p><strong>但是我们思考一下，就算积分服务挂了，订单服务也可以不用挂啊！为什么？</strong></p>
<pre><code>* 我们结合业务来看：支付订单的时候，只要把库存扣减了，然后通知仓库发货就OK了
* 如果积分服务挂了，大不了等他恢复之后，慢慢人肉手工恢复数据！为啥一定要因为一个积分服务挂了，就直接导致订单服务也挂了呢？不可以接受！</code></pre><p><strong>现在问题分析完了，如何解决？</strong></p>
<p>这时就轮到Hystrix闪亮登场了。Hystrix是隔离、熔断以及降级的一个框架。啥意思呢？说白了，<strong>Hystrix会搞很多个小小的线程池</strong>，比如订单服务请求库存服务是一个线程池，请求仓储服务是一个线程池，请求积分服务是一个线程池。每个线程池里的线程就仅仅用于请求那个服务。</p>
<p><strong>打个比方：现在很不幸，积分服务挂了，会咋样？</strong></p>
<p>当然会导致订单服务里那个用来调用积分服务的线程都卡死不能工作了啊！但由于订单服务调用库存服务、仓储服务的这两个线程池都是正常工作的，所以这两个服务不会受到任何影响。</p>
<p>这个时候如果别人请求订单服务，订单服务还是可以正常调用库存服务扣减库存，调用仓储服务通知发货。只不过调用积分服务的时候，每次都会报错。<strong>但是如果积分服务都挂了，每次调用都要去卡住几秒钟干啥呢？有意义吗？当然没有！</strong>所以我们直接对积分服务熔断不就得了，比如在5分钟内请求积分服务直接就返回了，不要去走网络请求卡住几秒钟，<strong>这个过程，就是所谓的熔断！</strong></p>
<hr>
<p><strong>那人家又说，兄弟，积分服务挂了你就熔断，好歹你干点儿什么啊！别啥都不干就直接返回啊？</strong>没问题，咱们就来个降级：每次调用积分服务，你就在数据库里记录一条消息，说给某某用户增加了多少积分，因为积分服务挂了，导致没增加成功！这样等积分服务恢复了，你可以根据这些记录手工加一下积分。<strong>这个过程，就是所谓的降级。</strong></p>
<hr>
<p>为帮助大家更直观的理解，接下来用一张图，梳理一下Hystrix隔离、熔断和降级的全流程：<br><img src="https://user-gold-cdn.xitu.io/2018/11/7/166ec004edf94426?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<h2 id="六、Spring-Cloud核心组件：Zuul"><a href="#六、Spring-Cloud核心组件：Zuul" class="headerlink" title="六、Spring Cloud核心组件：Zuul"></a>六、Spring Cloud核心组件：Zuul</h2><p>说完了Hystrix，接着给大家说说最后一个组件：Zuul，也就是微服务网关。<strong>这个组件是负责网络路由的。</strong>不懂网络路由？行，那我给你说说，如果没有Zuul的日常工作会怎样？</p>
<p>假设你后台部署了几百个服务，现在有个前端兄弟，人家请求是直接从浏览器那儿发过来的。<strong>打个比方</strong>：人家要请求一下库存服务，你难道还让人家记着这服务的名字叫做inventory-service？部署在5台机器上？就算人家肯记住这一个，你后台可有几百个服务的名称和地址呢？难不成人家请求一个，就得记住一个？你要这样玩儿，那真是友谊的小船，说翻就翻！</p>
<p>上面这种情况，压根儿是不现实的。所以一般微服务架构中都必然会设计一个网关在里面，像android、ios、pc前端、微信小程序、H5等等，不用去关心后端有几百个服务，就知道有一个网关，所有请求都往网关走，网关会根据请求中的一些特征，将请求转发给后端的各个服务。</p>
<p>而且有一个网关之后，还有很多好处，比如可以做<strong>统一的降级、限流、认证授权、安全</strong>，等等。</p>
<h2 id="七、总结："><a href="#七、总结：" class="headerlink" title="七、总结："></a>七、总结：</h2><p>最后再来总结一下，上述几个Spring Cloud核心组件，在微服务架构中，分别扮演的角色：</p>
<pre><code>* **Eureka**：各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里
* **Ribbon**：服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台
* **Feign**：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求
* **Hystrix**：发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题
* **Zuul**：如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务</code></pre><p>以上就是我们通过一个电商业务场景，阐述了Spring Cloud微服务架构几个核心组件的底层原理。</p>
<p><strong>文字总结还不够直观？没问题！</strong>我们将Spring Cloud的5个核心组件通过一张图串联起来，再来直观的感受一下其底层的架构原理：<br><img src="https://user-gold-cdn.xitu.io/2018/11/7/166ec006b1536f43?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<p>如有收获，请帮忙转发，您的鼓励是作者最大的动力，谢谢！</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/6/166e9511e7162c8b?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>Spring Cloud原创系列文章，将会持续更新</p>
<p>欢迎关注微信公众号：<strong>石杉的架构笔记（id:shishan100）</strong></p>
<p>十余年<strong>BAT架构经验</strong>倾囊相授</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/21/拜托！面试请不要再问我SpringCloud底层原理/" data-id="cjwdp2rdy001ecm2a9p683oep" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/">Spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微服务/">微服务</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/服务器/">服务器</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-用大白话告诉你小白都能看懂的Hadoop架构原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/21/用大白话告诉你小白都能看懂的Hadoop架构原理/" class="article-date">
  <time datetime="2019-05-21T01:57:19.019Z" itemprop="datePublished">2019-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/21/用大白话告诉你小白都能看懂的Hadoop架构原理/">用大白话告诉你小白都能看懂的Hadoop架构原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5beaf02ce51d457e90196069" target="_blank" rel="noopener">https://juejin.im/post/5beaf02ce51d457e90196069</a> </p>
</blockquote>
<p><strong>欢迎关注个人微信号：石杉的架构笔记（id：shishan100）</strong></p>
<p><strong>周一至周五早8点半！精品技术文章准时送上！</strong></p>
<hr>
<p><strong>往期文章</strong></p>
<p>1、<a href="https://juejin.im/post/5be13b83f265da6116393fc7" target="_blank" rel="noopener">拜托！面试请不要再问我Spring Cloud底层原理</a></p>
<p>2、<a href="https://juejin.im/post/5be3f8dcf265da613a5382ca" target="_blank" rel="noopener">【双11狂欢的背后】微服务注册中心如何承载大型系统的千万级访问？</a></p>
<p>3、<a href="https://juejin.im/post/5be83e166fb9a049a7115580" target="_blank" rel="noopener">【性能优化之道】每秒上万并发下的Spring Cloud参数优化实战</a></p>
<p>4、<a href="https://juejin.im/post/5be99a68e51d4511a8090440" target="_blank" rel="noopener">微服务架构如何保障双11狂欢下的99.99%高可用</a></p>
<hr>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>一、前奏</p>
<p>二、HDFS的NameNode架构原理</p>
<h1 id="一、前奏"><a href="#一、前奏" class="headerlink" title="一、前奏"></a>一、前奏</h1><p>Hadoop是目前大数据领域最主流的一套技术体系，包含了多种技术。</p>
<p>包括HDFS（分布式文件系统），YARN（分布式资源调度系统），MapReduce（分布式计算系统），等等。</p>
<p>有些朋友可能听说过Hadoop，但是却不太清楚他到底是个什么东西，这篇文章就用大白话给各位阐述一下。</p>
<p>假如你现在公司里的数据都是放在MySQL里的，那么就全部放在一台数据库服务器上，我们就假设这台服务器的磁盘空间有2T吧，<strong>大家先看下面这张图。</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/13/1670dbfd11e62805?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<p>现在问题来了，你不停的往这台服务器的MySQL里放数据，结果数据量越来越大了，超过了2T的大小了，现在咋办？</p>
<p>你说，我可以搞多台MySQL数据库服务器，分库分表啊！每台服务器放一部分数据不就得了。<strong>如上图所示！</strong></p>
<p>好，没问题，那咱们搞3台数据库服务器，3个MySQL实例，然后每台服务器都可以2T的数据。</p>
<p>现在我问你一个问题，<strong>所谓的大数据是在干什么？</strong></p>
<p>我们来说一下大数据最初级的一个使用场景。假设你有一个电商网站，现在要把这个电商网站里所有的用户在页面和APP上的点击、购买、浏览的行为日志都存放起来分析。</p>
<p>你现在把这些数据全都放在了3台MySQL服务器，数据量很大，但还是勉强可以放的下。</p>
<p>某天早上，你的boss来了。要看一张报表，比如要看每天网站的X指标、Y指标、Z指标，等等，二三十个数据指标。</p>
<p>好了，兄弟，现在你尝试去从那些点击、购买、浏览的日志里，通过写一个SQL来分析出那二三十个指标试试看？</p>
<p>我跟你打赌，你绝对会写出来一个几百行起步，甚至上千行的超级复杂大SQL。这个SQL，你觉得他能运行在分库分表后的3台MySQL服务器上么？</p>
<p>如果你觉得可以的话，那你一定是不太了解MySQL分库分表后有多坑，几百行的大SQL跨库join，各种复杂的计算，根本不现实。</p>
<p>所以说，大数据的存储和计算压根儿不是靠MySQL来搞的，因此，Hadoop、Spark等大数据技术体系才应运而生。</p>
<p>本质上，Hadoop、Spark等大数据技术，其实就是一系列的分布式系统。</p>
<p>比如hadoop中的HDFS，就是大数据技术体系中的核心基石，<strong>负责分布式存储数据，这是啥意思？别急，继续往下看。</strong></p>
<p>HDFS全称是Hadoop Distributed File System，是Hadoop的分布式文件系统。</p>
<p>它由很多机器组成，每台机器上运行一个DataNode进程，负责管理一部分数据。</p>
<p>然后有一台机器上运行了NameNode进程，NameNode大致可以认为是负责管理整个HDFS集群的这么一个进程，他里面存储了HDFS集群的所有元数据。</p>
<p>然后有很多台机器，每台机器存储一部分数据！好，HDFS现在可以很好的存储和管理大量的数据了。</p>
<p>这时候你肯定会有疑问：MySQL服务器也不是这样的吗？你要是这样想，那就大错特错了。</p>
<p>这个事情不是你想的那么简单的，HDFS天然就是分布式的技术，所以你上传大量数据，存储数据，管理数据，天然就可以用HDFS来做。</p>
<p>如果你硬要基于MySQL分库分表这个事儿，会痛苦很多倍，因为MySQL并不是设计为分布式系统架构的，他在分布式数据存储这块缺乏很多数据保障的机制。</p>
<p>好，你现在用HDFS分布式存储了数据，接着不就是要分布式来计算这些数据了吗？</p>
<p>对于分布式计算：</p>
<pre><code>* 很多公司用Hive写几百行的大SQL（底层基于MapReduce）
* 也有很多公司开始慢慢的用Spark写几百行的大SQL（底层是Spark Core引擎）。</code></pre><p>总之就是写一个大SQL，人家会拆分为很多的计算任务，放到各个机器上去，每个计算任务就负责计算一小部分数据，这就是所谓的分布式计算。</p>
<p>这个，绝对比你针对分库分表的MySQL来跑几百行大SQL要靠谱的多。</p>
<p>对于上述所说，老规矩，同样给大家来一张图，大伙儿跟着图来仔细捋一下整个过程。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/13/1670dc005dc982dc?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<h1 id="二、HDFS的NameNode架构原理"><a href="#二、HDFS的NameNode架构原理" class="headerlink" title="二、HDFS的NameNode架构原理"></a>二、HDFS的NameNode架构原理</h1><p>好了，前奏铺垫完之后，进入正题。本文其实主要就是讨论一下HDFS集群中的NameNode的核心架构原理。</p>
<p>NameNode有一个很核心的功能：<strong>管理整个HDFS集群的元数据</strong>，比如说文件目录树、权限的设置、副本数的设置，等等。</p>
<p>下面就用最典型的文件目录树的维护，来给大家举例说明，<strong>我们看看下面的图。</strong>现在有一个客户端系统要上传一个1TB的大文件到HDFS集群里。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/13/1670dc022eeddf7f?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<p>此时他会先跟NameNode通信，说：大哥，我想创建一个新的文件，他的名字叫“/usr/hive/warehouse/access_20180101.log”，大小是1TB，你看行不？</p>
<p>然后NameNode就会在自己内存的文件目录树里，在指定的目录下搞一个新的文件对象，名字就是“access_20180101.log”。</p>
<p>这个文件目录树不就是HDFS非常核心的一块元数据，维护了HDFS这个分布式文件系统中，有哪些目录，有哪些文件，对不对？</p>
<p>但是有个问题，这个文件目录树是在NameNode的内存里的啊！</p>
<p>这可坑爹了，你把重要的元数据都放在内存里，<strong>万一NameNode不小心宕机了可咋整？元数据不就全部丢失了？</strong></p>
<p>可你要是每次都频繁的修改磁盘文件里的元数据，性能肯定是极低的啊！毕竟这是大量的磁盘随机读写！</p>
<p>没关系，<strong>我们来看看HDFS优雅的解决方案。</strong></p>
<p>每次内存里改完了，写一条edits log，元数据修改的操作日志到磁盘文件里，不修改磁盘文件内容，就是顺序追加，这个性能就高多了。</p>
<p>每次NameNode重启的时候，把edits log里的操作日志读到内存里回放一下，不就可以恢复元数据了？</p>
<p><strong>大家顺着上面的文字，把整个过程，用下面这张图跟着走一遍。</strong></p>
<hr>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/13/1670dc03f2942281?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<p>但是问题又来了，那edits log如果越来越大的话，岂不是每次重启都会很慢？因为要读取大量的edits log回放恢复元数据！</p>
<p>所以HDFS说，我可以这样子啊，我引入一个新的磁盘文件叫做<strong>fsimage</strong>，然后呢，再引入一个<strong>JournalNodes</strong>集群，以及一个<strong>Standby NameNode</strong>（备节点）。</p>
<p>每次Active NameNode（主节点）修改一次元数据都会生成一条edits log，<strong>除了写入本地磁盘文件，还会写入JournalNodes集群。</strong></p>
<p>然后Standby NameNode就可以从JournalNodes集群拉取edits log，应用到自己内存的文件目录树里，跟Active NameNode保持一致。</p>
<p>然后每隔一段时间，Standby NameNode都把自己内存里的文件目录树写一份到磁盘上的fsimage，这可不是日志，这是完整的一份元数据。<strong>这个操作就是所谓的checkpoint检查点操作。</strong></p>
<p>然后把这个fsimage上传到到Active NameNode，接着清空掉Active NameNode的旧的edits log文件，这里可能都有100万行修改日志了！</p>
<p>然后Active NameNode继续接收修改元数据的请求，再写入edits log，写了一小会儿，这里可能就几十行修改日志而已！</p>
<p>如果说此时，Active NameNode重启了，bingo！没关系，只要把Standby NameNode传过来的fsimage直接读到内存里，<strong>这个fsimage直接就是元数据</strong>，不需要做任何额外操作，纯读取，效率很高！</p>
<p>然后把新的edits log里少量的几十行的修改日志回放到内存里就ok了！</p>
<p>这个过程的启动速度就快的多了！因为不需要回放大量上百万行的edits log来恢复元数据了！如下图所示。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/13/1670dc062e2fa9e8?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<p>此外，<strong>大家看看上面这张图</strong>，现在咱们有俩NameNode。</p>
<pre><code>* 一个是主节点对外提供服务接收请求
* 另外一个纯就是接收和同步主节点的edits log以及执行定期checkpoint的备节点。</code></pre><p>大家有没有发现！他们俩内存里的元数据几乎是一模一样的啊！</p>
<p>所以呢，如果Active NameNode挂了，是不是可以立马切换成Standby NameNode对外提供服务？</p>
<p><strong>这不就是所谓的NameNode主备高可用故障转移机制么！</strong></p>
<p>接下来大家再想想，HDFS客户端在NameNode内存里的文件目录树，新加了一个文件。</p>
<p>但是这个时候，人家要把数据上传到多台DataNode机器上去啊，<strong>这可是一个1TB的大文件！咋传呢？</strong></p>
<p>很简单，<strong>把1TB的大文件拆成N个block</strong>，每个block是128MB。1TB = 1024GB = 1048576MB，一个block是128MB，那么就是对应着8192个block。</p>
<p>这些block会分布在不同的机器上管理着，比如说一共有100台机器组成的集群，那么每台机器上放80个左右的block就ok了。</p>
<p>但是问题又来了，那如果这个时候1台机器宕机了，不就导致80个block丢失了？</p>
<p>也就是说上传上去的1TB的大文件，会丢失一小部分数据啊。没关系！HDFS都考虑好了！</p>
<p>它会<strong>默认给每个block搞3个副本</strong>，一模一样的副本，分放在不同的机器上，如果一台机器宕机了，同一个block还有另外两个副本在其他机器上呢！</p>
<p><strong>大伙儿看看下面这张图</strong>。每个block都在不同的机器上有3个副本，任何一台机器宕机都没事！还可以从其他的机器上拿到那个block。</p>
<p>这下子，你往HDFS上传一个1TB的大文件，可以高枕无忧了吧！</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/13/1670dc07b1a880a6?imageView2/0/w/1280/h/960/ignore-error/1" alt><br><a href></a></p>
<p><a href></a></p>
<p>OK，上面就是大白话加上一系列手绘图，给大家先聊聊小白都能听懂的Hadoop的基本架构原理</p>
<p>接下来会给大家聊聊HDFS，这个作为世界上最优秀的分布式存储系统，承载高并发请求、高性能文件上传的一些核心机制以及原理。</p>
<p><strong>《大规模集群下Hadoop如何承载每秒上千次的高并发访问》，</strong>敬请期待</p>
<p><strong>《【冰山下的秘密】Hadoop如何将TB级大文件的上传性能提升上百倍？》</strong>，敬请期待</p>
<p><strong>如有收获，请帮忙转发，您的鼓励是作者最大的动力，谢谢！</strong></p>
<p><strong>一大波微服务、分布式、高并发、高可用的**</strong>原创系列<strong>**文章正在路上,</strong></p>
<hr>
<p><strong>**欢迎扫描下方二维码</strong>，持续关注：**
<img src="https://user-gold-cdn.xitu.io/2018/11/12/167088310d1d57b1?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p><strong>石杉的架构笔记（id:shishan100）</strong></p>
<p><strong>十余年BAT架构经验倾囊相授</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/21/用大白话告诉你小白都能看懂的Hadoop架构原理/" data-id="cjwdp2re3001lcm2arx32r91i" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HDFS/">HDFS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hadoop/">Hadoop</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Token认证，如何快速方便获取用户信息" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/20/Token认证，如何快速方便获取用户信息/" class="article-date">
  <time datetime="2019-05-20T06:31:29.029Z" itemprop="datePublished">2019-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/20/Token认证，如何快速方便获取用户信息/">Token认证，如何快速方便获取用户信息</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5ce0dfb45188250c942f6c1d" target="_blank" rel="noopener">https://juejin.im/post/5ce0dfb45188250c942f6c1d</a> </p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们有一个Web项目，这个项目提供了很多的Rest API。也做了权限控制，访问API的请求必须要带上事先认证后获取的Token才可以。</p>
<p>认证的话就在Filter中进行的，会获取请求的Token进行验证，如果成功了可以得到Token中的用户信息，本文的核心就是讲解如何将用户信息（用户ID）优雅的传递给API接口（Controller）。</p>
<h1 id="方式一（很挫）"><a href="#方式一（很挫）" class="headerlink" title="方式一（很挫）"></a>方式一（很挫）</h1><p>我们在Filter中进行了统一拦截，在Controller中获取用户ID的话，仍然可以再次解析一遍Token获取用户ID</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/hello&quot;)</span><br><span class="line">public String test(HttpServletRequest request) &#123;</span><br><span class="line">    String token = request.getHeader(&quot;token&quot;);</span><br><span class="line">    JWTResult result = JWTUtils.checkToken(token);</span><br><span class="line">    Long userId = result.getUserId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方式二（优雅）"><a href="#方式二（优雅）" class="headerlink" title="方式二（优雅）"></a>方式二（优雅）</h1><p>方式一需要重新解析一遍Token, 浪费资源。我们可以直接将Filter中解析好了的用户ID直接通过Header传递给接口啊。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</span><br><span class="line">			throws IOException, ServletException &#123;</span><br><span class="line">    HttpServletRequest httpRequest = (HttpServletRequest) request;</span><br><span class="line">	HttpServletResponse httpResponse = (HttpServletResponse) response;</span><br><span class="line">    String token = request.getHeader(&quot;token&quot;);</span><br><span class="line">    JWTResult result = JWTUtils.checkToken(token);</span><br><span class="line">    Long userId = result.getUserId();</span><br><span class="line">	HttpServletRequestWrapper requestWrapper = new HttpServletRequestWrapper(httpRequest) &#123;</span><br><span class="line">		@Override</span><br><span class="line">		public String getHeader(String name) &#123;</span><br><span class="line">			if (name.equals(&quot;loginUserId&quot;)) &#123;</span><br><span class="line">				return userId .toString();</span><br><span class="line">			&#125;</span><br><span class="line">			return super.getHeader(name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	chain.doFilter(requestWrapper, httpResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中直接从Header中获取解析好了的用户ID:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/hello&quot;)</span><br><span class="line">public String save2(HttpServletRequest request) &#123;</span><br><span class="line">	Long userId = Long.parseLong(request.getHeader(&quot;loginUserId&quot;));	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方式三（很优雅）"><a href="#方式三（很优雅）" class="headerlink" title="方式三（很优雅）"></a>方式三（很优雅）</h1><p>通过Header传递确实很方便，但如果你有代码洁癖的话总会觉得怪怪的，能不能不用Header方式，比如说我就在方法上定义一个loginUserId的参数，你给我直接注入进来，这个有点意思哈，下面我们来实现下：</p>
<h3 id="GET参数方式"><a href="#GET参数方式" class="headerlink" title="GET参数方式"></a>GET参数方式</h3><p>在Filter中追加参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</span><br><span class="line">			throws IOException, ServletException &#123;</span><br><span class="line">    HttpServletRequest httpRequest = (HttpServletRequest) request;</span><br><span class="line">	HttpServletResponse httpResponse = (HttpServletResponse) response;</span><br><span class="line">    String token = request.getHeader(&quot;token&quot;);</span><br><span class="line">    JWTResult result = JWTUtils.checkToken(token);</span><br><span class="line">    Long userId = result.getUserId();</span><br><span class="line">	HttpServletRequestWrapper requestWrapper = new HttpServletRequestWrapper(httpRequest) &#123;</span><br><span class="line">		    @Override</span><br><span class="line">			public String[] getParameterValues(String name) &#123;</span><br><span class="line">				if (name.equals(&quot;loginUserId&quot;)) &#123;</span><br><span class="line">					return new String[] &#123; userId .toString() &#125;;</span><br><span class="line">				&#125;</span><br><span class="line">				return super.getParameterValues(name);</span><br><span class="line">			&#125;</span><br><span class="line">			@Override</span><br><span class="line">			public Enumeration&lt;String&gt; getParameterNames() &#123;</span><br><span class="line">				Set&lt;String&gt; paramNames = new LinkedHashSet&lt;&gt;();</span><br><span class="line">				paramNames.add(&quot;loginUserId&quot;);</span><br><span class="line">				Enumeration&lt;String&gt; names =  super.getParameterNames();</span><br><span class="line">				while(names.hasMoreElements()) &#123;</span><br><span class="line">					paramNames.add(names.nextElement());</span><br><span class="line">				&#125;</span><br><span class="line">				return Collections.enumeration(paramNames);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	chain.doFilter(requestWrapper, httpResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中直接填写参数即可获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/hello&quot;)</span><br><span class="line">public String save2(String name, Long loginUserId) &#123;</span><br><span class="line">	// loginUserId 就是Filter中追加的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于post请求，也可以用这种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/hello&quot;)</span><br><span class="line">public String save2(User user, Long loginUserId) &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可是往往我们在用post请求的时候，要么就是表单提交，要么就是json体的方式提交，一般不会使用get方式参数，这也就意味着这个loginUserId我们需要注入到对象中：</p>
<p>先创建一个参数实体类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">	private String name;</span><br><span class="line">	</span><br><span class="line">	private Long loginUserId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先模拟表单提交的方式，看看行不行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/hello&quot;)</span><br><span class="line">public User save2(User user) &#123;</span><br><span class="line">	return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用PostMan测试一下，表单方式是直接支持的：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/19/16ace69edcd28f75?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>再次试下Json提交方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/hello&quot;)</span><br><span class="line">public User save2(@RequestBody User user) &#123;</span><br><span class="line">	return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下图，失败了，得重新想办法实现下</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/19/16ace69edcc90ca7?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>只需要在HttpServletRequestWrapper中重新对提交的内容进行修改即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ServletInputStream getInputStream() throws IOException &#123;</span><br><span class="line">	byte[] requestBody = new byte[0];</span><br><span class="line">	try &#123;</span><br><span class="line">		requestBody = StreamUtils.copyToByteArray(request.getInputStream());</span><br><span class="line">		Map map = JsonUtils.toBean(Map.class, new String(requestBody));</span><br><span class="line">		map.put(&quot;loginUserId&quot;, loginUserId);</span><br><span class="line">		requestBody = JsonUtils.toJson(map).getBytes();</span><br><span class="line">	&#125; catch (IOException e) &#123;</span><br><span class="line">		throw new RuntimeException(e);</span><br><span class="line">	&#125;</span><br><span class="line">	final ByteArrayInputStream bais = new ByteArrayInputStream(requestBody);</span><br><span class="line">	return new ServletInputStream() &#123;</span><br><span class="line">		 @Override</span><br><span class="line">		  public int read() throws IOException &#123;</span><br><span class="line">		       return bais.read();</span><br><span class="line">		  &#125;</span><br><span class="line">		 </span><br><span class="line">		  @Override</span><br><span class="line">		   public boolean isFinished() &#123;</span><br><span class="line">		       return false;</span><br><span class="line">		   &#125;</span><br><span class="line">		 </span><br><span class="line">		   @Override</span><br><span class="line">		   public boolean isReady() &#123;</span><br><span class="line">		        return true;</span><br><span class="line">		   &#125;</span><br><span class="line">		 </span><br><span class="line">		   @Override</span><br><span class="line">		    public void setReadListener(ReadListener listener) &#123;</span><br><span class="line">		 </span><br><span class="line">		    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，我们就可以直接将Token解析的用户ID直接注入到参数中了，不用去Header中获取，是不是很方便。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/15/16ab91d71d2ab715?imageView2/0/w/1280/h/960/ignore-error/1" alt="猿天地"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/20/Token认证，如何快速方便获取用户信息/" data-id="cjwdp2rdg000gcm2af71ao0fr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HDFS/">HDFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactor/">Reactor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/">RxJava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue-js/">Vue.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端/">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微服务/">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/HDFS/" style="font-size: 10px;">HDFS</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Reactor/" style="font-size: 10px;">Reactor</a> <a href="/tags/RxJava/" style="font-size: 10px;">RxJava</a> <a href="/tags/Spring/" style="font-size: 13.33px;">Spring</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP/IP</a> <a href="/tags/Vue-js/" style="font-size: 10px;">Vue.js</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/后端/" style="font-size: 10px;">后端</a> <a href="/tags/微服务/" style="font-size: 10px;">微服务</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/服务器/" style="font-size: 10px;">服务器</a> <a href="/tags/架构/" style="font-size: 16.67px;">架构</a> <a href="/tags/源码/" style="font-size: 10px;">源码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/01/SpringBoot实现动态控制定时任务-支持多参数/">SpringBoot实现动态控制定时任务-支持多参数</a>
          </li>
        
          <li>
            <a href="/2019/05/31/感受lambda之美，推荐收藏，需要时查阅/">感受lambda之美，推荐收藏，需要时查阅</a>
          </li>
        
          <li>
            <a href="/2019/05/30/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/05/30/Effective Java/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/05/30/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 huan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>