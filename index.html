<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>HUAN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="HUAN">
<meta property="og:url" content="http://sillyfan.top/index.html">
<meta property="og:site_name" content="HUAN">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HUAN">
  
    <link rel="alternate" href="/atom.xml" title="HUAN" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HUAN</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://sillyfan.top"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-万万没想到，JVM内存结构的面试题可以问的这么难？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/06/万万没想到，JVM内存结构的面试题可以问的这么难？/" class="article-date">
  <time datetime="2019-08-06T03:41:56.056Z" itemprop="datePublished">2019-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/06/万万没想到，JVM内存结构的面试题可以问的这么难？/">万万没想到，JVM内存结构的面试题可以问的这么难？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5d4789afe51d453b386a62ac" target="_blank" rel="noopener">https://juejin.im/post/5d4789afe51d453b386a62ac</a> </p>
</blockquote>
<p>在我的博客中，之前有很多文章介绍过JVM内存结构，相信很多看多我文章的朋友对这部分知识都有一定的了解了。</p>
<p>那么，请大家尝试着回答一下以下问题：</p>
<p>1、JVM管理的内存结构是怎样的？<br>2、不同的虚拟机在实现运行时内存的时候有什么区别？<br>3、运行时数据区中哪些区域是线程共享的？哪些是独享的？<br>4、除了JVM运行时内存以外，还有什么区域可以用吗？<br>5、堆和栈的区别是什么？<br>6、Java中的数组是存储在堆上还是栈上的？<br>7、Java中的对象创建有多少种方式？<br>8、Java中对象创建的过程是怎么样的？<br>9、Java中的对象一定在堆上分配内存吗？<br>10、如何获取堆和栈的dump文件？</p>
<p>以上10道题，如果您可以全部准确无误的回答的话，那说明你真的很了解JVM的内存结构以及内存分配相关的知识了，如果有哪些知识点是不了解的，那么本文正好可以帮你答疑解惑。<br>JVM管理的内存结构是怎样的？</p>
<p>Java虚拟机在执行Java程序的过程中会把他所管理的内存划分为若干个不同的数据区域。《Java虚拟机规范》中规定了JVM所管理的内存需要包括一下几个运行时区域：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/5/16c5f71ceedef2ff?imageView2/0/w/1280/h/960/ignore-error/1" alt>￼</p>
<p>主要包含了PC寄存器（程序计数器）、Java虚拟机栈、本地方法栈、Java堆、方法区以及运行时常量池。</p>
<p>各个区域有各自不同的作用，关于各个区域的作用就不在本文中相信介绍了。</p>
<p>但是，需要注意的是，上面的区域划分只是逻辑区域，对于有些区域的限制是比较松的，所以不同的虚拟机厂商在实现上，甚至是同一款虚拟机的不同版本也是不尽相同的。<br>不同的虚拟机在实现运行时内存的时候有什么区别？</p>
<p>前面提到过《Java虚拟机规范》定义的JVM运行时所需的内存区域，不同的虚拟机实现上有所不同，而在这么多区域中，规范对于方法区的管理是最宽松的，规范中关于这部分的描述如下：</p>
<p>方法区在虚拟机启动的时候创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择在这个区域不实现垃圾收集与压缩。本版本的规范也不限定实现方法区的内存位置和代码编译的管理策略。方法区的容量可以是固定的，也可以随着程序执行的需求动态扩展，并在不需要过多的空间时自行收缩。方法区在实际内存空间站可以是不连续的。</p>
<p>这一规定，可以说是给了虚拟机厂商很大的自由。</p>
<p>虚拟机规范对方法区实现的位置并没有明确要求，在最著名的HotSopt虚拟机实现中（在Java 8 之前），方法区仅是逻辑上的独立区域，在物理上并没有独立于堆而存在，而是位于永久代中。所以，这时候方法区也是可以被垃圾回收的。<br>实践证明，JVM中存在着大量的声明短暂的对象，还有一些生命周期比较长的对象。为了对他们采用不同的收集策略，采用了分代收集算法，所以HotSpot虚拟机把的根据对象的年龄不同，把堆分位新生代、老年代和永久代。</p>
<p>在Java 8中 ，HotSpot虚拟机移除了永久代，使用本地内存来存储类元数据信息并称之为：元空间（Metaspace）</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/5/16c5f71cedf925ff?imageView2/0/w/1280/h/960/ignore-error/1" alt>￼
运行时数据区中哪些区域是线程共享的？哪些是独享的？</p>
<p>在JVM运行时内存区域中，PC寄存器、虚拟机栈和本地方法栈是线程独享的。</p>
<p>而Java堆、方法区是线程共享的。但是值得注意的是，Java堆其实还未每一个线程单独分配了一块<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.hollischuang.com%2Farchives%2F3855" target="_blank" rel="noopener">TLAB空间</a>，这部分空间在分配时是线程独享的，在使用时是线程共享的。<br>除了JVM运行时内存以外，还有什么区域可以用吗？</p>
<p>除了我们前面介绍的虚拟机运行时数据区以外，还有一部分内存也被频繁使用，他不是运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，他就是——直接内存。</p>
<p>直接内存的分配不受Java堆大小的限制，但是他还是会收到服务器总内存的影响。</p>
<p>在JDK 1.4中引入的NIO中，引入了一种基于Channel和Buffer的I/O方式，他可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的应用进行操作。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/5/16c5f71cf1ef6818?imageView2/0/w/1280/h/960/ignore-error/1" alt>￼
堆和栈的区别是什么？</p>
<p>堆和栈（虚拟机栈）是完全不同的两块内存区域，一个是线程独享的，一个是线程共享的，二者之间最大的区别就是存储的内容不同：</p>
<p>堆中主要存放对象实例。<br>栈（局部变量表）中主要存放各种基本数据类型、对象的引用。<br>Java中的数组是存储在堆上还是栈上的？</p>
<p>在Java中，数组同样是一个对象，所以对象在内存中如何存放同样适用于数组；</p>
<p>所以，数组的实例是保存在堆中，而数组的引用是保存在栈上的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/5/16c5f71ceef4b84d?imageView2/0/w/1280/h/960/ignore-error/1" alt>￼
Java中的对象创建有多少种方式？</p>
<p>Java中有很多方式可以创建一个对象，最简单的方式就是使用new关键字。</p>
<p><code>User user = new User();</code></p>
<p>除此以外，还可以使用反射机制创建对象：</p>
<p><code>User user = User.class.newInstance();</code></p>
<p>或者使用Constructor类的newInstance：</p>
<p><code>Constructor&lt;User&gt; constructor = User.class.getConstructor();
User user = constructor.newInstance();</code></p>
<p>除此之外还可以使用clone方法和反序列化的方式，这两种方式不常用并且代码比较复杂，就不在这里展示了，感兴趣的可以自行了解下。</p>
<p>Java中对象创建的过程是怎么样的？</p>
<p>对于一个普通的Java对象的创建，大致过程如下：</p>
<p>1、虚拟机遇到new指令，到常量池定位到这个类的符号引用。<br>2、检查符号引用代表的类是否被加载、解析、初始化过。<br>3、虚拟机为对象分配内存。<br>4、虚拟机将分配到的内存空间都初始化为零值。<br>5、虚拟机对对象进行必要的设置。<br>6、执行方法，成员变量进行初始化。<br>Java中的对象一定在堆上分配内存吗？</p>
<p>前面我们说过，Java堆中主要保存了对象实例，但是，随着JIT编译期的发展与<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2583" target="_blank" rel="noopener">逃逸分析</a>技术逐渐成熟，<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2398" target="_blank" rel="noopener">栈上分配</a>、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>
<p>其实，在编译期间，JIT会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，其中一种重要的技术叫做逃逸分析。</p>
<p>如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/5/16c5f71cf10db7bf?imageView2/0/w/1280/h/960/ignore-error/1" alt>￼
10、如何获取堆和栈的dump文件？</p>
<p>Java Dump，Java虚拟机的运行时快照。将Java虚拟机运行时的状态和信息保存到文件。</p>
<p>可以使用在服务器上使用<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.hollischuang.com%2Farchives%2F303" target="_blank" rel="noopener">jmap</a>命令来获取堆dump，使用<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.hollischuang.com%2Farchives%2F110" target="_blank" rel="noopener">jstack</a>命令来获取线程的调用栈dump。</p>
<p>最后，欢迎大家关注我的公众号：<br><img src="https://user-gold-cdn.xitu.io/2019/8/5/16c5f71f7d7e8f51?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/08/06/万万没想到，JVM内存结构的面试题可以问的这么难？/" data-id="cjyza2xxk0012af2arguanpjo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-分布式数据库中间件MyCat搞起来！" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/28/分布式数据库中间件MyCat搞起来！/" class="article-date">
  <time datetime="2019-06-28T07:51:14.014Z" itemprop="datePublished">2019-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/28/分布式数据库中间件MyCat搞起来！/">分布式数据库中间件 MyCat 搞起来！</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5d1566caf265da1ba77cb708" target="_blank" rel="noopener">https://juejin.im/post/5d1566caf265da1ba77cb708</a> </p>
</blockquote>
<p>关于 MyCat 的铺垫文章已经写了三篇了：</p>
<pre><code>1. [MySQL 只能做小项目？松哥要说几句公道话！](https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FbcyjBgEqg6Or5zdi4jHaiA)
1. [北冥有 Data，其名为鲲，鲲之大，一个 MySQL 放不下！](https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FqUGANVj2mmoMwUZEV5Zc1w)
1. [What？Tomcat 竟然也算中间件？](https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F7pj5E2HvmiejBJrW0T86oQ)</code></pre><p>今天终于可以迎接我们的大 Boss 出场了！</p>
<h1 id="MyCat-简介"><a href="#MyCat-简介" class="headerlink" title="MyCat 简介"></a>MyCat 简介</h1><p>前面文章我们提到，如果数据量比较大的话，我们需要对数据进行分库分表，分完之后，原本存在一个数据库中的数据，现在就存在多个数据库中了，就像下面这样：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/6/28/16b9b999eca3fda2?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>那么此时 MyCat 所扮演的角色就是分布式数据库中间件！</p>
<p>MyCat 是一个开源的分布式数据库中间件，它实现了 MySQL 协议，在开发者眼里，他就是一个数据库代理，我们甚至可以使用 MySQL 的客户端工具以及命令行来访问 MyCat 。</p>
<p>MyCat 现在已经不仅仅只支持 MySQL 了，同时也支持 MSSQL、Oracle、DB2、以及 PostgreSQL等主流数据库。甚至像 MongoDB 这种 NoSQL 也支持。</p>
<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="搭建读写分离"><a href="#搭建读写分离" class="headerlink" title="搭建读写分离"></a>搭建读写分离</h2><p>要搞 MyCat ，一般要先搭建好 MySQL 的读写分离，MySQL 的读写分离可以参考松哥之前的这篇文章：</p>
<pre><code>1. [提高性能，MySQL 读写分离环境搭建(二)](https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FSC0OYM6yO_GxQh9DvSsnoQ)</code></pre><h2 id="MyCat-安装"><a href="#MyCat-安装" class="headerlink" title="MyCat 安装"></a>MyCat 安装</h2><p>环境：</p>
<pre><code>* CentOS7
* JDK1.8</code></pre><p>MyCat 使用 Java 开发，因此，运行 MyCat ，一定要具备 Java 环境，配置 Java 运行环境这个比较容易，网上资料也很多，我就不详细介绍了。</p>
<p>Java 环境安装好之后，首先下载 MyCat：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://dl.mycat.io/1.6.7.1/Mycat-server-1.6.7.1-release-20190213150257-linux.tar.gz</span><br></pre></td></tr></table></figure>

<p>下载完成后，对下载文件进行解压。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf Mycat-server-1.6.7.1-release-20190213150257-linux.tar.gz</span><br></pre></td></tr></table></figure>

<p>解压成功后，会出现一个 <code>mycat</code> 目录，进入到 <code>mycat/conf</code> 目录，对 <code>mycat</code> 进行配置：</p>
<p>首先来配置 <code>schema.xml</code> 文件：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/6/28/16b9b999ec783a97?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<pre><code>1. 首先在 `schema` 中指定逻辑库的名字，逻辑库是指 `MyCat` 中的库，这个库不存储数据，数据存储在 `MySQL` 中的物理库中。
1. 逻辑库中配置逻辑表，配置逻辑表时，需要指定 `dataNode` 节点， `dataNode` 就是指数据库存储的位置
1. 配置 `dataNode` ，`dataNode` 指定 `dataHost` 和物理库的名字。
1. `dataHost` 则配置 `MySQL` 的主机和从机的位置，登录密码等。主机和从机都可以配置多个。</code></pre><p>配置完 schema.xml 后 ，接下来配置 server.xml。</p>
<p>server.xml 中主要配置 MyCat 的登录用户名和密码，以及需要操作的逻辑库。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/6/28/16b9b99a1a7fec73?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>配置完成后，接下来就可以启动 MyCat 了 。</p>
<p>执行 MyCat 解压目录下的 bin 目录下的 mycat 命令，可以启动 MyCat</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/mycat start</span><br></pre></td></tr></table></figure>

<p>如果启动后，提示无法创建 <code>mycat.pid</code> 文件，就自己手动创建一个 <code>mycat.pid</code> 文件。启动成功之后，就可以在本地连接 <code>MyCat</code> 了，连接方式和 <code>MySQL</code> 一样，唯一的区别在于端口号不同。</p>
<p>在连接 <code>MyCat</code> 之前，先在 <code>MySQL</code> 物理库中创建 <code>db1</code>、<code>db2</code> 以及 <code>db3</code> 三个数据库。</p>
<p>使用 <code>SQLyog</code> 连接：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/6/28/16b9b999ecbdcb90?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>也可以在 <code>cmd</code> 命令行登录 <code>MyCat</code> ：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/6/28/16b9b999f41ebb17?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>登录成功后 ，在 <code>MyCat</code> 的窗口中，执行如下命令，创建表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table t_user (id integer primary key,username varchar(255))</span><br></pre></td></tr></table></figure>

<p>执行成功后，我们会发现物理库中出现了相应的表。 接下来，手动往各个物理库的物理表中存储一条数据，然后在 MyCat 窗口中查询：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/6/28/16b9b999eccf3c2f?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>这样就可以查询到 三个库中的三个表中的数据。</p>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>整个过程不难，但是有的小伙伴在第一次配置的过程中还是容易出错，因此我这里还是来说两句，出错了要如何定位。</p>
<p>一般来说，配置 MyCat 出错，问题可能发生在两个阶段。第一个阶段就是客户端连接 MyCat 出错，第二个阶段就是 MyCat 连接 MySQL 出错。</p>
<p>无论你是使用 SQLyog 还是 Navicat ，我们在连接数据库的过程中，都可以先测试连接，很多人卡在这一步。</p>
<p>如果在测试连接的时候就连接不通，说明是 MyCat 的问题，这个时候检查步骤如下：</p>
<pre><code>1. 首先当然是查看日志信息，看能不能找出端倪
1. 通过 jps 命令查看 mycat 是否成功启动
1. 检查 server.xml 中配置是否正确，用户名密码是否输入正确</code></pre><p>这是第一种可能的问题，第二种问题就是测试连接没问题，但是测试完后，却连接不上。反映到 Navicat 上，就是测试连接没问题，测完之后，点击连接名要打开连接时，Navicat 就崩了，出现这个问题一般是 MyCat 在连接 MySQL 出问题了，这个时候就要去检查 schema.xml 文件中关于 MySQL 主机和从机的配置是否正确，数据库地址是否正确，用户名密码是否正确。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>好了，本文主要简单介绍了下 MyCat 的安装问题，下篇文章我们来看 MyCat 中的分片规则问题。</p>
<p>参考资料：</p>
<pre><code>1. [MyCat 官方文档](https://link.juejin.im?target=http%3A%2F%2Fwww.mycat.io%2F)</code></pre><p>关注公众号【江南一点雨】，专注于 Spring Boot+微服务以及前后端分离等全栈技术，定期视频教程分享，关注后回复 Java ，领取松哥为你精心准备的 Java 干货！<br><img src="https://user-gold-cdn.xitu.io/2019/6/28/16b9b99ae9446d11?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/06/28/分布式数据库中间件MyCat搞起来！/" data-id="cjyza2xy60029af2avq48pj00" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux生产环境上，最常用的一套“AWK“技巧" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/20/Linux生产环境上，最常用的一套“AWK“技巧/" class="article-date">
  <time datetime="2019-06-20T09:56:51.051Z" itemprop="datePublished">2019-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/20/Linux生产环境上，最常用的一套“AWK“技巧/">Linux生产环境上，最常用的一套“AWK“技巧</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5d0b4ca1f265da1bbc6fdb9e" target="_blank" rel="noopener">https://juejin.im/post/5d0b4ca1f265da1bbc6fdb9e</a> </p>
</blockquote>
<p>hi，大家好，小姐姐味道最有用系列完结。记得多多转发，点赞哦。</p>
<p>最有用系列：</p>
<p><a href="https://juejin.im/post/5bfa4211e51d4550184546ea" target="_blank" rel="noopener">《Linux生产环境上，最常用的一套“vim“技巧》</a></p>
<p><a href="https://juejin.im/post/5ce5190b5188252dbb08baa8" target="_blank" rel="noopener">《Linux生产环境上，最常用的一套“Sed“技巧》</a></p>
<p><a href="https://juejin.im/post/5d0b4ca1f265da1bbc6fdb9e" target="_blank" rel="noopener">《Linux生产环境上，最常用的一套“AWK“技巧》</a></p>
<p><a href="https://juejin.im/post/5cf5cb8c6fb9a07ef2010cb1" target="_blank" rel="noopener">《”Sed” 高级功能：我这小脑瓜都快绕晕了》</a></p>
<p>敢用自己的名字做软件名字的，都有非常强大的自信。比如，垠语言什么的。</p>
<p><code>awk</code>的命名得自于它的三个创始人姓别的首字母，都是<code>80来岁</code>的老爷爷了。当然也有四个人的组合：流行的GoF设计模式。但对于我这游戏爱好者来说，想到的竟然是三位一体，果然是不争气啊。</p>
<p>它长的很像C，为什么这么有名，除了它强大的功能，我们姑且认为<code>a</code>这个字母比较靠前吧。<code>awk</code>比<code>sed</code>简单，它更像一门编程语言。</p>
<h1 id="打印某一列"><a href="#打印某一列" class="headerlink" title="打印某一列"></a>打印某一列</h1><p>下面，这几行代码的效果基本是相同的：打印文件中的第一列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#Java</span><br><span class="line">System.out.println(aStr.split(&quot; &quot;)[0]);</span><br><span class="line"></span><br><span class="line">#Python</span><br><span class="line">print(aString.split(&quot; &quot;)[0])</span><br><span class="line"></span><br><span class="line">#cut 命令</span><br><span class="line">cut -d &quot; &quot; -f1   file</span><br><span class="line"></span><br><span class="line">#awk命令</span><br><span class="line">awk &apos;&#123;print $1&#125;&apos; file</span><br></pre></td></tr></table></figure>

<p>这可能是awk最常用的功能了：<strong>打印文件中的某一列</strong>。它智能的去切分你的数据，不管是<code>空格</code>，还是<code>TAB</code>，大概率是你想要的。</p>
<p>对于csv这种文件来说，分隔的字符是<code>,</code>。AWK使用<code>-F</code>参数去指定。以下代码打印csv文件中的第1和第2列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F &quot;,&quot;  &apos;&#123;print $1,$2&#125;&apos; file</span><br></pre></td></tr></table></figure>

<p>由此，我们可以看出一个基本的awk命令的组成部分。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/6/20/16b7424643b79faa?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p><strong>一般的开发语言，数组下标是以0开始的，但awk的列<code>$</code>是以<code>1</code>开始的，而<code>0</code>指的是原始字符串。</strong></p>
<h1 id="网络状态统计"><a href="#网络状态统计" class="headerlink" title="网络状态统计"></a>网络状态统计</h1><p>本小节，采用awk统计netstat命令的一些网络状态，来看一下awk语言的基本要素。netstat的输出类似于：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/6/20/16b7424af6eabdd0?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>其中，第6列，标明了网络连接所处于的网络状态。我们先给出awk命令，看一下统计结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">netstat  -ant | </span><br><span class="line">awk &apos; \</span><br><span class="line">    BEGIN&#123;print  &quot;State&quot;,&quot;Count&quot; &#125;  \</span><br><span class="line">    /^tcp/ \</span><br><span class="line">    &#123; rt[$6]++ &#125; \</span><br><span class="line">    END&#123;  for(i in rt)&#123;print i,rt[i]&#125;  &#125;&apos;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">State Count</span><br><span class="line">LAST_ACK 1</span><br><span class="line">LISTEN 64</span><br><span class="line">CLOSE_WAIT 43</span><br><span class="line">ESTABLISHED 719</span><br><span class="line">SYN_SENT 5</span><br><span class="line">TIME_WAIT 146</span><br></pre></td></tr></table></figure>

<p>下面这张图会配合以上命令详细说明，希望你能了解awk的精髓。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/6/20/16b7424e94105932?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>乍一看，好吓人的命令，但是很简单。awk和我们通常的程序不太一样，它分为四个部分。</p>
<p>1、<strong>BEGIN 开头部分</strong>，可选的。用来设置一些参数，输出一些表头，定义一些变量等。上面的命令仅打印了一行信息而已。</p>
<p>2、<strong>END 结尾部分</strong>，可选的。用来计算一些汇总逻辑，或者输出这些内容。上面的命令，使用简单的for循环，输出了数组rt中的内容。</p>
<p>3、<strong>Pattern 匹配部分</strong>，依然可选。用来匹配一些需要处理的行。上面的命令，只匹配tcp开头的行，其他的不进入处理。</p>
<p>4、<strong>Action 模块</strong>。主要逻辑体，按行处理，统计打印，都可以。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>1、awk的主程序部分使用单引号‘包围，而不能是双引号 2、awk的列开始的index是0，而不是1</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>我们从几个简单的例子，来看下awk的作用。</p>
<p>1、输出Recv-Q不为0的记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ant | awk &apos;$2 &gt; 0 &#123;print&#125;&apos;</span><br></pre></td></tr></table></figure>

<p>2、外网连接数，根据ip分组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ant | awk &apos;/^tcp/&#123;print $4&#125;&apos; | awk -F: &apos;!/^:/&#123;print $1&#125;&apos; | sort | uniq -c</span><br></pre></td></tr></table></figure>

<p>3、打印RSS物理内存占用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -b -n 1 | awk &apos;NR&gt;7&#123;rss+=$6&#125;END&#123;print rss&#125;</span><br></pre></td></tr></table></figure>

<p>4、过滤（去掉）空白行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;NF&apos; file</span><br></pre></td></tr></table></figure>

<p>5、打印奇数行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;a=!a&apos; file</span><br></pre></td></tr></table></figure>

<p>6、输出行数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;END&#123;print NR&#125;&apos; file</span><br></pre></td></tr></table></figure>

<p>这些命令，是需要了解awk的一些内部变量的，接下来我们来介绍。</p>
<h1 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h1><h2 id="FS"><a href="#FS" class="headerlink" title="FS"></a>FS</h2><p>下面的两个命令是等价的 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk -F &apos;:&apos;  &apos;&#123;print $3&#125;&apos; file</span><br><span class="line">awk &apos;BEGIN&#123;FS=&quot;:&quot;&#125;&#123;print $3&#125;&apos; file</span><br></pre></td></tr></table></figure>

<p>/<em>/</em>BEGIN块中的<code>FS</code>，就是内部变量，可以直接指定或者输出。/<em>/</em>如果你的文件既有用<code>,</code>分隔的，也有用<code>:</code>分割的，FS甚至可以指定多个分隔符同时起作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FS=&quot;[,:|]&quot;</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>OFS</strong> 指定输出内容的分割符，列数非常多的时候，简化操作。相似命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk -F &apos;:&apos; &apos;&#123;print $1,&quot;-&quot;,$2,&quot;-&quot;,$4&#125;&apos; file</span><br><span class="line">awk &apos;BEGIN&#123;FS=&quot;:&quot;;OFS=&quot;-&quot;&#125;&#123;print $1,$2,$4&#125;&apos; file</span><br></pre></td></tr></table></figure>

<p><strong>NF</strong> 列数。非常有用，比如，过滤一些列数不满足条件的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F, &apos;&#123;if(NF==3)&#123;print&#125;&#125;&apos; file</span><br></pre></td></tr></table></figure>

<p><strong>NR</strong> 行号，例如，下面两个命令是等价的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat -n file</span><br><span class="line">awk &apos;&#123;print NR,$0&#125;&apos; file</span><br></pre></td></tr></table></figure>

<p><strong>RS</strong> 记录分隔标志 <strong>ORS</strong> 指定记录输出的分隔标志</p>
<p><strong>FILENAME</strong> 当前处理的文件名称，在一次性处理多个文件时非常有用</p>
<h2 id="编程语言特性"><a href="#编程语言特性" class="headerlink" title="编程语言特性"></a>编程语言特性</h2><h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><p>从上面的代码可以看出，awk可以做一些简单的运算。它的语言简洁，不需要显示的定义变量的类型。</p>
<p>比如上面的<code>rt[$6]++</code>，就已经默认定义了一个叫做rt的hash(array?)，里面的key是网络状态，而value是可以进行运算的(+-/*/%)。</p>
<p>包含一些内置的数学运算（有限)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">log</span><br><span class="line">sqrt</span><br><span class="line">exp</span><br><span class="line">sin</span><br><span class="line">cos</span><br><span class="line">atan2</span><br><span class="line">rand</span><br><span class="line">srand</span><br></pre></td></tr></table></figure>

<h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><p>类似其他语言，awk也内置了很多字符串操作函数。它本来就是处理字符串的，所以必须强大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">length(str) #获取字符串长度</span><br><span class="line">split(input-string,output-array,separator)</span><br><span class="line">substr(input-string, location, length)</span><br></pre></td></tr></table></figure>

<h3 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h3><p>awk是个小型的编程语言，看它的基本语法，如果你需要复杂一点的逻辑，请自行深入了解，包括一些时间处理函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># logic</span><br><span class="line">if(x=a)&#123;&#125;</span><br><span class="line">if(x=a)&#123;&#125;else&#123;&#125;</span><br><span class="line">while(x=a)&#123;break;continue;&#125;</span><br><span class="line">do&#123;&#125;while(x=a)</span><br><span class="line">for(;;)&#123;&#125;</span><br><span class="line"></span><br><span class="line"># array</span><br><span class="line">arr[key] = value</span><br><span class="line">for(key in arr)&#123;arr[key]&#125;</span><br><span class="line">delete arr[key]</span><br><span class="line"></span><br><span class="line">asort(arr) #简单排序</span><br></pre></td></tr></table></figure>

<p>据说，awk可以胜任所有的文本操作。因为它本身就是一门语言啊。</p>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>曾经使用awk编写过复杂的日志处理和统计程序。虽然比写<code>sed</code>舒畅了很多，但还是备受煎熬。更加上现在有各种nawk,gawk版本之间的区别，所以业务复杂度一增长，就习惯性的转向更加简洁、工具更全的python。</p>
<p>awk处理一些简单的文本还是极其方便的，最常用的还是打印某一列之类的，包括一些格式化输出。对于awk，要简单的滚瓜烂熟，复杂的耳熟能详，毕竟有些<code>大牛</code>，就喜欢写这种脚本呢。</p>
<p>更多精彩文章。</p>
<p><a href="https://juejin.im/post/5c49317d5188252d3b3e377b" target="_blank" rel="noopener">《微服务不是全部，只是特定领域的子集》</a></p>
<p><a href="https://juejin.im/post/5bf778ef5188251b8a26ed8b" target="_blank" rel="noopener">《“分库分表” ？选型和流程要慎重，否则会失控》</a></p>
<p><a href="https://juejin.im/post/5bee22c051882528c4466334" target="_blank" rel="noopener">这么多监控组件，总有一款适合你</a></p>
<p><a href="https://juejin.im/post/5c186088f265da61691728fd" target="_blank" rel="noopener">《Kafka消息系统基础知识索引》</a></p>
<p><a href="https://juejin.im/post/5c75cbabe51d453ecf7d6f3f" target="_blank" rel="noopener">《使用Netty，我们到底在开发些什么？》</a></p>
<p>Linux五件套之类的。</p>
<p><a href="https://juejin.im/post/5bed239251882502df7f1e8e" target="_blank" rel="noopener">《Linux之《荒岛余生》（一）准备篇》</a></p>
<p><a href="https://juejin.im/post/5bf0b52df265da611b57f0e6" target="_blank" rel="noopener">《Linux之《荒岛余生》（二）CPU篇》</a></p>
<p><a href="https://juejin.im/post/5c00aee06fb9a049be5d3641" target="_blank" rel="noopener">《Linux之《荒岛余生》（三）内存篇》</a></p>
<p><a href="https://juejin.im/post/5c1dff6851882546150afb8f" target="_blank" rel="noopener">《Linux之《荒岛余生》（四）I/O篇》</a></p>
<p><a href="https://juejin.im/post/5c272ec66fb9a049e93ccffe" target="_blank" rel="noopener">《Linux之《荒岛余生》（五）网络篇》</a></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/6/17/16b64cb6e60d3b3a?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/06/20/Linux生产环境上，最常用的一套“AWK“技巧/" data-id="cjyza2xy50027af2awsd510qu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Shell/">Shell</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-死磕Java内部类（一篇就够）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/18/死磕Java内部类（一篇就够）/" class="article-date">
  <time datetime="2019-06-18T07:18:46.046Z" itemprop="datePublished">2019-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/18/死磕Java内部类（一篇就够）/">死磕Java内部类（一篇就够）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5d0821315188254c434686c8" target="_blank" rel="noopener">https://juejin.im/post/5d0821315188254c434686c8</a><br>Java内部类，相信大家都用过，但是多数同学可能对它了解的并不深入，只是靠记忆来完成日常工作，却不能融会贯通，遇到奇葩问题更是难以有思路去解决。这篇文章带大家一起死磕Java内部类的方方面面。 友情提示：这篇文章的讨论基于JDK版本 1.8.0_191</p>
</blockquote>
<h3 id="开篇问题"><a href="#开篇问题" class="headerlink" title="开篇问题"></a>开篇问题</h3><p>我一直觉得技术是工具，是一定要落地的，要切实解决某些问题的，所以我们通过先抛出问题，然后解决这些问题，在这个过程中来加深理解，最容易有收获。 so，先抛出几个问题。（如果这些问题你早已思考过，答案也了然于胸，那恭喜你，这篇文章可以关掉了）。</p>
<pre><code>* **为什么需要内部类？**
* **为什么内部类（包括匿名内部类、局部内部类），会持有外部类的引用？**
* **为什么匿名内部类使用到外部类方法中的局部变量时需要是final类型的？**
* **如何创建内部类实例，如何继承内部类？**
* **Lambda表达式是如何实现的？**</code></pre><h3 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类?"></a>为什么需要内部类?</h3><p>要回答这个问题，先要弄明白什么是内部类？我们知道Java有三种类型的内部类</p>
<h3 id="普通的内部类"><a href="#普通的内部类" class="headerlink" title="普通的内部类"></a>普通的内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line"></span><br><span class="line">    // 普通内部类</span><br><span class="line">    public class DemoRunnable implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line"></span><br><span class="line">    // 匿名内部类</span><br><span class="line">    private Runnable runnable = new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法内局部内部类"><a href="#方法内局部内部类" class="headerlink" title="方法内局部内部类"></a>方法内局部内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line"></span><br><span class="line">    // 局部内部类</span><br><span class="line">    public void work() &#123;</span><br><span class="line">        class InnerRunnable implements Runnable &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        InnerRunnable runnable = new InnerRunnable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三种形式的内部类，大家肯定都用过，但是技术在设计之初肯定也是要用来解决某个问题或者某个痛点，那可以想想内部类相对比外部定义类有什么优势呢？ 我们通过一个小例子来做说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Worker &#123;</span><br><span class="line">    private List&lt;Job&gt; mJobList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void addJob(Runnable task) &#123;</span><br><span class="line">        mJobList.add(new Job(task));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class Job implements Runnable &#123;</span><br><span class="line">        Runnable task;</span><br><span class="line">        public  Job(Runnable task) &#123;</span><br><span class="line">            this.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">            System.out.println(&quot;left job size : &quot; + mJobList.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了一个Worker类，暴露了一个addJob方法，一个参数task，类型是Runnable，然后定义 了一个内部类Job类对task进行了一层封装，这里Job是私有的，所以外界是感知不到Job的存在的，所以有了内部类第一个优势。</p>
<pre><code>* **内部类能够更好的封装，内聚，屏蔽细节**</code></pre><p>我们在Job的run方法中，打印了外部Worker的mJobList列表中剩余Job数量，代码这样写没问题，但是细想，内部类是如何拿到外部类的成员变量的呢？这里先卖个关子，但是已经可以先得出内部类的第二个优势了。</p>
<pre><code>* **内部类天然有访问外部类成员变量的能力**</code></pre><p>内部类主要就是上面的二个优势。当然还有一些其他的小优点，比如可以用来实现多重继承，可以将逻辑内聚在一个类方便维护等，这些见仁见智，先不去说它们。</p>
<p>我们接着看第二个问题！！！</p>
<h3 id="为什么内部类（包括匿名内部类、局部内部类），会持有外部类的引用？"><a href="#为什么内部类（包括匿名内部类、局部内部类），会持有外部类的引用？" class="headerlink" title="为什么内部类（包括匿名内部类、局部内部类），会持有外部类的引用？"></a>为什么内部类（包括匿名内部类、局部内部类），会持有外部类的引用？</h3><p>问这个问题，显得我是个杠精，您先别着急，其实我想问的是，内部类Java是怎么实现的。 我们还是举例说明，先以普通的内部类为例</p>
<h3 id="普通内部类的实现"><a href="#普通内部类的实现" class="headerlink" title="普通内部类的实现"></a>普通内部类的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    // 普通内部类</span><br><span class="line">    public class DemoRunnable implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切到Demo.java所在文件夹，命令行执行 javac Demo.java，在Demo类同目录下可以看到生成了二个class文件</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/6/18/16b67c1a51958f99?imageView2/0/w/1280/h/960/ignore-error/1" alt="普通内部类生成class.png"></p>
<p>Demo.class很好理解，另一个 类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Demo$DemoRunnable.class</span><br></pre></td></tr></table></figure>

<p>就是我们的内部类编译出来的，它的命名也是有规律的，外部类名Demo+$+内部类名DemoRunnable。 查看反编译后的代码（IntelliJ IDEA本身就支持，直接查看class文件即可）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package inner;</span><br><span class="line"></span><br><span class="line">public class Demo$DemoRunnable implements Runnable &#123;</span><br><span class="line">    public Demo$DemoRunnable(Demo var1) &#123;</span><br><span class="line">        this.this$0 = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的类只有一个构造器，参数就是Demo类型，而且保存到内部类本身的this$0字段中。到这里我们其实已经可以想到，内部类持有的外部类引用就是通过这个构造器传递进来的，它是一个强引用。</p>
<h3 id="验证我们的想法"><a href="#验证我们的想法" class="headerlink" title="验证我们的想法"></a>验证我们的想法</h3><p>怎么验证呢？我们需要在Demo.class类中加一个方法，来实例化这个DemoRunnable内部类对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Demo.java</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        DemoRunnable demoRunnable = new DemoRunnable();</span><br><span class="line">        demoRunnable.run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再次执行 javac Demo.java，再执行javap -verbose Demo.class，查看Demo类的字节码，前方高能，需要一些字节码知识，这里我们重点关注run方法（插一句题外话，字节码简单的要能看懂，-。-）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void run();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=2, args_size=1</span><br><span class="line">         0: new           #2                  // class inner/Demo$DemoRunnable</span><br><span class="line">         3: dup</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: invokespecial #3                  // Method inner/Demo$DemoRunnable.&quot;&lt;init&gt;&quot;:(Linner/Demo;)V</span><br><span class="line">         8: astore_1</span><br><span class="line">         9: aload_1</span><br><span class="line">        10: invokevirtual #4                  // Method inner/Demo$DemoRunnable.run:()V</span><br><span class="line">        13: return</span><br></pre></td></tr></table></figure>

<pre><code>* **先通过new指令，新建了一个Demo$DemoRunnable对象**
* **aload_0指令将外部类Demo对象自身加载到栈帧中**
* **调用Demo$DemoRunnable类的init方法，注意这里将Demo对象作为了参数传递进来了**</code></pre><p>到这一步其实已经很清楚了，就是将外部类对象自身作为参数传递给了内部类构造器，与我们上面的猜想一致。</p>
<h3 id="匿名内部类的实现"><a href="#匿名内部类的实现" class="headerlink" title="匿名内部类的实现"></a>匿名内部类的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    // 匿名内部类</span><br><span class="line">    private Runnable runnable = new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样执行javac Demo.java，这次多生成了一个Demo$1.class，反编译查看代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package inner;</span><br><span class="line"></span><br><span class="line">class Demo$1 implements Runnable &#123;</span><br><span class="line">    Demo$1(Demo var1) &#123;</span><br><span class="line">        this.this$0 = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到匿名内部类和普通内部类实现基本一致，只是编译器自动给它拼了个名字，所以匿名内部类不能自定义构造器，因为名字编译完成后才能确定。 方法局部内部类，我这里就不赘述了，原理都是一样的，大家可以自行试验。 这样我们算是解答了第二个问题，来看第三个问题。</p>
<h3 id="为什么匿名内部类使用到外部类方法中的局部变量时需要是final类型的？"><a href="#为什么匿名内部类使用到外部类方法中的局部变量时需要是final类型的？" class="headerlink" title="为什么匿名内部类使用到外部类方法中的局部变量时需要是final类型的？"></a>为什么匿名内部类使用到外部类方法中的局部变量时需要是final类型的？</h3><p>这里先申明一下，这个问题本身是有问题的，问题在哪呢？因为java8中并不一定需要声明为final。我们来看个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Demo.java</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        int age = 10;</span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                int myAge = age + 1;</span><br><span class="line">                System.out.println(myAge);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>匿名内部类对象runnable，使用了外部类方法中的age局部变量。编译运行完全没问题，而age并没有final修饰啊！ 那我们再在run方法中，尝试修改age试试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">        int age = 10;</span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                int myAge = age + 1;</span><br><span class="line">                System.out.println(myAge);</span><br><span class="line">                age = 20;   // error</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译器报错了，提示信息是”age is access from inner class, need to be final or effectively final“。很显然编译器很智能，由于我们第一个例子并没有修改age的值，所以编译器认为这是effectively final，是安全的，可以编译通过，而第二个例子尝试修改age的值，编译器立马就报错了。</strong></p>
<h3 id="外部类变量是怎么传递给内部类的？"><a href="#外部类变量是怎么传递给内部类的？" class="headerlink" title="外部类变量是怎么传递给内部类的？"></a>外部类变量是怎么传递给内部类的？</h3><p>这里对于变量的类型分三种情况分别来说明</p>
<h3 id="非final局部变量"><a href="#非final局部变量" class="headerlink" title="非final局部变量"></a>非final局部变量</h3><p>我们去掉尝试修改age的代码，然后执行javac Demo.java，查看Demo$1.class的实现代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package inner;</span><br><span class="line"></span><br><span class="line">class Demo$1 implements Runnable &#123;</span><br><span class="line">    Demo$1(Demo var1, int var2) &#123;</span><br><span class="line">        this.this$0 = var1;</span><br><span class="line">        this.val$age = var2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        int var1 = this.val$age + 1;</span><br><span class="line">        System.out.println(var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到对于非final局部变量，是通过构造器的方式传递进来的。</p>
<h3 id="final局部变量"><a href="#final局部变量" class="headerlink" title="final局部变量"></a>final局部变量</h3><p>age修改为final</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">        final int age = 10;</span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                int myAge = age + 1;</span><br><span class="line">                System.out.println(myAge);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>同样执行javac Demo.java，查看Demo$1.class的实现代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Demo$1 implements Runnable &#123;</span><br><span class="line">    Demo$1(Demo var1) &#123;</span><br><span class="line">        this.this$0 = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        byte var1 = 11;</span><br><span class="line">        System.out.println(var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到编译器很聪明的做了优化，age是final的，所以在编译期间是确定的，直接将+1优化为11。 为了测试编译器的智商，我们把age的赋值修改一下，改为运行时才能确定的，看编译器如何应对</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">        final int age = (int) System.currentTimeMillis();</span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                int myAge = age + 1;</span><br><span class="line">                System.out.println(myAge);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再看Demo$1 字节码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Demo$1 implements Runnable &#123;</span><br><span class="line">    Demo$1(Demo var1, int var2) &#123;</span><br><span class="line">        this.this$0 = var1;</span><br><span class="line">        this.val$age = var2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        int var1 = this.val$age + 1;</span><br><span class="line">        System.out.println(var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译器意识到编译期age的值不能确定，所以还是采用构造器传参的形式实现。现代编译器还是很机智的。</strong></p>
<h3 id="外部类成员变量"><a href="#外部类成员变量" class="headerlink" title="外部类成员变量"></a>外部类成员变量</h3><p>将age改为Demo的成员变量，注意没有加任何修饰符，是包级访问级别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    int age = 10;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                int myAge = age + 1;</span><br><span class="line">                System.out.println(myAge);</span><br><span class="line">                age = 20;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>javac Demo.java，查看匿名内部内的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Demo$1 implements Runnable &#123;</span><br><span class="line">    Demo$1(Demo var1) &#123;</span><br><span class="line">        this.this$0 = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        int var1 = this.this$0.age + 1;</span><br><span class="line">        System.out.println(var1);</span><br><span class="line">        this.this$0.age = 20;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一次编译器直接通过外部类的引用操作age，没毛病，由于age是包访问级别，所以这样是最高效的。 如果将age改为private，编译器会在Demo类中生成二个方法，分别用于读取age和设置age，篇幅关系，这种情况留给大家自行测试。</p>
<h3 id="解答为何局部变量传递给匿名内部类需要是final"><a href="#解答为何局部变量传递给匿名内部类需要是final" class="headerlink" title="解答为何局部变量传递给匿名内部类需要是final?"></a>解答为何局部变量传递给匿名内部类需要是final?</h3><p><strong>通过上面的例子可以看到，不是一定需要局部变量是final的，但是你不能在匿名内部类中修改外部局部变量，因为Java对于匿名内部类传递变量的实现是基于构造器传参的，也就是说如果允许你在匿名内部类中修改值，你修改的是匿名内部类中的外部局部变量副本，最终并不会对外部类产生效果，因为已经是二个变量了。</strong> <strong>这样就会让程序员产生困扰，原以为修改会生效，事实上却并不会，所以Java就禁止在匿名内部类中修改外部局部变量。</strong></p>
<h3 id="如何创建内部类实例，如何继承内部类？"><a href="#如何创建内部类实例，如何继承内部类？" class="headerlink" title="如何创建内部类实例，如何继承内部类？"></a>如何创建内部类实例，如何继承内部类？</h3><p>由于内部类对象需要持有外部类对象的引用，所以必须得先有外部类对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Demo.DemoRunnable demoRunnable = new Demo().new DemoRunnable();</span><br></pre></td></tr></table></figure>

<p>那如何继承一个内部类呢，先给出示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 extends Demo.DemoRunnable &#123;</span><br><span class="line">        public Demo2(Demo demo) &#123;</span><br><span class="line">            demo.super();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>必须在构造器中传入一个Demo对象，并且还需要调用demo.super(); 看个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class DemoKata &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo2 demo2 = new DemoKata().new Demo2(new Demo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class Demo2 extends Demo.DemoRunnable &#123;</span><br><span class="line">        public Demo2(Demo demo) &#123;</span><br><span class="line">            demo.super();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Demo2也是一个内部类，所以需要先new一个DemoKata对象。 这一个问题描述的场景可能用的并不多，一般也不这么去用，这里提一下，大家知道有这么回事就行。</p>
<h3 id="Lambda表达式是如何实现的？"><a href="#Lambda表达式是如何实现的？" class="headerlink" title="Lambda表达式是如何实现的？"></a>Lambda表达式是如何实现的？</h3><p>Java8引入了Lambda表达式，一定程度上可以简化我们的代码，使代码结构看起来更优雅。做技术的还是要有刨根问底的那股劲，问问自己有没有想过Java中Lambda到底是如何实现的呢？</p>
<p>来看一个最简单的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    public void run(Runnable runnable) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Animal类中定义了一个run方法，参数是一个Runnable对象，Java8以前，我们可以传入一个匿名内部类对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">run(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Java 8 之后编译器已经很智能的提示我们可以用Lambda表达式来替换。既然可以替换，那匿名内部类和Lambda表达式是不是底层实现是一样的呢，或者说Lambda表达式只是匿名内部类的语法糖呢？ 要解答这个问题，我们还是要去字节码中找线索。通过前面的知识，我们知道javac Animal.java命令将类编译成class，匿名内部类的方式会产生一个额外的类。那用Lambda表达式会不会也会编译新类呢？我们试一下便知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void run(Runnable runnable) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test() &#123;</span><br><span class="line">        run(() -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>javac Animal.java，发现并没有生成额外的类！！！ 我们继续使用javap -verbose Animal.class来查看Animal.class的字节码实现，重点关注test方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokedynamic #2,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable;</span><br><span class="line">         6: invokevirtual #3                  // Method run:(Ljava/lang/Runnable;)V</span><br><span class="line">         9: return</span><br><span class="line"></span><br><span class="line">SourceFile: &quot;Demo.java&quot;</span><br><span class="line">InnerClasses:</span><br><span class="line">     public static final #34= #33 of #37; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</span><br><span class="line">BootstrapMethods:</span><br><span class="line">  0: #18 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">    Method arguments:</span><br><span class="line">      #19 ()V</span><br><span class="line">      #20 invokestatic com/company/inner/Demo.lambda$test$0:()V</span><br><span class="line">      #19 ()V</span><br></pre></td></tr></table></figure>

<p>发现test方法字节码中多了一个invokedynamic /#2 0指令，这是java7引入的新指令，其中/#2 指向</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#2 = InvokeDynamic      #0:#21         // #0:run:()Ljava/lang/Runnable;</span><br></pre></td></tr></table></figure>

<p>而0代表BootstrapMethods方法表中的第一个，java/lang/invoke/LambdaMetafactory.metafactory方法被调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BootstrapMethods:</span><br><span class="line">  0: #18 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">    Method arguments:</span><br><span class="line">      #19 ()V</span><br><span class="line">      #20 invokestatic com/company/inner/Demo.lambda$test$0:()V</span><br><span class="line">      #19 ()V</span><br></pre></td></tr></table></figure>

<p>这里面我们看到了com/company/inner/Demo.lambda$test$0这么个东西，看起来跟我们的匿名内部类的名称有些类似，而且中间还有lambda，有可能就是我们要找的生成的类。 我们不妨验证下我们的想法，可以通过下面的代码打印出Lambda对象的真实类名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void run(Runnable runnable) &#123;</span><br><span class="line">        System.out.println(runnable.getClass().getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test() &#123;</span><br><span class="line">        run(() -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>打印出runnable的类名，结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.company.inner.Demo$$Lambda$1/764977973</span><br></pre></td></tr></table></figure>

<p>跟我们上面的猜测并不完全一致，我们继续找别的线索，既然我们有看到LambdaMetafactory.metafactory这个类被调用，不妨继续跟进看下它的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static CallSite metafactory(MethodHandles.Lookup caller,</span><br><span class="line">                                       String invokedName,</span><br><span class="line">                                       MethodType invokedType,</span><br><span class="line">                                       MethodType samMethodType,</span><br><span class="line">                                       MethodHandle implMethod,</span><br><span class="line">                                       MethodType instantiatedMethodType)</span><br><span class="line">            throws LambdaConversionException &#123;</span><br><span class="line">        AbstractValidatingLambdaMetafactory mf;</span><br><span class="line">        mf = new InnerClassLambdaMetafactory(caller, invokedType,</span><br><span class="line">                                             invokedName, samMethodType,</span><br><span class="line">                                             implMethod, instantiatedMethodType,</span><br><span class="line">                                             false, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);</span><br><span class="line">        mf.validateMetafactoryArgs();</span><br><span class="line">        return mf.buildCallSite();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>内部new了一个InnerClassLambdaMetafactory对象。看名字很可疑，继续跟进</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public InnerClassLambdaMetafactory(...)</span><br><span class="line">            throws LambdaConversionException &#123;</span><br><span class="line">        //....</span><br><span class="line">        lambdaClassName = targetClass.getName().replace(&apos;.&apos;, &apos;/&apos;) + &quot;$$Lambda$&quot; + counter.incrementAndGet();</span><br><span class="line">        cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);</span><br><span class="line">       //....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>省略了很多代码，我们重点看lambdaClassName这个字符串（通过名字就知道是干啥的），可以看到它的拼接结果跟我们上面打印的Lambda类名基本一致。而下面的ClassWriter也暴露了，其实Lambda运用的是Asm字节码技术，在运行时生成类文件。我感觉到这里就差不多了，再往下可能就有点太过细节了。-。-</p>
<h3 id="Lambda实现总结"><a href="#Lambda实现总结" class="headerlink" title="Lambda实现总结"></a>Lambda实现总结</h3><p>所以Lambda表达式并不是匿名内部类的语法糖，它是基于invokedynamic指令，在运行时使用ASM生成类文件来实现的。</p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>这可能是我迄今写的最长的一篇技术文章了，写的过程中也在不断的加深自己对知识点的理解，颠覆了很多以往的错误认知。写技术文章这条路我会一直坚持下去。 非常喜欢得到里面的一句slogan，胡适先生说的话。 <strong>怕什么真理无穷，进一寸有一寸的欢喜</strong> 共勉!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/06/18/死磕Java内部类（一篇就够）/" data-id="cjyza2xyl002zaf2a167513a4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-面试那点小事，你从未见过的springboot面试集锦（附详细答案）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/06/面试那点小事，你从未见过的springboot面试集锦（附详细答案）/" class="article-date">
  <time datetime="2019-06-06T07:39:01.001Z" itemprop="datePublished">2019-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/06/面试那点小事，你从未见过的springboot面试集锦（附详细答案）/">面试那点小事，你从未见过的spring boot面试集锦（附详细答案）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5cf7827d6fb9a07efc4977c9" target="_blank" rel="noopener">https://juejin.im/post/5cf7827d6fb9a07efc4977c9</a> </p>
</blockquote>
<h3 id="一，-什么是spring-boot？"><a href="#一，-什么是spring-boot？" class="headerlink" title="一， 什么是spring boot？"></a>一， 什么是spring boot？</h3><p>多年来，随着新功能的增加，spring变得越来越复杂。只需访问页面<a href="https://spring.io/projects，我们将看到所有在应用程序中使用的不同功能的spring项目。如果必须启动一个新的spring项目，我们必须添加构建路径或maven依赖项，配置application" target="_blank" rel="noopener">https://spring.io/projects，我们将看到所有在应用程序中使用的不同功能的spring项目。如果必须启动一个新的spring项目，我们必须添加构建路径或maven依赖项，配置application</a> server，添加spring配置。因此，启动一个新的spring项目需要大量的工作，因为我们目前必须从头开始做所有事情。Spring Boot是这个问题的解决方案。Spring boot构建在现有Spring框架之上。使用spring boot，我们可以避免以前必须执行的所有样板代码和配置。因此，Spring boot帮助我们更健壮地使用现有的Spring功能，并且只需最少的工作量。</p>
<h3 id="二，Spring-Boot的优点是什么"><a href="#二，Spring-Boot的优点是什么" class="headerlink" title="二，Spring Boot的优点是什么?"></a>二，Spring Boot的优点是什么?</h3><pre><code>* 减少开发、测试的时间和工作量。
* 使用JavaConfig有助于避免使用XML。
* 避免大量maven导入和各种版本冲突。
* 提供可选的开发方法。
* 通过提供默认开发方式进行快速开发。
* 不需要单独的Web服务器。这意味着您不再需要启动Tomcat、Glassfish或其他任何东西。</code></pre><p>由于没有web.xml文件，所以需要更少的配置。只需添加带@ configuration注释的类，然后可以添加带@ bean注释的方法，Spring将自动加载对象并像往常一样管理它。您甚至可以将@Autowired添加到bean方法中，使Spring autowire成为bean所需的依赖项。</p>
<p>基于环境的配置——使用这些属性，您可以将其传递到您正在使用的应用程序环境中:- dspring .profile .active={enviorement}。在加载主应用程序属性文件之后，Spring将在(application-{environment}.properties)处加载后续的应用程序属性文件。</p>
<h3 id="三，您使用过哪些构建工具来开发Spring引导应用程序"><a href="#三，您使用过哪些构建工具来开发Spring引导应用程序" class="headerlink" title="三，您使用过哪些构建工具来开发Spring引导应用程序?"></a>三，您使用过哪些构建工具来开发Spring引导应用程序?</h3><p>Spring Boot应用程序可以使用Maven和Gradle开发。</p>
<h3 id="四，什么是JavaConfig"><a href="#四，什么是JavaConfig" class="headerlink" title="四，什么是JavaConfig?"></a>四，什么是JavaConfig?</h3><p>Spring JavaConfig是Spring社区的一个产品，它提供了一种纯java方法来配置Spring IoC容器。因此，它有助于避免使用XML配置。使用JavaConfig的优点是：<br>    * 面向对象的配置。因为配置在JavaConfig中定义为类，所以用户可以充分利用Java中的面向对象特性。一个配置类可以子类化另一个配置类，覆盖它的@Bean方法，等等。<br>    * 减少或消除XML配置。已经证明了基于依赖注入原则的外部化配置的好处。然而，许多开发人员不愿意在XML和Java之间来回切换。JavaConfig为开发人员提供了一种纯java方法来配置Spring容器，这种方法在概念上类似于XML配置。从技术上讲，仅使用   JavaConfig配置类来配置容器是可行的，但是在实践中，许多人发现将JavaConfig与XML混合并匹配是理想的。<br>    * 类型安全的重构能力。JavaConfig提供了一种类型安全的配置Spring容器的方法。由于Java 5.0对泛型的支持，现在可以通过类型而不是名称检索bean，不需要进行任何基于类型转换或字符串的查找。</p>
<h3 id="五，如何在不重启服务器的情况下在Spring引导时重新加载我的更改"><a href="#五，如何在不重启服务器的情况下在Spring引导时重新加载我的更改" class="headerlink" title="五，如何在不重启服务器的情况下在Spring引导时重新加载我的更改?"></a>五，如何在不重启服务器的情况下在Spring引导时重新加载我的更改?</h3><p>这可以通过开发工具来实现。有了这个依赖项，您保存的任何更改都将重新启动嵌入的tomcat。Spring Boot有一个开发人员工具(DevTools)模块，它有助于提高开发人员的工作效率。Java开发人员面临的关键挑战之一是将文件更改自动部署到服务器并自动重启服务器。开发人员可以在Spring引导时重新加载更改，而不必重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot在发布第一个版本时没有这个特性。这是开发人员最需要的特性。DevTools模块完全满足开发人员的需求。此模块将在生产环境中禁用。它还提供了H2-database控制台，以便更好地测试应用程序。使用以下依赖项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>下面的<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2FSpringBootUsingPagination" target="_blank" rel="noopener">示例</a>演示了自动启动和H2 DB控制台的DevTool依赖项用法</p>
<h3 id="六，什么是Spring-boot-actuator"><a href="#六，什么是Spring-boot-actuator" class="headerlink" title="六，什么是Spring boot actuator?"></a>六，什么是Spring boot actuator?</h3><p>Spring boot actuator是Spring boot framework的重要特性之一。Spring boot actuator帮助您访问生产环境中正在运行的应用程序的当前状态，在生产环境中必须检查和监视几个指标。甚至一些外部应用程序也可能使用这些服务来触发对相关人员的警报消息。actuator模块公开一组REST端点，这些端点可以作为HTTP URL直接访问，以检查状态。</p>
<h3 id="七，如何将Spring-Boot应用程序作为war包部署"><a href="#七，如何将Spring-Boot应用程序作为war包部署" class="headerlink" title="七，如何将Spring Boot应用程序作为war包部署?"></a>七，如何将Spring Boot应用程序作为war包部署?</h3><p>Spring Boot WAR部署</p>
<h3 id="八，什么是Docker吗-如何将Spring引导应用程序部署到Docker"><a href="#八，什么是Docker吗-如何将Spring引导应用程序部署到Docker" class="headerlink" title="八，什么是Docker吗?如何将Spring引导应用程序部署到Docker?"></a>八，什么是Docker吗?如何将Spring引导应用程序部署到Docker?</h3><p>Docker是什么 将基于Spring的WAR应用程序部署到Docker 将基于Spring的JAR应用程序部署到Docker</p>
<h3 id="九，如何禁用执行器端点安全在Spring启动"><a href="#九，如何禁用执行器端点安全在Spring启动" class="headerlink" title="九，如何禁用执行器端点安全在Spring启动?"></a>九，如何禁用执行器端点安全在Spring启动?</h3><p>默认情况下，所有敏感的HTTP端点都是安全的，只有具有ACTUATOR角色的用户才能访问它们。安全性是使用标准HttpServletRequest.isUserInRole方法实现的。 我们可以使用-禁用安全性 management.security.enabled = false 建议仅当在防火墙后访问ACTUATOR端点时禁用安全性。</p>
<h3 id="十，如何将Spring引导应用程序运行到自定义端口"><a href="#十，如何将Spring引导应用程序运行到自定义端口" class="headerlink" title="十，如何将Spring引导应用程序运行到自定义端口?"></a>十，如何将Spring引导应用程序运行到自定义端口?</h3><p>要在自定义端口上运行spring引导应用程序，可以在application.properties中指定端口。 server.port = 8090</p>
<h3 id="十一，什么是ELK堆栈-如何与Spring-Boot一起使用"><a href="#十一，什么是ELK堆栈-如何与Spring-Boot一起使用" class="headerlink" title="十一，什么是ELK堆栈?如何与Spring Boot一起使用?"></a>十一，什么是ELK堆栈?如何与Spring Boot一起使用?</h3><p>ELK堆栈由三个开源产品组成——Elasticsearch、Logstash和Kibana from Elastic。<br><img src="https://user-gold-cdn.xitu.io/2019/6/5/16b26d5b5d3af6a1?imageView2/0/w/1280/h/960/ignore-error/1" alt> Elasticsearch是一个基于Lucene搜索引擎的NoSQL数据库。     Logstash是一个日志管道工具，它接受来自不同来源的输入，执行不同的转换，并将数据导出到不同的目标。它是一个动态的数据收集管道，具有可扩展的插件生态系统和强大的弹性搜索协同作用     Kibana是一个可视化UI层，工作在Elasticsearch之上。 这三个项目一起用于各种环境中的日志分析。因此Logstash收集和解析日志、弹性搜索索引并存储这些信息，而Kibana提供了一个UI层，提供可操作的可见性。</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspringboot-microservice-elk" target="_blank" rel="noopener">Spring Boot + ELK stack</a></p>
<h3 id="十二，您有使用Spring-Boot编写测试用例吗"><a href="#十二，您有使用Spring-Boot编写测试用例吗" class="headerlink" title="十二，您有使用Spring Boot编写测试用例吗?"></a>十二，您有使用Spring Boot编写测试用例吗?</h3><p>SpringBoot为编写单元测试用例提供了@SpringBootTest</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspringboot_testcases" target="_blank" rel="noopener">Spring引导单元测试的简单示例</a></p>
<h3 id="十三，YAML是什么"><a href="#十三，YAML是什么" class="headerlink" title="十三，YAML是什么?"></a>十三，YAML是什么?</h3><p>YAML是一种人类可读的数据序列化语言。它通常用于配置文件。 与属性文件相比，YAML文件的结构更加结构化，如果我们希望在配置文件中添加复杂的属性，那么它不会造成太大的混乱。可以看到，YAML具有分层的配置数据。</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fbootyaml" target="_blank" rel="noopener">在Spring引导中使用YAML属性</a></p>
<h3 id="十四，如何为Spring引导应用程序实现安全性"><a href="#十四，如何为Spring引导应用程序实现安全性" class="headerlink" title="十四，如何为Spring引导应用程序实现安全性?"></a>十四，如何为Spring引导应用程序实现安全性?</h3><p>为了实现Spring Boot的安全性，我们使用Spring - Boot -starter-security依赖项，必须添加安全配置。它只需要很少的代码。Config类必须扩展WebSecurityConfigurerAdapter并覆盖它的方法。</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fsprboot_sec" target="_blank" rel="noopener">Spring引导安全性示例和说明</a></p>
<h3 id="十五，您是否集成了Spring-Boot和ActiveMQ"><a href="#十五，您是否集成了Spring-Boot和ActiveMQ" class="headerlink" title="十五，您是否集成了Spring Boot和ActiveMQ ?"></a>十五，您是否集成了Spring Boot和ActiveMQ ?</h3><p>为了集成Spring Boot和ActiveMQ，我们使用Spring - Boot -starter- ActiveMQ依赖项，它只需要很少的配置，没有样板代码。</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fsprboot_activemq" target="_blank" rel="noopener">Spring引导ActiveMQ说明</a></p>
<h3 id="十六，您是否集成了Spring-Boot和Apache-Kafka"><a href="#十六，您是否集成了Spring-Boot和Apache-Kafka" class="headerlink" title="十六，您是否集成了Spring Boot和Apache Kafka ?"></a>十六，您是否集成了Spring Boot和Apache Kafka ?</h3><p>为了集成Spring Boot和Apache Kafka，我们使用Spring - Kafka依赖项。</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspring-boot-apache-kafka-hello-world" target="_blank" rel="noopener">Spring Boot + Apache Kafka示例</a></p>
<h3 id="十七，如何使用Spring引导实现分页和排序"><a href="#十七，如何使用Spring引导实现分页和排序" class="headerlink" title="十七，如何使用Spring引导实现分页和排序?"></a>十七，如何使用Spring引导实现分页和排序?</h3><p>使用Spring Boot实现分页非常简单。使用Spring Data-JPA，这是通过传递可分页的org.springframe .data.domain来实现的。可分页到存储库方法。</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2FSpringBootInterviewQuestions" target="_blank" rel="noopener">Spring引导分页说明</a></p>
<h3 id="十八，什么是Swagger-您是否使用Spring-Boot实现了它"><a href="#十八，什么是Swagger-您是否使用Spring-Boot实现了它" class="headerlink" title="十八，什么是Swagger?您是否使用Spring Boot实现了它?"></a>十八，什么是Swagger?您是否使用Spring Boot实现了它?</h3><p>Swagger被广泛用于可视化api，Swagger UI为前端开发人员提供在线沙箱环境。在本教程中，我们将使用Swagger 2规范的Springfox实现。Swagger是一种工具、规范和完整的框架实现，用于生成RESTful Web服务的可视化表示。它允许文档以与服务器相同的速度更新。当通过Swagger正确定义时，使用者可以用最少的实现逻辑理解远程服务并与之交互。因此Swagger消除了调用服务时的猜测。</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fboot_swagger" target="_blank" rel="noopener">Spring Boot + Swagger2</a></p>
<h3 id="十九，什么是Spring-Profiles-如何使用Spring-Boot实现它"><a href="#十九，什么是Spring-Profiles-如何使用Spring-Boot实现它" class="headerlink" title="十九，什么是Spring Profiles?如何使用Spring Boot实现它?"></a>十九，什么是Spring Profiles?如何使用Spring Boot实现它?</h3><p>Spring Profiles允许用户根据配置文件(dev, test, prod等)注册bean。因此，当应用程序在开发中运行时，只能加载某些bean，当应用程序在生产中运行时，只能加载某些其他bean。假设我们的需求是Swagger文档只对QA环境启用，对所有其他环境禁用。这可以使用配置文件来完成。Spring Boot使得使用配置文件非常容易。</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fboot_swagger_profile" target="_blank" rel="noopener">Spring引导+配置文件</a></p>
<h3 id="二十，什么是Spring-Boot-Batch-如何使用Spring-Boot实现它"><a href="#二十，什么是Spring-Boot-Batch-如何使用Spring-Boot实现它" class="headerlink" title="二十，什么是Spring Boot Batch?如何使用Spring Boot实现它?"></a>二十，什么是Spring Boot Batch?如何使用Spring Boot实现它?</h3><p>Spring Boot Batch提供了处理大量记录所必需的可重用功能，包括日志/跟踪、事务管理、作业处理统计信息、作业重启、作业跳过和资源管理。它还提供了更高级的技术服务和特性，通过优化和分区技术，这些特性将支持极高容量和高性能的批处理作业。无论是简单的还是复杂的，大容量批处理作业都可以以高度可伸缩的方式利用该框架来处理大量信息。</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fbootbatch" target="_blank" rel="noopener">Spring Boot Batch</a></p>
<h3 id="二十一，什么是FreeMarker模板-如何使用Spring-Boot实现它"><a href="#二十一，什么是FreeMarker模板-如何使用Spring-Boot实现它" class="headerlink" title="二十一，什么是FreeMarker模板?如何使用Spring Boot实现它?"></a>二十一，什么是FreeMarker模板?如何使用Spring Boot实现它?</h3><p>答:FreeMarker是一个基于java的模板引擎，最初专注于使用MVC软件架构生成动态web页面。使用Freemarker的主要优势是完全分离了表示层和业务层。程序员可以处理应用程序代码，而设计人员可以处理html页面设计。最后，使用freemarker，这些可以组合在一起，给出最终的输出页面。</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspring-boot-freemarker-hello-world" target="_blank" rel="noopener">Spring Boot + FreeMarker的例子</a></p>
<h3 id="二十二，如何使用Spring-Boot实现异常处理"><a href="#二十二，如何使用Spring-Boot实现异常处理" class="headerlink" title="二十二，如何使用Spring Boot实现异常处理?"></a>二十二，如何使用Spring Boot实现异常处理?</h3><p>Spring提供了一种非常有用的方法，可以使用ControllerAdvice处理异常。我们将实现一个ControlerAdvice类，它将处理控制器类抛出的所有异常。</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fboot-exception-handling" target="_blank" rel="noopener">Spring引导异常处理</a></p>
<h3 id="二十三，什么是缓存-您在Spring引导中使用过缓存框架吗"><a href="#二十三，什么是缓存-您在Spring引导中使用过缓存框架吗" class="headerlink" title="二十三，什么是缓存?您在Spring引导中使用过缓存框架吗?"></a>二十三，什么是缓存?您在Spring引导中使用过缓存框架吗?</h3><p>缓存是本地内存的一个区域，它保存了频繁访问的数据的副本，否则获取或计算这些数据将非常昂贵。使用Hazelcast进行缓存。</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspring-boot-hazelcast" target="_blank" rel="noopener">Spring Boot + Hazelcast示例</a></p>
<h3 id="二十四您是否使用Spring-Boot公开了SOAP-web服务端点"><a href="#二十四您是否使用Spring-Boot公开了SOAP-web服务端点" class="headerlink" title="二十四您是否使用Spring Boot公开了SOAP web服务端点?"></a>二十四您是否使用Spring Boot公开了SOAP web服务端点?</h3><p>是的。使用Spring Boot公开了要使用的web服务。使用契约优先的方法从wsdl生成类。</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspringbootsoapwebservice" target="_blank" rel="noopener">Spring引导+ SOAP Web服务示例</a></p>
<h3 id="二十五，您如何使用Spring-Boot执行数据库操作"><a href="#二十五，您如何使用Spring-Boot执行数据库操作" class="headerlink" title="二十五，您如何使用Spring Boot执行数据库操作?"></a>二十五，您如何使用Spring Boot执行数据库操作?</h3><p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2FSpringBoot_DataJPA" target="_blank" rel="noopener">Spring引导教程-Spring Data JPA</a></p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fbootjdbc" target="_blank" rel="noopener">Spring引导JDBC示例</a></p>
<h3 id="二十六，如何使用Spring上传文件"><a href="#二十六，如何使用Spring上传文件" class="headerlink" title="二十六，如何使用Spring上传文件?"></a>二十六，如何使用Spring上传文件?</h3><p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fbootupload" target="_blank" rel="noopener">Spring Boot +文件上传的例子</a></p>
<h3 id="二十七，如何用Spring-Boot实现拦截器"><a href="#二十七，如何用Spring-Boot实现拦截器" class="headerlink" title="二十七，如何用Spring Boot实现拦截器?"></a>二十七，如何用Spring Boot实现拦截器?</h3><p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2FbootInterceptor" target="_blank" rel="noopener">使用Spring MVC HandlerInterceptor与Spring引导</a></p>
<h3 id="二十八，如何在Spring-Boot下使用schedulers"><a href="#二十八，如何在Spring-Boot下使用schedulers" class="headerlink" title="二十八，如何在Spring Boot下使用schedulers ?"></a>二十八，如何在Spring Boot下使用schedulers ?</h3><p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2FbootTask" target="_blank" rel="noopener">Spring引导任务调度程序示例</a></p>
<h3 id="二十九，您使用过哪些启动器maven依赖项"><a href="#二十九，您使用过哪些启动器maven依赖项" class="headerlink" title="二十九，您使用过哪些启动器maven依赖项?"></a>二十九，您使用过哪些启动器maven依赖项?</h3><p>使用过不同的starter依赖项，如spring-boot-starter-activemq依赖项、spring-boot-starter-security依赖项、spring-boot-starter-web依赖项。 这有助于减少依赖项的数量，并减少版本组合。</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fsprboot_sec" target="_blank" rel="noopener">Spring引导安全性示例和说明</a></p>
<h3 id="三十，什么是CSRF攻击-如何启用CSRF对其进行保护"><a href="#三十，什么是CSRF攻击-如何启用CSRF对其进行保护" class="headerlink" title="三十，什么是CSRF攻击?如何启用CSRF对其进行保护?"></a>三十，什么是CSRF攻击?如何启用CSRF对其进行保护?</h3><p>CSRF代表跨站请求伪造。它是一种攻击，迫使最终用户在其当前已经过身份验证的web应用程序上执行不需要的操作。CSRF攻击专门针对状态更改请求，而不是数据窃取，因为攻击者无法看到对伪造请求的响应。</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fboot_security_csrf" target="_blank" rel="noopener">Spring引导安全性—启用CSRF保护</a></p>
<h3 id="三十一，如何使用Spring引导使用表单登录身份验证"><a href="#三十一，如何使用Spring引导使用表单登录身份验证" class="headerlink" title="三十一，如何使用Spring引导使用表单登录身份验证?"></a>三十一，如何使用Spring引导使用表单登录身份验证?</h3><p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fboot_form_security" target="_blank" rel="noopener">Spring引导表单安全登录Hello World示例</a></p>
<h3 id="三十二，什么是OAuth2-如何使用Spring-Boot实现它"><a href="#三十二，什么是OAuth2-如何使用Spring-Boot实现它" class="headerlink" title="三十二，什么是OAuth2?如何使用Spring Boot实现它?"></a>三十二，什么是OAuth2?如何使用Spring Boot实现它?</h3><p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspring-boot-oauth-introduction" target="_blank" rel="noopener">Spring Boot + OAuth2实现</a></p>
<h3 id="三十三，GZIP是什么-如何使用Spring-Boot实现它"><a href="#三十三，GZIP是什么-如何使用Spring-Boot实现它" class="headerlink" title="三十三，GZIP是什么?如何使用Spring Boot实现它?"></a>三十三，GZIP是什么?如何使用Spring Boot实现它?</h3><p>gzip是一种文件格式，是一种用于文件压缩和解压缩的软件应用程序。</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fboot-zip" target="_blank" rel="noopener">Spring引导+ GZIP压缩</a></p>
<h3 id="三十四，您在Spring引导中使用过集成框架吗"><a href="#三十四，您在Spring引导中使用过集成框架吗" class="headerlink" title="三十四，您在Spring引导中使用过集成框架吗?"></a>三十四，您在Spring引导中使用过集成框架吗?</h3><p>已将Apache Camel与Spring引导集成。使用Apache Camel Spring启动启动依赖项。</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fbootcamel" target="_blank" rel="noopener">Spring Boot +Apache Camel</a></p>
<h3 id="三十五，什么是Apache-Freemarker-什么时候使用它而不是JSP-如何与Spring-Boot集成"><a href="#三十五，什么是Apache-Freemarker-什么时候使用它而不是JSP-如何与Spring-Boot集成" class="headerlink" title="三十五，什么是Apache Freemarker?什么时候使用它而不是JSP?如何与Spring Boot集成?"></a>三十五，什么是Apache Freemarker?什么时候使用它而不是JSP?如何与Spring Boot集成?</h3><p>JSP是为网页量身定做的，Freemarker模板是一种更通用的模板语言——它可以用来生成html、纯文本、电子邮件等。</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspring-boot-freemarker-hello-world" target="_blank" rel="noopener">Spring Boot + FreeMarker的例子</a></p>
<h3 id="三十六，你什么时候使用WebSockets-如何使用Spring-Boot实现它"><a href="#三十六，你什么时候使用WebSockets-如何使用Spring-Boot实现它" class="headerlink" title="三十六，你什么时候使用WebSockets?如何使用Spring Boot实现它?"></a>三十六，你什么时候使用WebSockets?如何使用Spring Boot实现它?</h3><p>WebSocket是一种计算机通信协议，通过单个TCP连接提供全双工通信通道。<br><img src="https://user-gold-cdn.xitu.io/2019/6/5/16b26d5b5d292438?imageView2/0/w/1280/h/960/ignore-error/1" alt> WebSocket是双向的——使用WebSocket客户端或服务器都可以发起发送消息。 WebSocket是全双工的——客户端和服务器之间的通信是相互独立的。 单个TCP连接——初始连接使用HTTP，然后将此连接升级为基于套接字的连接。然后，这个单一连接将用于未来的所有通信 轻- WebSocket消息数据交换比http轻得多。 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fboot-websocket" target="_blank" rel="noopener">Spring Boot + WebSockets的例子</a></p>
<h3 id="三十七，什么是AOP-如何与Spring-Boot一起使用"><a href="#三十七，什么是AOP-如何与Spring-Boot一起使用" class="headerlink" title="三十七，什么是AOP?如何与Spring Boot一起使用?"></a>三十七，什么是AOP?如何与Spring Boot一起使用?</h3><p>在软件开发过程中，跨越应用程序多个点的功能称为横切关注点。这些横切关注点不同于应用程序的主要业务逻辑。因此，将这些横切关注点从业务逻辑中分离出来是面向方面编程(AOP)的切入点。</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspring-boot-aop" target="_blank" rel="noopener">Spring Boot + AOP示例</a></p>
<h3 id="三十八，什么是Apache-Kafka-如何与Spring-Boot集成"><a href="#三十八，什么是Apache-Kafka-如何与Spring-Boot集成" class="headerlink" title="三十八，什么是Apache Kafka?如何与Spring Boot集成?"></a>三十八，什么是Apache Kafka?如何与Spring Boot集成?</h3><p>apache Kafka是一个分布式发布-订阅消息传递系统。它是一个可伸缩的、容错的、发布-订阅消息传递系统，使我们能够构建分布式应用程序。这是一个Apache顶级项目。Kafka适用于离线和在线的消息消费。</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspring-boot-apache-kafka-hello-world" target="_blank" rel="noopener">Spring Boot + Apache Kafka示例</a></p>
<h3 id="三十九，我们如何监视所有Spring-Boot微服务"><a href="#三十九，我们如何监视所有Spring-Boot微服务" class="headerlink" title="三十九，我们如何监视所有Spring Boot微服务?"></a>三十九，我们如何监视所有Spring Boot微服务?</h3><p>Spring Boot提供了actuator 端点来监控单个微服务的指标。这些端点对于获取关于应用程序的信息非常有帮助，比如应用程序是否启动，它们的组件(如数据库等)是否正常工作。但是，使用actuator 接口的一个主要缺点或困难是，我们必须逐个命中这些接口，以了解应用程序的状态或健康状况。假设微服务涉及50个应用程序，管理员将不得不命中所有50个应用程序的actuator 端点。为了帮助我们处理这种情况，我们将使用位于<a href="https://github.com/codecentric/springing-boot-admin的开源项目。" target="_blank" rel="noopener">https://github.com/codecentric/springing-boot-admin的开源项目。</a> 它构建在Spring Boot Actuator之上，提供了一个web UI，使我们能够可视化多个应用程序的指标。</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fboot-admin" target="_blank" rel="noopener">Spring Boot Admin</a></p>
<h3 id="四十，您在Spring引导中使用过Spring-Cloud组件吗"><a href="#四十，您在Spring引导中使用过Spring-Cloud组件吗" class="headerlink" title="四十，您在Spring引导中使用过Spring Cloud组件吗?"></a>四十，您在Spring引导中使用过Spring Cloud组件吗?</h3><p>使用过Netflix Eureka等Spring Cloud组件进行服务注册，Ribbon用于负载平衡。 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspringcloud" target="_blank" rel="noopener">Spring Boot + Cloud Components</a> <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fspring%2Fspring-cloud-interview-questions" target="_blank" rel="noopener">Spring Cloud interview Questions</a></p>
<h3 id="四十一，如何将Spring-Boot应用程序部署到Pivotal-Cloud-Foundry-PCF"><a href="#四十一，如何将Spring-Boot应用程序部署到Pivotal-Cloud-Foundry-PCF" class="headerlink" title="四十一，如何将Spring Boot应用程序部署到Pivotal Cloud Foundry(PCF)?"></a>四十一，如何将Spring Boot应用程序部署到Pivotal Cloud Foundry(PCF)?</h3><p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fpcf%2Fpcf-hello" target="_blank" rel="noopener">Deploying Spring Boot Application to PCF</a></p>
<h3 id="四十二，如何将Spring-Boot-MySQL应用部署到Pivotal-Cloud-Foundry-PCF"><a href="#四十二，如何将Spring-Boot-MySQL应用部署到Pivotal-Cloud-Foundry-PCF" class="headerlink" title="四十二，如何将Spring Boot + MySQL应用部署到Pivotal Cloud Foundry(PCF)?"></a>四十二，如何将Spring Boot + MySQL应用部署到Pivotal Cloud Foundry(PCF)?</h3><p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fpcf%2Fpcf-sql" target="_blank" rel="noopener">Pivotal Cloud Foundry Tutorial - Deploying Spring Boot + MySQL Application to PCF</a></p>
<h3 id="四十三，如何将Spring-Boot-RabbitMQ应用部署到Pivotal-Cloud-Foundry-PCF"><a href="#四十三，如何将Spring-Boot-RabbitMQ应用部署到Pivotal-Cloud-Foundry-PCF" class="headerlink" title="四十三，如何将Spring Boot + RabbitMQ应用部署到Pivotal Cloud Foundry(PCF)?"></a>四十三，如何将Spring Boot + RabbitMQ应用部署到Pivotal Cloud Foundry(PCF)?</h3><p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.javainuse.com%2Fpcf%2Fpcf-rabbitmq" target="_blank" rel="noopener">Pivotal Cloud Foundry Tutorial - Deploying Spring Boot + RabbitMQ Application to PCF</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/06/06/面试那点小事，你从未见过的springboot面试集锦（附详细答案）/" data-id="cjyza2xym0030af2aqlxkqytj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SpringBoot实现动态控制定时任务-支持多参数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/01/SpringBoot实现动态控制定时任务-支持多参数/" class="article-date">
  <time datetime="2019-06-01T15:51:17.017Z" itemprop="datePublished">2019-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/01/SpringBoot实现动态控制定时任务-支持多参数/">SpringBoot实现动态控制定时任务-支持多参数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5cf099556fb9a07ef2010716" target="_blank" rel="noopener">https://juejin.im/post/5cf099556fb9a07ef2010716</a><br>由于工作上的原因，需要进行定时任务的动态增删改查，网上大部分资料都是整合quertz框架实现的。本人查阅了一些资料，发现springBoot本身就支持实现定时任务的动态控制。并进行改进，现支持任意多参数定时任务配置</p>
</blockquote>
<p>实现结果如下图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/31/16b0be286b6a031a?imageView2/0/w/1280/h/960/ignore-error/1" alt> 后台测试显示如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/31/16b0bf1a0e118b4b?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>github 简单demo地址如下： <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fcaotinging%2Fsimple-demo%2Ftree%2Fmaster%2Fspringboot-dynamic-task" target="_blank" rel="noopener">springboot-dynamic-task</a></p>
<h3 id="1-定时任务的配置类：SchedulingConfig"><a href="#1-定时任务的配置类：SchedulingConfig" class="headerlink" title="1.定时任务的配置类：SchedulingConfig"></a>1.定时任务的配置类：SchedulingConfig</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.scheduling.TaskScheduler;</span><br><span class="line">import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @program: simple-demo</span><br><span class="line"> * @description: 定时任务配置类</span><br><span class="line"> * @author: CaoTing</span><br><span class="line"> * @date: 2019/5/23</span><br><span class="line"> **/</span><br><span class="line">@Configuration</span><br><span class="line">public class SchedulingConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public TaskScheduler taskScheduler() &#123;</span><br><span class="line">        ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();</span><br><span class="line">        // 定时任务执行线程池核心线程数</span><br><span class="line">        taskScheduler.setPoolSize(4);</span><br><span class="line">        taskScheduler.setRemoveOnCancelPolicy(true);</span><br><span class="line">        taskScheduler.setThreadNamePrefix(&quot;TaskSchedulerThreadPool-&quot;);</span><br><span class="line">        return taskScheduler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-定时任务注册类：CronTaskRegistrar"><a href="#2-定时任务注册类：CronTaskRegistrar" class="headerlink" title="2.定时任务注册类：CronTaskRegistrar"></a>2.定时任务注册类：CronTaskRegistrar</h3><p>这个类包含了新增定时任务，移除定时任务等等核心功能方法<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">import com.caotinging.demo.task.ScheduledTask;</span><br><span class="line">import org.springframework.beans.factory.DisposableBean;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.scheduling.TaskScheduler;</span><br><span class="line">import org.springframework.scheduling.config.CronTask;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @program: simple-demo</span><br><span class="line"> * @description: 添加定时任务注册类，用来增加、删除定时任务。</span><br><span class="line"> * @author: CaoTing</span><br><span class="line"> * @date: 2019/5/23</span><br><span class="line"> **/</span><br><span class="line">@Component</span><br><span class="line">public class CronTaskRegistrar implements DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    private final Map&lt;Runnable, ScheduledTask&gt; scheduledTasks = new ConcurrentHashMap&lt;&gt;(16);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private TaskScheduler taskScheduler;</span><br><span class="line"></span><br><span class="line">    public TaskScheduler getScheduler() &#123;</span><br><span class="line">        return this.taskScheduler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增定时任务</span><br><span class="line">     * @param task</span><br><span class="line">     * @param cronExpression</span><br><span class="line">     */</span><br><span class="line">    public void addCronTask(Runnable task, String cronExpression) &#123;</span><br><span class="line">        addCronTask(new CronTask(task, cronExpression));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addCronTask(CronTask cronTask) &#123;</span><br><span class="line">        if (cronTask != null) &#123;</span><br><span class="line">            Runnable task = cronTask.getRunnable();</span><br><span class="line">            if (this.scheduledTasks.containsKey(task)) &#123;</span><br><span class="line">                removeCronTask(task);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.scheduledTasks.put(task, scheduleCronTask(cronTask));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除定时任务</span><br><span class="line">     * @param task</span><br><span class="line">     */</span><br><span class="line">    public void removeCronTask(Runnable task) &#123;</span><br><span class="line">        ScheduledTask scheduledTask = this.scheduledTasks.remove(task);</span><br><span class="line">        if (scheduledTask != null)</span><br><span class="line">            scheduledTask.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ScheduledTask scheduleCronTask(CronTask cronTask) &#123;</span><br><span class="line">        ScheduledTask scheduledTask = new ScheduledTask();</span><br><span class="line">        scheduledTask.future = this.taskScheduler.schedule(cronTask.getRunnable(), cronTask.getTrigger());</span><br><span class="line"></span><br><span class="line">        return scheduledTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        for (ScheduledTask task : this.scheduledTasks.values()) &#123;</span><br><span class="line">            task.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        this.scheduledTasks.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-定时任务执行类：SchedulingRunnable"><a href="#3-定时任务执行类：SchedulingRunnable" class="headerlink" title="3.定时任务执行类：SchedulingRunnable"></a>3.定时任务执行类：SchedulingRunnable</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">import com.caotinging.demo.utils.SpringContextUtils;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.util.ReflectionUtils;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.Objects;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @program: simple-demo</span><br><span class="line"> * @description: 定时任务运行类</span><br><span class="line"> * @author: CaoTing</span><br><span class="line"> * @date: 2019/5/23</span><br><span class="line"> **/</span><br><span class="line">public class SchedulingRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(SchedulingRunnable.class);</span><br><span class="line"></span><br><span class="line">    private String beanName;</span><br><span class="line"></span><br><span class="line">    private String methodName;</span><br><span class="line"></span><br><span class="line">    private Object[] params;</span><br><span class="line"></span><br><span class="line">    public SchedulingRunnable(String beanName, String methodName) &#123;</span><br><span class="line">        this(beanName, methodName, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SchedulingRunnable(String beanName, String methodName, Object...params ) &#123;</span><br><span class="line">        this.beanName = beanName;</span><br><span class="line">        this.methodName = methodName;</span><br><span class="line">        this.params = params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        logger.info(&quot;定时任务开始执行 - bean：&#123;&#125;，方法：&#123;&#125;，参数：&#123;&#125;&quot;, beanName, methodName, params);</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Object target = SpringContextUtils.getBean(beanName);</span><br><span class="line"></span><br><span class="line">            Method method = null;</span><br><span class="line">            if (null != params &amp;amp;&amp;amp; params.length &gt; 0) &#123;</span><br><span class="line">                Class&lt;?&gt;[] paramCls = new Class[params.length];</span><br><span class="line">                for (int i = 0; i &lt; params.length; i++) &#123;</span><br><span class="line">                    paramCls[i] = params[i].getClass();</span><br><span class="line">                &#125;</span><br><span class="line">                method = target.getClass().getDeclaredMethod(methodName, paramCls);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                method = target.getClass().getDeclaredMethod(methodName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ReflectionUtils.makeAccessible(method);</span><br><span class="line">            if (null != params &amp;amp;&amp;amp; params.length &gt; 0) &#123;</span><br><span class="line">                method.invoke(target, params);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                method.invoke(target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            logger.error(String.format(&quot;定时任务执行异常 - bean：%s，方法：%s，参数：%s &quot;, beanName, methodName, params), ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long times = System.currentTimeMillis() - startTime;</span><br><span class="line">        logger.info(&quot;定时任务执行结束 - bean：&#123;&#125;，方法：&#123;&#125;，参数：&#123;&#125;，耗时：&#123;&#125; 毫秒&quot;, beanName, methodName, params, times);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass()) return false;</span><br><span class="line">        SchedulingRunnable that = (SchedulingRunnable) o;</span><br><span class="line">        if (params == null) &#123;</span><br><span class="line">            return beanName.equals(that.beanName) &amp;amp;&amp;amp;</span><br><span class="line">                    methodName.equals(that.methodName) &amp;amp;&amp;amp;</span><br><span class="line">                    that.params == null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return beanName.equals(that.beanName) &amp;amp;&amp;amp;</span><br><span class="line">                methodName.equals(that.methodName) &amp;amp;&amp;amp;</span><br><span class="line">                params.equals(that.params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        if (params == null) &#123;</span><br><span class="line">            return Objects.hash(beanName, methodName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return Objects.hash(beanName, methodName, params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-定时任务控制类：ScheduledTask"><a href="#4-定时任务控制类：ScheduledTask" class="headerlink" title="4.定时任务控制类：ScheduledTask"></a>4.定时任务控制类：ScheduledTask</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ScheduledFuture;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @program: simple-demo</span><br><span class="line"> * @description: 定时任务控制类</span><br><span class="line"> * @author: CaoTing</span><br><span class="line"> * @date: 2019/5/23</span><br><span class="line"> **/</span><br><span class="line">public final class ScheduledTask &#123;</span><br><span class="line"></span><br><span class="line">    public volatile ScheduledFuture&lt;?&gt; future;</span><br><span class="line">    /**</span><br><span class="line">     * 取消定时任务</span><br><span class="line">     */</span><br><span class="line">    public void cancel() &#123;</span><br><span class="line">        ScheduledFuture&lt;?&gt; future = this.future;</span><br><span class="line">        if (future != null) &#123;</span><br><span class="line">            future.cancel(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-定时任务的测试"><a href="#5-定时任务的测试" class="headerlink" title="5.定时任务的测试"></a>5.定时任务的测试</h3><p>编写一个需要用于测试的任务类<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @program: simple-demo</span><br><span class="line"> * @description:</span><br><span class="line"> * @author: CaoTing</span><br><span class="line"> * @date: 2019/5/23</span><br><span class="line"> **/</span><br><span class="line">@Component(&quot;demoTask&quot;)</span><br><span class="line">public class DemoTask &#123;</span><br><span class="line"></span><br><span class="line">    public void taskWithParams(String param1, Integer param2) &#123;</span><br><span class="line">        System.out.println(&quot;这是有参示例任务：&quot; + param1 + param2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void taskNoParams() &#123;</span><br><span class="line">        System.out.println(&quot;这是无参示例任务&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>进行单元测试<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import com.caotinging.demo.application.DynamicTaskApplication;</span><br><span class="line">import com.caotinging.demo.application.SchedulingRunnable;</span><br><span class="line">import com.caotinging.demo.config.CronTaskRegistrar;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @program: simple-demo</span><br><span class="line"> * @description: 测试定时任务</span><br><span class="line"> * @author: CaoTing</span><br><span class="line"> * @date: 2019/5/23</span><br><span class="line"> **/</span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringBootTest(classes = DynamicTaskApplication.class)</span><br><span class="line">public class TaskTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    CronTaskRegistrar cronTaskRegistrar;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testTask() throws InterruptedException &#123;</span><br><span class="line">        SchedulingRunnable task = new SchedulingRunnable(&quot;demoTask&quot;, &quot;taskNoParams&quot;, null);</span><br><span class="line">        cronTaskRegistrar.addCronTask(task, &quot;0/10 * * * * ?&quot;);</span><br><span class="line"></span><br><span class="line">        // 便于观察</span><br><span class="line">        Thread.sleep(3000000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testHaveParamsTask() throws InterruptedException &#123;</span><br><span class="line">        SchedulingRunnable task = new SchedulingRunnable(&quot;demoTask&quot;, &quot;taskWithParams&quot;, &quot;haha&quot;, 23);</span><br><span class="line">        cronTaskRegistrar.addCronTask(task, &quot;0/10 * * * * ?&quot;);</span><br><span class="line"></span><br><span class="line">        // 便于观察</span><br><span class="line">        Thread.sleep(3000000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="6-工具类：SpringContextUtils"><a href="#6-工具类：SpringContextUtils" class="headerlink" title="6.工具类：SpringContextUtils"></a>6.工具类：SpringContextUtils</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.ApplicationContextAware;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @program: simple-demo</span><br><span class="line"> * @description: spring获取bean工具类</span><br><span class="line"> * @author: CaoTing</span><br><span class="line"> * @date: 2019/5/23</span><br><span class="line"> **/</span><br><span class="line">@Component</span><br><span class="line">public class SpringContextUtils implements ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    private static ApplicationContext applicationContext = null;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        if (SpringContextUtils.applicationContext == null) &#123;</span><br><span class="line">            SpringContextUtils.applicationContext = applicationContext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取applicationContext</span><br><span class="line">    public static ApplicationContext getApplicationContext() &#123;</span><br><span class="line">        return applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //通过name获取 Bean.</span><br><span class="line">    public static Object getBean(String name) &#123;</span><br><span class="line">        return getApplicationContext().getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //通过class获取Bean.</span><br><span class="line">    public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        return getApplicationContext().getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //通过name,以及Clazz返回指定的Bean</span><br><span class="line">    public static &lt;T&gt; T getBean(String name, Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        return getApplicationContext().getBean(name, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-我的pom依赖"><a href="#7-我的pom依赖" class="headerlink" title="7.我的pom依赖"></a>7.我的pom依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatisplus-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0.5&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.1.9&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.9&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 数据库--&gt;</span><br><span class="line">        &lt;!--&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;--&gt;</span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/com.hynnet/oracle-driver-ojdbc --&gt;</span><br><span class="line">        &lt;!--&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.oracle&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;11.2.0.1.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 单元测试 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--redisTemplate --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- http连接 restTemplate --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;httpclient-cache&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 工具--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.31&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-lang&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.6&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/com.google/guava --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;10.0.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- pinyin4j --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.belerweb&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;pinyin4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.5.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h3><p>建议移步github获取简单demo上手实践哦，在本文文首哦。有帮助的话点个赞吧，笔芯。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/06/01/SpringBoot实现动态控制定时任务-支持多参数/" data-id="cjyza2xxt001laf2aeliin5hx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-感受lambda之美，推荐收藏，需要时查阅" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/31/感受lambda之美，推荐收藏，需要时查阅/" class="article-date">
  <time datetime="2019-05-31T08:43:37.037Z" itemprop="datePublished">2019-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/31/感受lambda之美，推荐收藏，需要时查阅/">感受lambda之美，推荐收藏，需要时查阅</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文转载自 <a href="https://juejin.im/post/5ce66801e51d455d850d3a4a" target="_blank" rel="noopener">https://juejin.im/post/5ce66801e51d455d850d3a4a</a><br><a href="#h">一、引言</a><a href="#hjava">二、java重要的函数式接口</a><a href="#h1">1、什么是函数式接口</a><a href="#h11java8">1.1 java8自带的常用函数式接口。</a><a href="#h12">1.2 惰性求值与及早求值</a><a href="#h2">2、常用的流</a><a href="#h21collectcollectorstolist">2.1 collect(Collectors.toList())</a><a href="#h22filter">2.2 filter</a><a href="#h23map">2.3 map</a><a href="#h24flatmap">2.4 flatMap</a><a href="#h25maxmin">2.5 max和min</a><a href="#h26count">2.6 count</a><a href="#h27reduce">2.7 reduce</a><a href="#h-1">三、高级集合类及收集器</a><a href="#h31">3.1 转换成值</a><a href="#h32">3.2 转换成块</a><a href="#h33">3.3 数据分组</a><a href="#h34">3.4 字符串拼接</a><a href="#h-2">四、总结</a></p>
</blockquote>
<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>java8最大的特性就是引入Lambda表达式，即函数式编程，可以将行为进行传递。<strong>总结就是：使用不可变值与函数，函数对不可变值进行处理，映射成另一个值。</strong></p>
<h3 id="二、java重要的函数式接口"><a href="#二、java重要的函数式接口" class="headerlink" title="二、java重要的函数式接口"></a>二、java重要的函数式接口</h3><h3 id="1、什么是函数式接口"><a href="#1、什么是函数式接口" class="headerlink" title="1、什么是函数式接口"></a>1、什么是函数式接口</h3><p><strong>函数接口是只有一个抽象方法的接口，用作 Lambda 表达式的类型。使用@FunctionalInterface注解修饰的类，编译器会检测该类是否只有一个抽象方法或接口，否则，会报错。可以有多个默认方法，静态方法。</strong></p>
<h3 id="1-1-java8自带的常用函数式接口。"><a href="#1-1-java8自带的常用函数式接口。" class="headerlink" title="1.1 java8自带的常用函数式接口。"></a>1.1 java8自带的常用函数式接口。</h3><table>
<thead>
<tr>
<th align="center">函数接口</th>
<th align="center">抽象方法</th>
<th align="center">功能</th>
<th align="center">参数</th>
<th align="center">返回类型</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Predicate</td>
<td align="center">test(T t)</td>
<td align="center">判断真假</td>
<td align="center">T</td>
<td align="center">boolean</td>
<td align="center">9龙的身高大于185cm吗？</td>
</tr>
<tr>
<td align="center">Consumer</td>
<td align="center">accept(T t)</td>
<td align="center">消费消息</td>
<td align="center">T</td>
<td align="center">void</td>
<td align="center">输出一个值</td>
</tr>
<tr>
<td align="center">Function</td>
<td align="center">R apply(T t)</td>
<td align="center">将T映射为R（转换功能）</td>
<td align="center">T</td>
<td align="center">R</td>
<td align="center">获得student对象的名字</td>
</tr>
<tr>
<td align="center">Supplier</td>
<td align="center">T get()</td>
<td align="center">生产消息</td>
<td align="center">None</td>
<td align="center">T</td>
<td align="center">工厂方法</td>
</tr>
<tr>
<td align="center">UnaryOperator</td>
<td align="center">T apply(T t)</td>
<td align="center">一元操作</td>
<td align="center">T</td>
<td align="center">T</td>
<td align="center">逻辑非（!）</td>
</tr>
<tr>
<td align="center">BinaryOperator</td>
<td align="center">apply(T t, U u)</td>
<td align="center">二元操作</td>
<td align="center">(T，T)</td>
<td align="center">(T)</td>
<td align="center">求两个数的乘积（*）</td>
</tr>
<tr>
<td align="center"><code>{     {         Predicate&lt;Integer&gt; predicate = x -&gt; x &gt; ;         Student student =  Student(, , );         System.out.println(              + predicate.test(student.getStature()));         Consumer&lt;String&gt; consumer = System.out::println;         consumer.accept();         Function&lt;Student, String&gt; function = Student::getName;         String name = function.apply(student);         System.out.println(name);         Supplier&lt;Integer&gt; supplier =              () -&gt; Integer.valueOf(BigDecimal.TEN.toString());         System.out.println(supplier.get());         UnaryOperator&lt;Boolean&gt; unaryOperator = uglily -&gt; !uglily;         Boolean apply2 = unaryOperator.apply();         System.out.println(apply2);         BinaryOperator&lt;Integer&gt; operator = (x, y) -&gt; x * y;         Integer integer = operator.apply(, );         System.out.println(integer);         test(() -&gt; );     }          {         String work = worker.work();         System.out.println(work);     }      {         ;     } }</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>以上演示了lambda接口的使用及自定义一个函数式接口并使用。下面，我们看看java8将函数式接口封装到流中如何高效的帮助我们处理集合。</p>
<p><strong>注意：Student::getName</strong>例子中这种编写lambda表达式的方式称为<strong>方法引用。</strong>格式为<strong>ClassNmae::methodName</strong>。是不是很神奇，java8就是这么迷人。</p>
<p><strong>示例：本篇所有示例都基于以下三个类。OutstandingClass：班级；Student：学生；SpecialityEnum：特长。</strong><br><img src="https://user-gold-cdn.xitu.io/2019/5/23/16ae40638d420acd?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<h3 id="1-2-惰性求值与及早求值"><a href="#1-2-惰性求值与及早求值" class="headerlink" title="1.2 惰性求值与及早求值"></a>1.2 惰性求值与及早求值</h3><p><strong>惰性求值：只描述Stream，操作的结果也是Stream，这样的操作称为惰性求值。</strong>惰性求值可以像建造者模式一样链式使用，最后再使用及早求值得到最终结果。</p>
<p><strong>及早求值：得到最终的结果而不是Stream，这样的操作称为及早求值。</strong></p>
<h3 id="2、常用的流"><a href="#2、常用的流" class="headerlink" title="2、常用的流"></a>2、常用的流</h3><h3 id="2-1-collect-Collectors-toList"><a href="#2-1-collect-Collectors-toList" class="headerlink" title="2.1 collect(Collectors.toList())"></a>2.1 collect(Collectors.toList())</h3><p><strong>将流转换为list。还有toSet()，toMap()等。及早求值</strong>。
<code>{     {         List&lt;Student&gt; studentList = Stream.of( Student(, , ),                  Student(, , ),                  Student(, , )).collect(Collectors.toList());         System.out.println(studentList);     } }</code></p>
<h3 id="2-2-filter"><a href="#2-2-filter" class="headerlink" title="2.2 filter"></a>2.2 filter</h3><p>顾名思义，起<strong>过滤筛选</strong>的作用。<strong>内部就是Predicate接口。惰性求值。</strong><br><img src="https://user-gold-cdn.xitu.io/2019/5/23/16ae40638d2c0a51?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>比如我们筛选出出身高小于180的同学。</p>
<p><code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));         List&lt;Student&gt; list = students.stream()             .filter(stu -&gt; stu.getStature() &lt; )             .collect(Collectors.toList());         System.out.println(list);     } }</code></p>
<h3 id="2-3-map"><a href="#2-3-map" class="headerlink" title="2.3 map"></a>2.3 map</h3><p><strong>转换功能，内部就是Function接口。惰性求值</strong><br><img src="https://user-gold-cdn.xitu.io/2019/5/23/16ae40638d1c6610?imageView2/0/w/1280/h/960/ignore-error/1" alt> <code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));         List&lt;String&gt; names = students.stream().map(student -&gt; student.getName())                 .collect(Collectors.toList());         System.out.println(names);     } }</code></p>
<p>例子中将student对象转换为String对象，获取student的名字。</p>
<h3 id="2-4-flatMap"><a href="#2-4-flatMap" class="headerlink" title="2.4 flatMap"></a>2.4 flatMap</h3><p><strong>将多个Stream合并为一个Stream。惰性求值</strong><br><img src="https://user-gold-cdn.xitu.io/2019/5/23/16ae40638c4cca86?imageView2/0/w/1280/h/960/ignore-error/1" alt> <code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));         List&lt;Student&gt; studentList = Stream.of(students,                 asList( Student(, , ),                          Student(, , )))                 .flatMap(students1 -&gt; students1.stream()).collect(Collectors.toList());         System.out.println(studentList);     } }</code></p>
<p>调用Stream.of的静态方法将两个list转换为Stream，再通过flatMap将两个流合并为一个。</p>
<h3 id="2-5-max和min"><a href="#2-5-max和min" class="headerlink" title="2.5 max和min"></a>2.5 max和min</h3><p>我们经常会在集合中<strong>求最大或最小值</strong>，使用流就很方便。<strong>及早求值。</strong><br><code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));         Optional&lt;Student&gt; max = students.stream()             .max(Comparator.comparing(stu -&gt; stu.getAge()));         Optional&lt;Student&gt; min = students.stream()             .min(Comparator.comparing(stu -&gt; stu.getAge()));                   (max.isPresent()) {             System.out.println(max.get());         }          (min.isPresent()) {             System.out.println(min.get());         }     } }</code></p>
<p><strong>max、min接收一个Comparator</strong>（例子中使用java8自带的静态函数，只需要传进需要比较值即可。）并且返回一个Optional对象，该对象是java8新增的类，专门为了防止null引发的空指针异常。可以使用max.isPresent()判断是否有值；可以使用max.orElse(new Student())，当值为null时就使用给定值；也可以使用max.orElseGet(() -&gt; new Student());这需要传入一个Supplier的lambda表达式。</p>
<h3 id="2-6-count"><a href="#2-6-count" class="headerlink" title="2.6 count"></a>2.6 count</h3><p><strong>统计功能，一般都是结合filter使用，因为先筛选出我们需要的再统计即可。及早求值</strong><br><code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));          count = students.stream().filter(s1 -&gt; s1.getAge() &lt; ).count();         System.out.println( + count);     } }</code></p>
<h3 id="2-7-reduce"><a href="#2-7-reduce" class="headerlink" title="2.7 reduce"></a>2.7 reduce</h3><p><strong>reduce 操作可以实现从一组值中生成一个值</strong>。在上述例子中用到的 count 、 min 和 max 方<br>法，因为常用而被纳入标准库中。事实上，这些方法都是 reduce 操作。<strong>及早求值。</strong><br><img src="https://user-gold-cdn.xitu.io/2019/5/23/16ae40638c52397b?imageView2/0/w/1280/h/960/ignore-error/1" alt> <code>{     {         Integer reduce = Stream.of(, , , ).reduce(, (acc, x) -&gt; acc+ x);         System.out.println(reduce);     } }</code></p>
<p>我们看得reduce接收了一个初始值为0的累加器，依次取出值与累加器相加，最后累加器的值就是最终的结果。</p>
<h3 id="三、高级集合类及收集器"><a href="#三、高级集合类及收集器" class="headerlink" title="三、高级集合类及收集器"></a>三、高级集合类及收集器</h3><h3 id="3-1-转换成值"><a href="#3-1-转换成值" class="headerlink" title="3.1 转换成值"></a>3.1 转换成值</h3><p><strong>收集器，一种通用的、从流生成复杂值的结构。</strong>只要将它传给 collect 方法，所有<br>的流就都可以使用它了。标准类库已经提供了一些有用的收集器，<strong>以下示例代码中的收集器都是从 java.util.stream.Collectors 类中静态导入的。</strong><br><code>{     {         List&lt;Student&gt; students1 =  ArrayList&lt;&gt;();         students1.add( Student(, , ));         students1.add( Student(, , ));         students1.add( Student(, , ));         OutstandingClass ostClass1 =  OutstandingClass(, students1);                  List&lt;Student&gt; students2 =  ArrayList&lt;&gt;(students1);         students2.remove();         OutstandingClass ostClass2 =  OutstandingClass(, students2);                  Stream&lt;OutstandingClass&gt; classStream = Stream.of(ostClass1, ostClass2);         OutstandingClass outstandingClass = biggestGroup(classStream);         System.out.println( + outstandingClass.getName());         System.out.println( + averageNumberOfStudent(students1));     }          {          outstandingClasses.collect(                 maxBy(comparing(ostClass -&gt; ostClass.getStudents().size())))                 .orElseGet(OutstandingClass::);     }          {          students.stream().collect(averagingInt(Student::getAge));     } }</code></p>
<p>maxBy或者minBy就是求最大值与最小值。</p>
<h3 id="3-2-转换成块"><a href="#3-2-转换成块" class="headerlink" title="3.2 转换成块"></a>3.2 转换成块</h3><p><strong>常用的流操作是将其分解成两个集合，Collectors.partitioningBy帮我们实现了，接收一个Predicate函数式接口。</strong><br><img src="https://user-gold-cdn.xitu.io/2019/5/23/16ae4063943b9487?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p>将示例学生分为会唱歌与不会唱歌的两个集合。</p>
<p><code>{     {                  Map&lt;Boolean, List&lt;Student&gt;&gt; listMap = students.stream().collect(             Collectors.partitioningBy(student -&gt; student.getSpecialities().                                       contains(SpecialityEnum.SING)));     } }</code></p>
<h3 id="3-3-数据分组"><a href="#3-3-数据分组" class="headerlink" title="3.3 数据分组"></a>3.3 数据分组</h3><p>数据分组是一种更自然的分割数据操作，与将数据分成 ture 和 false 两部分不同，<strong>可以使</strong><br><strong>用任意值对数据分组。Collectors.groupingBy接收一个Function做转换。</strong><br><img src="https://user-gold-cdn.xitu.io/2019/5/23/16ae4063f5d78c78?imageView2/0/w/1280/h/960/ignore-error/1" alt></p>
<p><strong>如图，我们使用groupingBy将根据进行分组为圆形一组，三角形一组，正方形一组。</strong></p>
<p>例子：根据学生第一个特长进行分组<br><code>{     {                   Map&lt;SpecialityEnum, List&lt;Student&gt;&gt; listMap =               students.stream().collect(              Collectors.groupingBy(student -&gt; student.getSpecialities().get()));     } }</code></p>
<p><strong>Collectors.groupingBy与SQL 中的 group by 操作是一样的。</strong></p>
<h3 id="3-4-字符串拼接"><a href="#3-4-字符串拼接" class="headerlink" title="3.4 字符串拼接"></a>3.4 字符串拼接</h3><p>如果将所有学生的名字拼接起来，怎么做呢？通常只能创建一个StringBuilder，循环拼接。使用Stream，使用Collectors.joining()简单容易。<br><code>{     {         List&lt;Student&gt; students =  ArrayList&lt;&gt;();         students.add( Student(, , ));         students.add( Student(, , ));         students.add( Student(, , ));          String names = students.stream()              .map(Student::getName).collect(Collectors.joining(,,));         System.out.println(names);     } }</code></p>
<p><strong>joining接收三个参数，第一个是分界符，第二个是前缀符，第三个是结束符。也可以不传入参数Collectors.joining()，这样就是直接拼接。</strong></p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>本篇主要从实际使用讲述了常用的方法及流，使用java8可以很清晰表达你要做什么，代码也很简洁。本篇例子主要是为了讲解较为简单，大家可以去使用java8重构自己现有的代码，自行领会lambda的奥妙。本文说的Stream要组合使用才会发挥更大的功能，链式调用很迷人，根据自己的业务去做吧。</p>
<p><strong>整理不易，希望点赞支持支持。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/31/感受lambda之美，推荐收藏，需要时查阅/" data-id="cjyza2xxz001xaf2ayvax0fk4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-README" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/30/README/" class="article-date">
  <time datetime="2019-05-30T00:52:25.412Z" itemprop="datePublished">2019-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="My-Reading-Notes"><a href="#My-Reading-Notes" class="headerlink" title="My Reading Notes"></a>My Reading Notes</h1><blockquote>
<p><a href="mailto:huan.dreamer@gmail.com" target="_blank" rel="noopener">huan.dreamer@gmail.com</a></p>
</blockquote>
<h2 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h2><ol>
<li>《Docker技术入门与实践》 杨保华  等</li>
<li>《腾讯传1998-2016：中国互联网公司计划论》 吴晓波</li>
<li>《史蒂芬·乔布斯传》 沃尔特·艾萨克森</li>
<li>《激荡十年，水大鱼大：中国企业2008-2018》 吴晓波</li>
<li>《Spring Cloud微服务实战》 翟永超</li>
<li>《人月神话（40周年中文纪念版）》 布鲁克斯</li>
<li>《乔布斯离开了，马斯克来了》 竹内一正</li>
<li>《深入理解Java虚拟机》 周志明</li>
<li>《产品的视角：从热闹到门道》 后显慧</li>
<li>《大型网站技术架构 核心原理与案例分析》 李智慧</li>
<li>《Effective Java中文版 第二版》Joshua Bloch</li>
<li>《操作系统之哲学原理》 邹恒明</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/30/README/" data-id="cjyza2xx7000eaf2amc9rputv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Effective Java" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/30/Effective Java/" class="article-date">
  <time datetime="2019-05-30T00:52:25.400Z" itemprop="datePublished">2019-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="对象的创建和销毁"><a href="#对象的创建和销毁" class="headerlink" title="对象的创建和销毁"></a>对象的创建和销毁</h1><h3 id="一、使用静态工厂方法代替构造器"><a href="#一、使用静态工厂方法代替构造器" class="headerlink" title="一、使用静态工厂方法代替构造器"></a>一、使用静态工厂方法代替构造器</h3><ol>
<li>静态工厂优势一：有名称。当一个类需要多个带有相同签名的构造器时，可以通过名称突出它们之间的区别</li>
<li>静态工程优势二：不必每次都创建新的对象。可以将创建的实例缓存，或者是返回预先构建好的实例(工厂模式)。例如 <code>Boolean.valueOf(boolean)</code>。如果确保了每次返回的都是同一对象的话，可以使用<code>==</code>进行判断，提升效率</li>
<li>静态工厂优势三：可以返回原返回类型的任何子类的对象，可以返回受保护的类的对象。例如<code>Collections.singletonList(T)</code>、<code>EnumSet</code>。</li>
</ol>
<h3 id="二、遇到多个构造器参数时要考虑用构造器"><a href="#二、遇到多个构造器参数时要考虑用构造器" class="headerlink" title="二、遇到多个构造器参数时要考虑用构造器"></a>二、遇到多个构造器参数时要考虑用构造器</h3><p>​    Builder 模式。这个就不必多少了，当构造器参数很多，并且都是可选时，推荐使用builder。也可以提供一个<code>DefaultInstance</code>，返回具有默认参数的对象。推荐一个工具 <a href="https://www.projectlombok.org/" target="_blank" rel="noopener">lombok</a> ,使用注解生成样板代码。</p>
<h3 id="三、使用私有构造器或者枚举类型强化-Singleton-属性"><a href="#三、使用私有构造器或者枚举类型强化-Singleton-属性" class="headerlink" title="三、使用私有构造器或者枚举类型强化 Singleton 属性"></a>三、使用私有构造器或者枚举类型强化 Singleton 属性</h3><p>​    使构造器私有，通过创建<code>getInstance</code>方法，返回该类的唯一<code>private static final</code>的实例。好处在于，在不改变API的前提下，可以改变方法实现，从而对类是否为<code>Singleton</code>。但是客户端可以使用<code>AccessibleObject.setAccessible</code>方法，通过反射调用私有构造器。</p>
<p>​    实现<code>Singleton</code>还可以使用<code>Enum</code>。</p>
<h3 id="四、通过私有构造器强化不可变实例化的能力"><a href="#四、通过私有构造器强化不可变实例化的能力" class="headerlink" title="四、通过私有构造器强化不可变实例化的能力"></a>四、通过私有构造器强化不可变实例化的能力</h3><p>​    例如工具类，不希望客户端对它进行实例化（实例化没有任何意义），可以创建私有的无参构造函数进行屏蔽对象的创建。NERVER：企图通过做成抽象类来强制该类不能被实例化，这样会引起误解。</p>
<h3 id="五、避免创建不必要的对象"><a href="#五、避免创建不必要的对象" class="headerlink" title="五、避免创建不必要的对象"></a>五、避免创建不必要的对象</h3><ol>
<li><p>避免 <code>String s = new String(&quot;***&quot;)</code>的操作</p>
</li>
<li><p>需要重复使用的对象，应该将实例进行缓存，而不是每次都创建。例如判断一个人是否为2000年后出生，应该将<code>2000-1-1</code>进行缓存，再和他的出生日期进行比较</p>
</li>
<li><p><code>适配器模式</code>中，没有必要创建多个适配器对象。例如<code>Map.keySet()</code>方法，就会将<code>ks</code>对象进行缓存。每次都返回同一个对象</p>
</li>
<li><p>避免大量的<code>自动装箱</code>操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Long sum = <span class="number">0L</span>; 	<span class="comment">// 使用 long sum = 0L 可以避免自动装箱，节省大量资源</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span>  i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i ++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/30/Effective Java/" data-id="cjyza2xx40008af2amcd2qgw9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/30/hello-world/" class="article-date">
  <time datetime="2019-05-30T00:45:32.658Z" itemprop="datePublished">2019-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/30/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sillyfan.top/2019/05/30/hello-world/" data-id="cjyza2xxf000saf2a8vrb76qb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HDFS/">HDFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactor/">Reactor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/">RxJava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue-js/">Vue.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端/">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微服务/">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/HDFS/" style="font-size: 10px;">HDFS</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 13.33px;">MySQL</a> <a href="/tags/Reactor/" style="font-size: 10px;">Reactor</a> <a href="/tags/RxJava/" style="font-size: 10px;">RxJava</a> <a href="/tags/Shell/" style="font-size: 10px;">Shell</a> <a href="/tags/Spring/" style="font-size: 13.33px;">Spring</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP/IP</a> <a href="/tags/Vue-js/" style="font-size: 10px;">Vue.js</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/后端/" style="font-size: 10px;">后端</a> <a href="/tags/微服务/" style="font-size: 10px;">微服务</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/服务器/" style="font-size: 10px;">服务器</a> <a href="/tags/架构/" style="font-size: 16.67px;">架构</a> <a href="/tags/源码/" style="font-size: 10px;">源码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/06/万万没想到，JVM内存结构的面试题可以问的这么难？/">万万没想到，JVM内存结构的面试题可以问的这么难？</a>
          </li>
        
          <li>
            <a href="/2019/06/28/分布式数据库中间件MyCat搞起来！/">分布式数据库中间件 MyCat 搞起来！</a>
          </li>
        
          <li>
            <a href="/2019/06/20/Linux生产环境上，最常用的一套“AWK“技巧/">Linux生产环境上，最常用的一套“AWK“技巧</a>
          </li>
        
          <li>
            <a href="/2019/06/18/死磕Java内部类（一篇就够）/">死磕Java内部类（一篇就够）</a>
          </li>
        
          <li>
            <a href="/2019/06/06/面试那点小事，你从未见过的springboot面试集锦（附详细答案）/">面试那点小事，你从未见过的spring boot面试集锦（附详细答案）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 huan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>